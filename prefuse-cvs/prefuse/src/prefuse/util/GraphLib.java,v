head	2.1;
access;
symbols
	java_1_5:2.1.0.4
	Root_java_1_5:2.1
	beta:2.1.0.2
	beta-20080113:2.1
	beta-20071021:2.1
	beta-20060220:2.1
	beta-20060209:2.0;
locks; strict;
comment	@# @;


2.1
date	2006.02.20.09.34.36;	author jheer;	state Exp;
branches
	2.1.4.1;
next	2.0;

2.0
date	2006.02.12.18.23.45;	author jheer;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.30.09.13.31;	author jheer;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2005.12.30.09.13.31;	author jheer;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2006.01.16.20.07.41;	author jheer;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2006.01.23.22.08.47;	author jheer;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2006.01.30.09.08.06;	author jheer;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2006.02.07.00.42.29;	author jheer;	state Exp;
branches;
next	;

2.1.4.1
date	2008.01.23.23.55.36;	author jogiles;	state Exp;
branches;
next	;


desc
@@


2.1
log
@Added honeycomb generator.
Added missing labels in diamond tree generator.
@
text
@package prefuse.util;

import java.util.ArrayList;

import prefuse.data.Graph;
import prefuse.data.Node;
import prefuse.data.Schema;
import prefuse.data.Tree;

/**
 * Library routines for creating various Graph structures. All Graphs
 * generated by methods of this class include a String-valued
 * "label" field.
 * 
 * @@author <a href="http://jheer.org">jeffrey heer</a>
 */
public class GraphLib {

    private GraphLib() {
        // prevent instantiation
    }
    
    // ------------------------------------------------------------------------
    // Graph Creation Routines
    
    /**
     * Builds a completely unconnected (edge-free) graph with the given 
     * number of nodes
     * @@param n the number of nodes
     * @@return a graph with n nodes and no edges
     */
    public static Graph getNodes(int n) {
        Graph g = new Graph();
        g.getNodeTable().addColumns(LABEL_SCHEMA);
        
        for ( int i=0; i < n; i++ ) {
            Node node = g.addNode();
            node.setString(LABEL, String.valueOf(i));
        }
        return g;
    }
    
    /**
     * Builds a "star" graph with one central hub connected to the given
     * number of satellite nodes.
     * @@param n the number of points of the star
     * @@return a "star" graph with n points, for a total of n+1 nodes
     */
    public static Graph getStar(int n) {
        Graph g = new Graph();
        g.getNodeTable().addColumns(LABEL_SCHEMA);
        
        Node r = g.addNode();
        r.setString(LABEL, "0");
        
        for ( int i=1; i <= n; ++i ) {
            Node nn = g.addNode();
            nn.setString(LABEL, String.valueOf(i));
            g.addEdge(r, nn);
        }
        return g;
    }
    
    /**
     * Returns a clique of given size. A clique is a graph in which every node
     * is a neighbor of every other node.
     * @@param n the number of nodes in the graph
     * @@return a clique of size n
     */
    public static Graph getClique(int n) {
        Graph g = new Graph();
        g.getNodeTable().addColumns(LABEL_SCHEMA);
        
        Node nodes[] = new Node[n];
        for ( int i = 0; i < n; ++i ) {
            nodes[i] = g.addNode();
            nodes[i].setString(LABEL, String.valueOf(i));
        }
        for ( int i = 0; i < n; ++i ) {
            for ( int j = i; j < n; ++j )
                if ( i != j )
                    g.addEdge(nodes[i], nodes[j]);
        }
        return g;
    }
    
    /**
     * Returns a graph structured as an m-by-n grid.
     * @@param m the number of rows of the grid
     * @@param n the number of columns of the grid
     * @@return an m-by-n grid structured graph
     */
    public static Graph getGrid(int m, int n) {
        Graph g = new Graph();
        g.getNodeTable().addColumns(LABEL_SCHEMA);
        
        Node[] nodes = new Node[m*n];
        for ( int i = 0; i < m*n; ++i ) {
            nodes[i] = g.addNode();
            nodes[i].setString(LABEL, String.valueOf(i));
            
            if ( i >= n )
                g.addEdge(nodes[i-n], nodes[i]);
            if ( i % n != 0 )
                g.addEdge(nodes[i-1], nodes[i]);
        }
        return g;
    }
    
    public static Graph getHoneycomb(int levels) {
        Graph g = new Graph();
        g.getNodeTable().addColumns(LABEL_SCHEMA);
        ArrayList layer1 = halfcomb(g, levels);
        ArrayList layer2 = halfcomb(g, levels);
        for ( int i=0; i<(levels<<1); ++i ) {
            Node n1 = (Node)layer1.get(i);
            Node n2 = (Node)layer2.get(i);
            g.addEdge(n1, n2);
        }
        return g;
    }
    
    private static ArrayList halfcomb(Graph g, int levels) {
        ArrayList top   = new ArrayList();
        ArrayList layer = new ArrayList();
        
        int label = 0;
        
        for ( int i=0; i<levels; ++i ) {
            Node n = g.addNode();
            n.setString(LABEL, String.valueOf(label++));
            top.add(n);
        }
        for ( int i=0; i<levels; ++i ) {
            Node n = null;
            for ( int j=0; j<top.size(); ++j ) {
                Node p = (Node)top.get(j);
                if ( n == null ) {
                    n = g.addNode();
                    n.setString(LABEL, String.valueOf(label++));
                    layer.add(n);
                }
                g.addEdge(p, n);
                n = g.addNode();
                n.setString(LABEL, String.valueOf(label++));
                layer.add(n);
                g.addEdge(p, n);
            }
            if ( i == levels-1 ) {
                return layer;
            }
            top.clear();
            for ( int j=0; j<layer.size(); ++j ) {
                Node p = (Node)layer.get(j);
                n = g.addNode();
                n.setString(LABEL, String.valueOf(label++));
                top.add(n);
                g.addEdge(p, n);
            }
            layer.clear();
        }
        // should never happen
        return top;
    }
    
    /**
     * Returns a balanced tree of the requested breadth and depth.
     * @@param breadth the breadth of each level of the tree
     * @@param depth the depth of the tree
     * @@return a balanced tree
     */
    public static Tree getBalancedTree(int breadth, int depth) {
        Tree t = new Tree();
        t.getNodeTable().addColumns(LABEL_SCHEMA);
        
        Node r = t.addRoot();
        r.setString(LABEL, "0,0");
        
        if ( depth > 0 )
            balancedHelper(t, r, breadth, depth-1);
        return t;
    }
    
    private static void balancedHelper(Tree t, Node n, 
            int breadth, int depth)
    {
        for ( int i=0; i<breadth; ++i ) {
            Node c = t.addChild(n);
            c.setString(LABEL, i+","+c.getDepth());
            if ( depth > 0 )
                balancedHelper(t,c,breadth,depth-1);
        }
    }
    
    /**
     * Returns a left deep binary tree
     * @@param depth the depth of the tree
     * @@return the generated tree
     */
    public static Tree getLeftDeepTree(int depth) {
        Tree t = new Tree();
        t.getNodeTable().addColumns(LABEL_SCHEMA);
        
        Node r = t.addRoot();
        r.setString(LABEL, "0,0");
        
        deepHelper(t, r, 2, depth, true);
        return t;
    }
    
    /**
     * Returns a right deep binary tree
     * @@param depth the depth of the tree
     * @@return the generated Tree
     */
    public static Tree getRightDeepTree(int depth) {
        Tree t = new Tree();
        t.getNodeTable().addColumns(LABEL_SCHEMA);
        
        Node r = t.addRoot();
        r.setString(LABEL, "0,0");
        
        deepHelper(t, r, 2, depth, false);
        return t;
    }
    
    /**
     * Create a diamond tree, with a given branching factor at
     * each level, and depth levels for the two main branches.
     * @@param b the number of children of each branch node
     * @@param d1 the length of the first (left) branch
     * @@param d2 the length of the second (right) branch
     * @@return the generated Tree
     */
    public static Tree getDiamondTree(int b, int d1, int d2) {
        Tree t = new Tree();
        t.getNodeTable().addColumns(LABEL_SCHEMA);
        
        Node r = t.addRoot();
        r.setString(LABEL, "0,0");
        
        Node left = t.addChild(r);
        left.setString(LABEL, "1,0");
        Node right = t.addChild(r);
        right.setString(LABEL, "1,1");
        
        deepHelper(t, left, b, d1-2, true);
        deepHelper(t, right, b, d1-2, false);
        
        while ( left.getFirstChild() != null )
            left = left.getFirstChild();
        while ( right.getLastChild() != null )
            right = right.getLastChild();
        
        deepHelper(t, left, b, d2-1, false);
        deepHelper(t, right, b, d2-1, true);
        
        return t;
    }
    
    private static void deepHelper(Tree t, Node n, 
            int breadth, int depth, boolean left)
    {
        Node c = t.addChild(n);
        c.setString(LABEL, "0,"+c.getDepth());
        if ( left && depth > 0 )
            deepHelper(t, c, breadth, depth-1, left);
        
        for ( int i=1; i<breadth; ++i ) {
            c = t.addChild(n);
            c.setString(LABEL, i+","+c.getDepth());
        }
        if ( !left && depth > 0 )
            deepHelper(t, c, breadth, depth-1, left);
    }
    
    
    // ------------------------------------------------------------------------
    
    /** Label data field included in generated Graphs */
    public static final String LABEL = "label";
    /** Node table schema used for generated Graphs */
    public static final Schema LABEL_SCHEMA = new Schema();
    static {
        LABEL_SCHEMA.addColumn(LABEL, String.class, "");
    }
    
} // end of class GraphLib
@


2.1.4.1
log
@First import of a Java 1.5-targetted version of prefuse.
@
text
@a3 1
import java.util.List;
a4 1
import prefuse.data.Edge;
a8 3
import prefuse.data.tuple.TableEdge;
import prefuse.data.tuple.TableNode;
import prefuse.data.tuple.TableTuple;
d14 1
a14 1
 *
d22 1
a22 1

d25 1
a25 1

d27 1
a27 1
     * Builds a completely unconnected (edge-free) graph with the given
d32 2
a33 2
    public static Graph<TableTuple<?>,TableNode,TableEdge> getNodes(int n) {
        Graph<TableTuple<?>,TableNode,TableEdge> g = Graph.createGraph();
d35 1
a35 1

d37 1
a37 1
            TableNode node = g.addNode();
d42 1
a42 1

d49 2
a50 3
    public static Graph<TableTuple<?>,TableNode,TableEdge> getStar(int n) {
        Graph<TableTuple<?>,TableNode,TableEdge> g = Graph.createGraph();

d52 2
a53 3
        g.getEdgeTable().addColumns(LABEL_SCHEMA);

        TableNode r = g.addNode();
d55 1
a55 1

d57 1
a57 1
            TableNode nn = g.addNode();
d59 1
a59 2
            TableEdge e = g.addEdge(r, nn);
            e.setString(LABEL, "0-" + nn );
d63 1
a63 1

d70 2
a71 2
    public static Graph<TableTuple<?>,TableNode,TableEdge> getClique(int n) {
        Graph<TableTuple<?>,TableNode,TableEdge> g = Graph.createGraph();
d73 2
a74 3
        g.getEdgeTable().addColumns(LABEL_SCHEMA);

        TableNode nodes[] = new TableNode[n];
d80 3
a82 6
            for ( int j = i; j < n; ++j ) {
				if ( i != j ) {
                    TableEdge e = g.addEdge(nodes[i], nodes[j]);
                    e.setString(LABEL, i + "-" + j);
                }
			}
d86 1
a86 1

d93 2
a94 2
    public static Graph<TableTuple<?>,TableNode,TableEdge> getGrid(int m, int n) {
        Graph<TableTuple<?>,TableNode,TableEdge> g = Graph.createGraph();
d96 2
a97 3
        g.getEdgeTable().addColumns(LABEL_SCHEMA);

        TableNode[] nodes = new TableNode[m*n];
d101 5
a105 9

            if ( i >= n ) {
                TableEdge e = g.addEdge(nodes[i-n], nodes[i]);
                e.setString(LABEL, i-n + "-" + i);
            }
            if ( i % n != 0 ) {
                TableEdge e = g.addEdge(nodes[i-1], nodes[i]);
                e.setString(LABEL, i-1 + "-" + i);
            }
d109 3
a111 3

    public static Graph<TableTuple<?>,TableNode,TableEdge> getHoneycomb(int levels) {
        Graph<TableTuple<?>,TableNode,TableEdge> g = Graph.createGraph();
d113 6
a118 8
        g.getEdgeTable().addColumns(LABEL_SCHEMA);
        List<TableNode> layer1 = halfcomb(g, levels);
        List<TableNode> layer2 = halfcomb(g, levels);
        for ( int i=0; i<levels<<1; ++i ) {
            TableNode n1 = layer1.get(i);
            TableNode n2 = layer2.get(i);
            TableEdge e = g.addEdge(n1, n2);
            e.setString(LABEL, n1.getString(LABEL) + "-" + n2.getString(LABEL));
d122 5
a126 5

    private static <N extends Node<N,E>,E extends Edge<N,E>> List<N> halfcomb(Graph<?,N,E> g, int levels) {
        List<N> top   = new ArrayList<N>();
        List<N> layer = new ArrayList<N>();

d128 1
a128 1

d130 1
a130 1
            N n = g.addNode();
d135 1
a135 1
            N n = null;
d137 1
a137 1
                N p = top.get(j);
d143 1
a143 2
                Edge<N,E> e = g.addEdge(p, n);
                e.setString(LABEL, p.getString(LABEL) + "-" + n.getString(LABEL));
d147 1
a147 2
                e = g.addEdge(p, n);
                e.setString(LABEL, p.getString(LABEL) + "-" + n.getString(LABEL));
d154 1
a154 1
                N p = layer.get(j);
d158 1
a158 2
                Edge<N,E> e = g.addEdge(p, n);
                e.setString(LABEL, p.getString(LABEL) + "-" + n.getString(LABEL));
d165 1
a165 1

d172 2
a173 2
    public static Tree<TableTuple<?>,TableNode,TableEdge> getBalancedTree(int breadth, int depth) {
        Tree<TableTuple<?>,TableNode,TableEdge> t = Tree.createTree();
d175 2
a176 2

        TableNode r = t.addRoot();
d178 3
a180 4

        if ( depth > 0 ) {
			balancedHelper(t, r, breadth, depth-1);
		}
d183 2
a184 2

    private static <N extends Node<N,?>> void balancedHelper(Tree<?,N,?> t, N n,
d188 1
a188 1
            N c = t.addChild(n);
d190 2
a191 3
            if ( depth > 0 ) {
				balancedHelper(t,c,breadth,depth-1);
			}
d194 1
a194 1

d200 2
a201 3
    public static Tree<TableTuple<?>,TableNode,TableEdge> getLeftDeepTree(int depth) {
        Tree<TableTuple<?>,TableNode,TableEdge> t = Tree.createTree();

d203 2
a204 2

        TableNode r = t.addRoot();
d206 1
a206 1

d210 1
a210 1

d216 2
a217 3
    public static Tree<TableTuple<?>,TableNode,TableEdge> getRightDeepTree(int depth) {
        Tree<TableTuple<?>,TableNode,TableEdge> t = Tree.createTree();

d219 2
a220 2

        TableNode r = t.addRoot();
d222 1
a222 1

d226 1
a226 1

d235 2
a236 3
    public static Tree<TableTuple<?>,TableNode,TableEdge> getDiamondTree(int b, int d1, int d2) {
        Tree<TableTuple<?>,TableNode,TableEdge> t = Tree.createTree();

d238 2
a239 2

        TableNode r = t.addRoot();
d241 2
a242 2

        TableNode left = t.addChild(r);
d244 1
a244 1
        TableNode right = t.addChild(r);
d246 1
a246 1

d249 6
a254 12

        List<TableNode> children = left.children();
        while ( !children.isEmpty()) {
			left = children.get(0);
			children = left.children();
		}
        children = right.children();
        while ( !children.isEmpty()) {
			right = children.get(children.size() - 1);
			children = right.children();
		}

d257 1
a257 1

d260 2
a261 2

    private static <N extends Node<N,?>> void deepHelper(Tree<?,N,?> t, N n,
d264 1
a264 1
        N c = t.addChild(n);
d266 3
a268 4
        if ( left && depth > 0 ) {
			deepHelper(t, c, breadth, depth-1, left);
		}

d273 2
a274 3
        if ( !left && depth > 0 ) {
			deepHelper(t, c, breadth, depth-1, left);
		}
d276 2
a277 2


d279 1
a279 1

d287 1
a287 1

@


2.0
log
@Merge beta branch back onto main trunk
@
text
@d3 2
d110 56
d243 1
d245 1
d269 4
a272 5
        for ( int i=1; i<breadth-1; ++i )
            t.addChild(n);
        
        c = t.addChild(n);
        c.setString(LABEL, "1,"+c.getDepth());
@


1.1
log
@file GraphLib.java was initially added on branch beta.
@
text
@d1 229
@


1.1.2.1
log
@Initial commit of prefuse beta
@
text
@a0 218
package prefuse.util;

import prefuse.data.Graph;
import prefuse.data.Schema;
import prefuse.data.Tree;
import prefuse.data.tuple.Node;
import prefuse.data.tuple.TreeNode;



/**
 * @@author <a href="http://jheer.org">jeffrey heer</a> - prefuse(AT)jheer.org
 */
public class GraphLib {

    private GraphLib() {
        // prevent instantiation
    }
    
    // ------------------------------------------------------------------------
    // Graph Creation Routines
    
    /**
     * Builds a completely unconnected (edge-free) graph with the given 
     * number of nodes
     * @@param n the number of nodes
     * @@return a graph with n nodes and no edges
     */
    public static Graph getNodes(int n) {
        Graph g = new Graph();
        g.getNodeTable().addColumns(LABEL_SCHEMA);
        
        for ( int i=0; i < n; i++ ) {
            Node node = g.addNode();
            node.setString(String.valueOf(i), LABEL);
        }
        return g;
    }
    
    /**
     * Builds a "star" graph with one central hub connected to the given
     * number of satellite nodes.
     * @@param n the number of points of the star
     * @@return a "star" graph with n points, for a total of n+1 nodes
     */
    public static Graph getStar(int n) {
        Graph g = new Graph();
        g.getNodeTable().addColumns(LABEL_SCHEMA);
        
        Node r = g.addNode();
        r.setString("0", LABEL);
        
        for ( int i=1; i <= n; ++i ) {
            Node nn = g.addNode();
            nn.setString(String.valueOf(i), LABEL);
            g.addEdge(r, nn);
        }
        return g;
    }
    
    /**
     * Returns a clique of given size. A clique is a graph in which every node
     * is a neighbor of every other node.
     * @@param n the number of nodes in the graph
     * @@return a clique of size n
     */
    public static Graph getClique(int n) {
        Graph g = new Graph();
        g.getNodeTable().addColumns(LABEL_SCHEMA);
        
        Node nodes[] = new Node[n];
        for ( int i = 0; i < n; ++i ) {
            nodes[i] = g.addNode();
            nodes[i].setString(String.valueOf(i), LABEL);
        }
        for ( int i = 0; i < n; ++i ) {
            for ( int j = i; j < n; ++j )
                if ( i != j )
                    g.addEdge(nodes[i], nodes[j]);
        }
        return g;
    }
    
    /**
     * Returns a graph structured as an m-by-n grid.
     * @@param m the number of rows of the grid
     * @@param n the number of columns of the grid
     * @@return an m-by-n grid structured graph
     */
    public static Graph getGrid(int m, int n) {
        Graph g = new Graph();
        g.getNodeTable().addColumns(LABEL_SCHEMA);
        
        Node[] nodes = new Node[m*n];
        for ( int i = 0; i < m*n; ++i ) {
            nodes[i] = g.addNode();
            nodes[i].setString(String.valueOf(i), LABEL);
            
            if ( i >= n )
                g.addEdge(nodes[i-n], nodes[i]);
            if ( i % n != 0 )
                g.addEdge(nodes[i-1], nodes[i]);
        }
        return g;
    }
    
    /**
     * Returns a balanced tree of the requested breadth and depth.
     * @@param breadth the breadth of each level of the tree
     * @@param depth the depth of the tree
     * @@return a balanced tree
     */
    public static Tree getBalancedTree(int breadth, int depth) {
        Tree t = new Tree();
        t.getNodeTable().addColumns(LABEL_SCHEMA);
        
        TreeNode r = t.addRoot();
        r.setString("0,0", LABEL);
        
        if ( depth > 0 )
            balancedHelper(t, r, breadth, depth-1);
        return t;
    }
    
    private static void balancedHelper(Tree t, TreeNode n, 
            int breadth, int depth)
    {
        for ( int i=0; i<breadth; ++i ) {
            TreeNode c = t.addChild(n);
            c.setString(i+","+c.getDepth(), LABEL);
            if ( depth > 0 )
                balancedHelper(t,c,breadth,depth-1);
        }
    }
    
    /**
     * Returns a left deep binary tree
     * @@param depth the depth of the tree
     * @@return the generated tree
     */
    public static Tree getLeftDeepTree(int depth) {
        Tree t = new Tree();
        t.getNodeTable().addColumns(LABEL_SCHEMA);
        
        TreeNode r = t.addRoot();
        r.setString("0,0", LABEL);
        
        deepHelper(t, r, 2, depth, true);
        return t;
    }
    
    /**
     * Returns a right deep binary tree
     * @@param depth the depth of the tree
     * @@return the generated tree
     */
    public static Tree getRightDeepTree(int depth) {
        Tree t = new Tree();
        t.getNodeTable().addColumns(LABEL_SCHEMA);
        
        TreeNode r = t.addRoot();
        r.setString("0,0", LABEL);
        
        deepHelper(t, r, 2, depth, false);
        return t;
    }
    
    public static Tree getDiamondTree(int b, int d1, int d2) {
        Tree t = new Tree();
        t.getNodeTable().addColumns(LABEL_SCHEMA);
        
        TreeNode r = t.addRoot();
        r.setString("0,0", LABEL);
        
        TreeNode left = t.addChild(r);
        TreeNode right = t.addChild(r);
        
        deepHelper(t, left, b, d1-2, true);
        deepHelper(t, right, b, d1-2, false);
        
        while ( left.getFirstChild() != null )
            left = left.getFirstChild();
        while ( right.getLastChild() != null )
            right = right.getLastChild();
        
        deepHelper(t, left, b, d2-1, false);
        deepHelper(t, right, b, d2-1, true);
        
        return t;
    }
    
    private static void deepHelper(Tree t, TreeNode n, 
            int breadth, int depth, boolean left)
    {
        TreeNode c = t.addChild(n);
        c.setString("0,"+c.getDepth(), LABEL);
        if ( left && depth > 0 )
            deepHelper(t, c, breadth, depth-1, left);
        
        for ( int i=1; i<breadth-1; ++i )
            t.addChild(n);
        
        c = t.addChild(n);
        c.setString("1,"+c.getDepth(), LABEL);
        if ( !left && depth > 0 )
            deepHelper(t, c, breadth, depth-1, left);
    }
    
    
    // ------------------------------------------------------------------------
    
    public static final String LABEL = "label";
    public static final Schema LABEL_SCHEMA = new Schema();
    static {
        LABEL_SCHEMA.addColumn(LABEL, String.class, "");
    }
    
} // end of class GraphLib
@


1.1.2.2
log
@Table method refactoring. Added PredicateChain, included in ColorFunction, SizeFunction, and RendererFactory. Added ItemBoundsListener, included in GraphView demo. Updated ColorMap to use int representation, moved palette creators to ColorLib. Added minExtent to JRangeSlider. Fixed round-off rendering glitches int optimized rendering, added RenderingAccuracy test class. Updated PrefuseConfig to support logging output to file system. Added DelmitedTextTableWriter. Added CompositeTupleSet. Added directionality to edges, increased support to EdgeRenderer, including reversed directionality.
@
text
@d35 1
a35 1
            node.setString(LABEL, String.valueOf(i));
d51 1
a51 1
        r.setString(LABEL, "0");
d55 1
a55 1
            nn.setString(LABEL, String.valueOf(i));
d74 1
a74 1
            nodes[i].setString(LABEL, String.valueOf(i));
d97 1
a97 1
            nodes[i].setString(LABEL, String.valueOf(i));
d118 1
a118 1
        r.setString(LABEL, "0,0");
d130 1
a130 1
            c.setString(LABEL, i+","+c.getDepth());
d146 1
a146 1
        r.setString(LABEL, "0,0");
d162 1
a162 1
        r.setString(LABEL, "0,0");
d173 1
a173 1
        r.setString(LABEL, "0,0");
d196 1
a196 1
        c.setString(LABEL, "0,"+c.getDepth());
d204 1
a204 1
        c.setString(LABEL, "1,"+c.getDepth());
@


1.1.2.3
log
@Added support for aggregates as a visual data type (AggregateItem, AggregateTable).
Added listener callback to DataSourceWorker.
Reworked graph representation to use an internal table of adjacency lists (the "links" table).
Added spanning tree functionality for all graph instances.
Reworked RadialTreeLayout. Updated PolarLocationAnimator to use an externally defined set for linear Cartesian interpolation cases.
Fixed out-of-order row manager indexing bug in CascadedTable -- all row indexing is now complete once a table insert event is fired.
Made filterRows() public in CascadedTable.
Reorganized visual data support classes to prefuse.visual.tuple package.
@
text
@d7 1
d117 1
a117 1
        Node r = t.addRoot();
d125 1
a125 1
    private static void balancedHelper(Tree t, Node n, 
d129 1
a129 1
            Node c = t.addChild(n);
d145 1
a145 1
        Node r = t.addRoot();
d161 1
a161 1
        Node r = t.addRoot();
d172 1
a172 1
        Node r = t.addRoot();
d175 2
a176 2
        Node left = t.addChild(r);
        Node right = t.addChild(r);
d192 1
a192 1
    private static void deepHelper(Tree t, Node n, 
d195 1
a195 1
        Node c = t.addChild(n);
@


1.1.2.4
log
@Much more javadoc
@
text
@d8 2
d11 1
a11 5
 * Library routines for creating various Graph structures. All Graphs
 * generated by methods of this class include a String-valued
 * "label" field.
 * 
 * @@author <a href="http://jheer.org">jeffrey heer</a>
d154 1
a154 1
     * @@return the generated Tree
a166 8
    /**
     * Create a diamond tree, with a given branching factor at
     * each level, and depth levels for the two main branches.
     * @@param b the number of children of each branch node
     * @@param d1 the length of the first (left) branch
     * @@param d2 the length of the second (right) branch
     * @@return the generated Tree
     */
a210 1
    /** Label data field included in generated Graphs */
a211 1
    /** Node table schema used for generated Graphs */
@


1.1.2.5
log
@Intermediate commit in run-up to release.
Upgraded Tuple, Node, and Edge to the data package.
Renamed "Function" classes to "Action" classes.
Added Shape to VisualItem Schema.
Added ShapeActions, moved Shape constants to Constants interface.
Added Background image handling to the Display class.
Added social network data file.
@
text
@a3 1
import prefuse.data.Node;
d6 1
@


