head	2.1;
access;
symbols
	java_1_5:2.1.0.4
	Root_java_1_5:2.1
	beta:2.1.0.2
	beta-20080113:2.1
	beta-20071021:2.1
	beta-20060220:2.1
	beta-20060209:2.0;
locks; strict;
comment	@# @;


2.1
date	2006.02.17.18.08.28;	author jheer;	state Exp;
branches
	2.1.4.1;
next	2.0;

2.0
date	2006.02.12.18.23.45;	author jheer;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.30.09.13.31;	author jheer;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2005.12.30.09.13.31;	author jheer;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2006.01.16.20.07.41;	author jheer;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2006.01.23.22.08.47;	author jheer;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2006.01.30.09.08.06;	author jheer;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2006.02.01.19.22.43;	author jheer;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2006.02.02.19.01.53;	author jheer;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2006.02.07.00.42.29;	author jheer;	state Exp;
branches;
next	;

2.1.4.1
date	2008.01.23.23.55.36;	author jogiles;	state Exp;
branches;
next	2.1.4.2;

2.1.4.2
date	2008.02.24.00.22.31;	author amarsden;	state Exp;
branches;
next	2.1.4.3;

2.1.4.3
date	2008.02.28.00.40.29;	author amarsden;	state Exp;
branches;
next	;


desc
@@


2.1
log
@Added "stroke" visual property for configuring line drawing.
EdgeRenderer now draws directed edges (more) correctly, and allow parameterization of the arrow head size.
@
text
@package prefuse.util;

import java.awt.BasicStroke;
import java.awt.Font;
import java.awt.Stroke;
import java.awt.geom.Rectangle2D;

import prefuse.Constants;
import prefuse.Display;
import prefuse.data.Schema;
import prefuse.visual.VisualItem;

/**
 * General library routines used by the prefuse toolkit.
 * 
 * @@author <a href="http://jheer.org">jeffrey heer</a>
 */
public class PrefuseLib {

    /**
     * Group delimiter string used to demarcate the hierarchical structure
     * of nested data groups; the default value is a dot (.).
     */
    private static final String GROUP_DELIMITER 
        = PrefuseConfig.get("data.delimiter");
    /**
     * Scale factor for psychophysical scaling of area values, defaults to
     * 0.5, resulting in linear scaling.
     */
    private static final double SIZE_SCALE_FACTOR 
        = PrefuseConfig.getDouble("size.scale2D");
    /**
     * Prefix for visualization-specific data fields, such as those used by
     * VisualItem; the default is a single underscore (_).
     */
    public static final String FIELD_PREFIX
        = PrefuseConfig.get("data.visual.fieldPrefix");
    
    // ------------------------------------------------------------------------
    
    private PrefuseLib() {
        // prevent instantiation
    }
    
    // ------------------------------------------------------------------------
    // Memory Usage / Debugging Output
    
    /**
     * Get a String showing current JVM memory usage in kilobytes.
     * @@return the memory usage String in KB
     */
    public static String getMemoryUsageInKB() {
        long total = Runtime.getRuntime().totalMemory() / (2<<10);
        long free  = Runtime.getRuntime().freeMemory() / (2<<10);
        long max   = Runtime.getRuntime().maxMemory() / (2<<10);
        return "Memory: "+(total-free)+"k / "+total+"k / "+max+"k";
    }

    /**
     * Get a String showing current JVM memory usage in megabytes.
     * @@return the memory usage String in MB
     */
    public static String getMemoryUsageInMB() {
        long total = Runtime.getRuntime().totalMemory() / (2<<20);
        long free  = Runtime.getRuntime().freeMemory() / (2<<20);
        long max   = Runtime.getRuntime().maxMemory() / (2<<20);
        return "Memory: "+(total-free)+"M / "+total+"M / "+max+"M";
    }
    
    /**
     * Returns a string showing debugging info such as number of visualized
     * items and the current frame rate.
     * @@return the debug string
     */
    public static String getDisplayStats(Display d) {
        float fr = Math.round(d.getFrameRate()*100f)/100f;
        
        Runtime rt = Runtime.getRuntime();
        long tm = rt.totalMemory() / (2<<20);
        long fm = rt.freeMemory() / (2<<20);
        long mm = rt.maxMemory() / (2<<20);
        
        StringBuffer sb = new StringBuffer();
        sb.append("frame rate: ").append(fr).append("fps - ");
        sb.append(d.getVisibleItemCount()).append(" items - ");
        sb.append("fonts(").append(FontLib.getCacheMissCount());
        sb.append(") colors(");
        sb.append(ColorLib.getCacheMissCount()).append(')');
        sb.append(" mem(");
        sb.append(tm-fm).append("M / ");
        sb.append(mm).append("M)");
        sb.append(" (x:");
        sb.append(StringLib.formatNumber(d.getDisplayX(),2));
        sb.append(", y:");
        sb.append(StringLib.formatNumber(d.getDisplayY(),2));
        sb.append(", z:");
        sb.append(StringLib.formatNumber(d.getScale(),5)).append(")");
        return sb.toString();
    }
    
    // ------------------------------------------------------------------------
    // VisualItem Methods
    
    /**
     * Returns a scale factor by which to scale a 2D shape to grow 
     * the area by the desired input size value. This is used to scale shapes
     * by total pixel area, rather than scaling each dimension by the
     * size value itself, which grows the pixel area quadratically rather
     * than linearly.
     */
    public static double getSize2D(double size) {
        return Math.pow(size, SIZE_SCALE_FACTOR);
    }
    
    /**
     * Get the distance between the x,y points of two VisualItems.
     * @@param vi1 the first VisualItem
     * @@param vi2 the second VisualItem
     * @@return the distance between the items' x,y coordinates
     */
    public static double distance(VisualItem vi1, VisualItem vi2) {
        double dx = vi1.getX() - vi2.getX();
        double dy = vi1.getY() - vi2.getY();
        return Math.sqrt(dx*dx + dy*dy);
    }
    
    /**
     * Update the values in an interpolated column (a set of three columns
     * representing a current value along with starting and ending values).
     * The current value will become the new starting value, while the given
     * value will become the new current and ending values.
     * @@param item the VisualItem to update
     * @@param field the base field to update, start and ending fields will
     * also be updated, too.
     * @@param val the value to set
     */
    public static void update(VisualItem item, String field, Object val) {
        item.set(getStartField(field), item.get(field));
        item.set(field, val);
        item.set(getEndField(field), val);
    }
    
    /**
     * Update the values in an interpolated column (a set of three columns
     * representing a current value along with starting and ending values).
     * The current value will become the new starting value, while the given
     * value will become the new current and ending values.
     * @@param item the VisualItem to update
     * @@param field the base field to update, start and ending fields will
     * also be updated, too.
     * @@param val the value to set
     */
    public static void updateInt(VisualItem item, String field, int val) {
        item.setInt(getStartField(field), item.getInt(field));
        item.setInt(field, val);
        item.setInt(getEndField(field), val);
    }
    
    /**
     * Update the values in an interpolated column (a set of three columns
     * representing a current value along with starting and ending values).
     * The current value will become the new starting value, while the given
     * value will become the new current and ending values.
     * @@param item the VisualItem to update
     * @@param field the base field to update, start and ending fields will
     * also be updated, too.
     * @@param val the value to set
     */
    public static void updateLong(VisualItem item, String field, long val) {
        item.setLong(getStartField(field), item.getLong(field));
        item.setLong(field, val);
        item.setLong(getEndField(field), val);
    }
    
    /**
     * Update the values in an interpolated column (a set of three columns
     * representing a current value along with starting and ending values).
     * The current value will become the new starting value, while the given
     * value will become the new current and ending values.
     * @@param item the VisualItem to update
     * @@param field the base field to update, start and ending fields will
     * also be updated, too.
     * @@param val the value to set
     */
    public static void updateFloat(VisualItem item, String field, float val)
    {
        item.setFloat(getStartField(field), item.getFloat(field));
        item.setFloat(field, val);
        item.setFloat(getEndField(field), val);
    }
    
    /**
     * Update the values in an interpolated column (a set of three columns
     * representing a current value along with starting and ending values).
     * The current value will become the new starting value, while the given
     * value will become the new current and ending values.
     * @@param item the VisualItem to update
     * @@param field the base field to update, start and ending fields will
     * also be updated, too.
     * @@param val the value to set
     */
    public static void updateDouble(VisualItem item, String field, double val)
    {
        item.setDouble(getStartField(field), item.getDouble(field));
        item.setDouble(field, val);
        item.setDouble(getEndField(field), val);
    }
    
    /**
     * Update the values in an interpolated column (a set of three columns
     * representing a current value along with starting and ending values).
     * The current value will become the new starting value, while the given
     * value will become the new current and ending values.
     * @@param item the VisualItem to update
     * @@param field the base field to update, start and ending fields will
     * also be updated, too.
     * @@param b the value to set
     */
    public static void updateBoolean(VisualItem item, String field, boolean b)
    {
        item.setBoolean(getStartField(field), item.getBoolean(field));
        item.setBoolean(field, b);
        item.setBoolean(getEndField(field), b);
    }
    
    /**
     * Update the visibility of an item. The current visibility will become the
     * new starting visibility, while the given visibility value will become
     * the new current and ending visibility.
     * @@param item the VisualItem to update
     * @@param val the visibility value to set
     */
    public static void updateVisible(VisualItem item, boolean val) {
        item.setStartVisible(item.isVisible());
        item.setVisible(val);
        item.setEndVisible(val);
    }
    
    /**
     * Update the x-coordinate of an item. The current x value will become the
     * new starting x value, while the given value will become the new current
     * x and ending x values. This method also supports an optional referrer
     * item, whose x coordinate will become the new starting x coordinate
     * of item if item's current x value is NaN.
     * @@param item the VisualItem to update
     * @@param referrer an optional referrer VisualItem
     * @@param x the x value to set
     */
    public static void setX(VisualItem item, VisualItem referrer, double x) {
        double sx = item.getX();
        if ( Double.isNaN(sx) )
            sx = (referrer != null ? referrer.getX() : x);
        
        item.setStartX(sx);
        item.setEndX(x);
        item.setX(x);
    }

    /**
     * Update the y-coordinate of an item. The current y value will become the
     * new starting y value, while the given value will become the new current
     * x and ending y values. This method also supports an optional referrer
     * item, whose y coordinate will become the new starting y coordinate
     * of item if item's current x value is NaN.
     * @@param item the VisualItem to update
     * @@param referrer an optional referrer VisualItem
     * @@param y the y value to set
     */
    public static void setY(VisualItem item, VisualItem referrer, double y) {
        double sy = item.getY();
        if ( Double.isNaN(sy) )
            sy = (referrer != null ? referrer.getY() : y);
        
        item.setStartY(sy);
        item.setEndY(y);
        item.setY(y);
    }
    
    // ------------------------------------------------------------------------
    // Group Name Methods
    
    /**
     * Indicates if a group is a child group, a non-top-level data group in
     * a set of nested data groups (e.g., the node or edge table of a
     * graph or tree).
     * @@return true if the group is a nested, or child, group
     */
    public static boolean isChildGroup(String group) {
        return group.indexOf(GROUP_DELIMITER) != -1;
    }
    
    /**
     * Get the parent group string of a child group, stripping off the
     * bottom-level group from the group name (e.g., graph.nodes --> graph).
     * @@param group the group name
     * @@return the stripped parent group name
     */
    public static String getParentGroup(String group) {
        int idx = group.lastIndexOf(GROUP_DELIMITER);
        return (idx < 0 ? null : group.substring(0,idx));
    }

    /**
     * Get the tail group name of a child group, stripping all but the
     * bottom-level group from the group name (e.g., graph.nodes --> nodes).
     * @@param group the group name
     * @@return the stripped child group name
     */
    public static String getChildGroup(String group) {
        int idx = group.lastIndexOf(GROUP_DELIMITER);
        return (idx < 0 ? null : group.substring(idx+1));
    }
    
    /**
     * Get the group name for the given parent and child group, simply
     * concatenating them together with a group delimiter in between.
     * @@param parent the parent group name
     * @@param child the child group name
     * @@return the combined group name
     */
    public static String getGroupName(String parent, String child) {
        return parent + GROUP_DELIMITER + child;
    }
    
    /**
     * For a given interpolated field name, get the name of the start
     * field.
     * @@param field the data field
     * @@return the starting field for the interpolated column
     */
    public static String getStartField(String field) {
        return field+":start";
    }
    
    /**
     * For a given interpolated field name, get the name of the end
     * field.
     * @@param field the data field
     * @@return the ending field for the interpolated column
     */
    public static String getEndField(String field) {
        return field+":end";
    }
    
    // ------------------------------------------------------------------------
    // Schema Routines
    
    /**
     * Get an instance of the default Schema used for VisualItem instances.
     * Contains all the data members commonly used to model a visual element,
     * such as x,y position, stroke, fill, and text, colors, size, font,
     * and validated, visibility, interactive, fixed, highlight, and mouse
     * hover fields.
     * @@return the VisualItem data Schema
     */
    public static Schema getVisualItemSchema() {
        Schema s = new Schema();
        
        // booleans
        s.addColumn(VisualItem.VALIDATED, boolean.class, Boolean.FALSE);
        s.addColumn(VisualItem.VISIBLE, boolean.class, Boolean.TRUE);
        s.addColumn(VisualItem.STARTVISIBLE, boolean.class, Boolean.FALSE);
        s.addColumn(VisualItem.ENDVISIBLE, boolean.class, Boolean.TRUE);
        s.addColumn(VisualItem.INTERACTIVE, boolean.class, Boolean.TRUE);
        s.addColumn(VisualItem.EXPANDED, boolean.class, Boolean.TRUE);
        s.addColumn(VisualItem.FIXED, boolean.class, Boolean.FALSE);
        s.addColumn(VisualItem.HIGHLIGHT, boolean.class, Boolean.FALSE);
        s.addColumn(VisualItem.HOVER, boolean.class, Boolean.FALSE);
        
        s.addInterpolatedColumn(VisualItem.X, double.class);
        s.addInterpolatedColumn(VisualItem.Y, double.class);
        
        // bounding box
        s.addColumn(VisualItem.BOUNDS, Rectangle2D.class, new Rectangle2D.Double());
        
        // color
        Integer defStroke = new Integer(ColorLib.rgba(0,0,0,0));
        s.addInterpolatedColumn(VisualItem.STROKECOLOR, int.class, defStroke);

        Integer defFill = new Integer(ColorLib.rgba(0,0,0,0));
        s.addInterpolatedColumn(VisualItem.FILLCOLOR, int.class, defFill);

        Integer defTextColor = new Integer(ColorLib.rgba(0,0,0,0));
        s.addInterpolatedColumn(VisualItem.TEXTCOLOR, int.class, defTextColor);

        // size
        s.addInterpolatedColumn(VisualItem.SIZE, double.class, new Double(1));
        
        // shape
        s.addColumn(VisualItem.SHAPE, int.class,
            new Integer(Constants.SHAPE_RECTANGLE));
        
        // stroke
        s.addColumn(VisualItem.STROKE, Stroke.class, new BasicStroke());
        
        // font
        Font defFont = FontLib.getFont("SansSerif",Font.PLAIN,10);
        s.addInterpolatedColumn(VisualItem.FONT, Font.class, defFont);
        
        // degree-of-interest
        s.addColumn(VisualItem.DOI, double.class, new Double(Double.MIN_VALUE));

        return s;
    }
    
    /**
     * Get the minimal Schema needed for a unique VisualItem. Can be useful
     * for derived groups that inherit other visual properties from a
     * another visual data group.
     * @@return the minimal VisualItem data Schema
     */
    public static Schema getMinimalVisualSchema() {
        Schema s = new Schema();
        
        // booleans
        s.addColumn(VisualItem.VALIDATED, boolean.class, Boolean.FALSE);
        s.addColumn(VisualItem.VISIBLE, boolean.class, Boolean.TRUE);
        s.addColumn(VisualItem.STARTVISIBLE, boolean.class, Boolean.FALSE);
        s.addColumn(VisualItem.ENDVISIBLE, boolean.class, Boolean.TRUE);
        s.addColumn(VisualItem.INTERACTIVE, boolean.class, Boolean.TRUE);
        
        // bounding box
        s.addColumn(VisualItem.BOUNDS, Rectangle2D.class, new Rectangle2D.Double());
        
        return s;
    }
    
    /**
     * Get the VisualItem Schema used for axis tick marks and labels. Extends
     * the VisualItem Schema with an additional end-point coordinate, a
     * String label field, and numeric value field for storing the value
     * which the axis label corresponds to.
     * @@return the Schema for axis tick marks and labels. 
     */
    public static Schema getAxisLabelSchema() {
        Schema s = getVisualItemSchema();

        s.setDefault(VisualItem.STARTVISIBLE, Boolean.FALSE);
        
        Integer defColor = new Integer(ColorLib.gray(230));
        s.setInterpolatedDefault(VisualItem.STROKECOLOR, defColor);
        
        defColor = new Integer(ColorLib.gray(150));
        s.setInterpolatedDefault(VisualItem.TEXTCOLOR, defColor);

        Double nan = new Double(Double.NaN);
        s.addInterpolatedColumn(VisualItem.X2, double.class);
        s.addInterpolatedColumn(VisualItem.Y2, double.class);
        
        s.addColumn(VisualItem.LABEL, String.class);
        s.addColumn(VisualItem.VALUE, double.class, nan);
        
        return s;
    }
    
} // end of class PrefuseLib
@


2.1.4.1
log
@First import of a Java 1.5-targetted version of prefuse.
@
text
@d8 1
a9 1
import prefuse.ShapeType;
d15 1
a15 1
 *
d24 1
a24 1
    private static final String GROUP_DELIMITER
d30 1
a30 1
    private static final double SIZE_SCALE_FACTOR
d38 1
a38 1

d40 1
a40 1

d44 1
a44 1

d47 1
a47 1

d69 1
a69 1

d77 1
a77 1

d82 1
a82 1

d100 1
a100 1

d103 1
a103 1

d105 1
a105 1
     * Returns a scale factor by which to scale a 2D shape to grow
d114 1
a114 1

d121 1
a121 1
    public static double distance(VisualItem<?> vi1, VisualItem<?> vi2) {
d126 1
a126 1

d137 1
a137 1
    public static void update(VisualItem<?> item, String field, Object val) {
d142 1
a142 1

d153 1
a153 1
    public static void updateInt(VisualItem<?> item, String field, int val) {
d158 1
a158 1

d169 1
a169 1
    public static void updateLong(VisualItem<?> item, String field, long val) {
d174 1
a174 1

d185 1
a185 1
    public static void updateFloat(VisualItem<?> item, String field, float val)
d191 1
a191 1

d202 1
a202 1
    public static void updateDouble(VisualItem<?> item, String field, double val)
d208 1
a208 1

d219 1
a219 1
    public static void updateBoolean(VisualItem<?> item, String field, boolean b)
d225 1
a225 1

d233 1
a233 1
    public static void updateVisible(VisualItem<?> item, boolean val) {
d238 1
a238 1

d249 1
a249 1
    public static void setX(VisualItem<?> item, VisualItem<?> referrer, double x) {
d251 3
a253 4
        if ( Double.isNaN(sx) ) {
			sx = referrer != null ? referrer.getX() : x;
		}

d269 1
a269 1
    public static void setY(VisualItem<?> item, VisualItem<?> referrer, double y) {
d271 3
a273 4
        if ( Double.isNaN(sy) ) {
			sy = referrer != null ? referrer.getY() : y;
		}

d278 1
a278 1

d281 1
a281 1

d291 1
a291 1

d300 1
a300 1
        return idx < 0 ? null : group.substring(0,idx);
d311 1
a311 1
        return idx < 0 ? null : group.substring(idx+1);
d313 1
a313 1

d324 1
a324 1

d334 1
a334 1

d344 1
a344 1

d347 1
a347 1

d358 1
a358 1

d369 1
a369 1

d372 1
a372 1

d375 1
a375 1

d388 1
a388 1

d390 3
a392 2
        s.addColumn(VisualItem.SHAPE, int.class, ShapeType.RECTANGLE.ordinal());

d395 1
a395 1

d399 1
a399 1

d405 1
a405 1

d414 1
a414 1

d421 1
a421 1

d424 1
a424 1

d427 1
a427 1

d433 1
a433 1
     * @@return the Schema for axis tick marks and labels.
d439 1
a439 1

d442 1
a442 1

d449 1
a449 1

d452 1
a452 1

d455 1
a455 1

@


2.1.4.2
log
@Refactored the shape work to allow for custom ShapeBuilders. VisualItem.SHAPE has been replaced with VisualItem.SHAPEBUILDER.
@
text
@d9 1
a9 2
import prefuse.ShapeBuilder;
import prefuse.PredefinedShape;
d392 1
a392 1
        s.addColumn(VisualItem.SHAPEBUILDER, ShapeBuilder.class, PredefinedShape.NONE);
@


2.1.4.3
log
@Allow the display to be zoomed in x/y dimensions separately (animation support too)
@
text
@d97 2
a98 5
        sb.append(", z-x:");
        sb.append(StringLib.formatNumber(d.getScaleX(),5));
        sb.append(", z-y:");
        sb.append(StringLib.formatNumber(d.getScaleY(),5));
        sb.append(")");
@


2.0
log
@Merge beta branch back onto main trunk
@
text
@d3 1
d5 1
d393 3
@


1.1
log
@file PrefuseLib.java was initially added on branch beta.
@
text
@d1 451
@


1.1.2.1
log
@Initial commit of prefuse beta
@
text
@a0 280
package prefuse.util;

import java.awt.Font;
import java.awt.geom.Rectangle2D;

import prefuse.Display;
import prefuse.data.Schema;
import prefuse.visual.VisualItem;

/**
 * General library routines used by the prefuse toolkit.
 * 
 * @@author <a href="http://jheer.org">jeffrey heer</a> - prefuse(AT)jheer.org
 */
public class PrefuseLib {

    private static final String GROUP_DELIMITER 
        = PrefuseConfig.get("data.delimiter");
    
    private static final double SIZE_SCALE_FACTOR 
        = PrefuseConfig.getDouble("size.scale2D");
    
    public static final String FIELD_PREFIX
        = PrefuseConfig.get("data.visual.fieldPrefix");
    
    // ------------------------------------------------------------------------
    
    private PrefuseLib() {
        // prevent instantiation
    }
    
    // ------------------------------------------------------------------------
    // Memory Usage / Debugging Output
    
    public static String getMemoryUsageInKB() {
        long total = Runtime.getRuntime().totalMemory() / (2<<10);
        long free  = Runtime.getRuntime().freeMemory() / (2<<10);
        long max   = Runtime.getRuntime().maxMemory() / (2<<10);
        return "Memory: "+(total-free)+"k / "+total+"k / "+max+"k";
    }
    
    public static String getMemoryUsageInMB() {
        long total = Runtime.getRuntime().totalMemory() / (2<<20);
        long free  = Runtime.getRuntime().freeMemory() / (2<<20);
        long max   = Runtime.getRuntime().maxMemory() / (2<<20);
        return "Memory: "+(total-free)+"M / "+total+"M / "+max+"M";
    }
    
    /**
     * Returns a string showing debugging info such as number of visualized
     * items and the current frame rate.
     * @@return the debug string
     */
    public static String getDisplayStats(Display d) {
        float fr = Math.round(d.getFrameRate()*100f)/100f;
        
        Runtime rt = Runtime.getRuntime();
        long tm = rt.totalMemory() / (2<<20);
        long fm = rt.freeMemory() / (2<<20);
        long mm = rt.maxMemory() / (2<<20);
        
        StringBuffer sb = new StringBuffer();
        sb.append("frame rate: ").append(fr).append("fps - ");
        sb.append(d.getVisibleItemCount()).append(" items - ");
        sb.append("fonts(").append(FontLib.getCacheMissCount());
        sb.append(") colors(");
        sb.append(ColorLib.getCacheMissCount()).append(')');
        sb.append(" mem(");
        sb.append(tm-fm).append("M / ");
        sb.append(mm).append("M)");
        sb.append(" (x:");
        sb.append(StringLib.formatNumber(d.getDisplayX(),2));
        sb.append(", y:");
        sb.append(StringLib.formatNumber(d.getDisplayY(),2));
        sb.append(", z:");
        sb.append(StringLib.formatNumber(d.getScale(),5)).append(")");
        return sb.toString();
    }
    
    // ------------------------------------------------------------------------
    // VisualItem Methods
    
    /**
     * Returns a scale factor by which to scale a 2D shape to grow 
     * the area by the desired input size value.
     */
    public static double getSize2D(double size) {
        return Math.pow(size, SIZE_SCALE_FACTOR);
    }
    
    public static double distance(VisualItem x, VisualItem y) {
        double dx = x.getX() - y.getX();
        double dy = x.getY() - y.getY();
        return Math.sqrt(dx*dx + dy*dy);
    }
    
    public static void update(VisualItem item, String field, Object val) {
        item.set(item.get(field), getStartField(field));
        item.set(val, field);
        item.set(val, getEndField(field));
    }
    
    public static void updateInt(VisualItem item, String field, int val) {
        item.setInt(item.getInt(field), getStartField(field));
        item.setInt(val, field);
        item.setInt(val, getEndField(field));
    }
    
    public static void updateLong(VisualItem item, String field, long val) {
        item.setLong(item.getLong(field), getStartField(field));
        item.setLong(val, field);
        item.setLong(val, getEndField(field));
    }
    
    public static void updateFloat(VisualItem item, String field, float val)
    {
        item.setFloat(item.getFloat(field), getStartField(field));
        item.setFloat(val, field);
        item.setFloat(val, getEndField(field));
    }
    
    public static void updateDouble(VisualItem item, String field, double val)
    {
        item.setDouble(item.getDouble(field), getStartField(field));
        item.setDouble(val, field);
        item.setDouble(val, getEndField(field));
    }
    
    public static void updateBoolean(VisualItem item, String field, boolean b)
    {
        item.setBoolean(item.getBoolean(field), getStartField(field));
        item.setBoolean(b, field);
        item.setBoolean(b, getEndField(field));
    }
    
    public static void updateVisible(VisualItem item, boolean val) {
        item.setStartVisible(item.isVisible());
        item.setVisible(val);
        item.setEndVisible(val);
    }
    
    public static void setX(VisualItem item, VisualItem referrer, double x) {
        double sx = item.getX();
        if ( Double.isNaN(sx) )
            sx = (referrer != null ? referrer.getX() : x);
        
        item.setStartX(sx);
        item.setEndX(x);
        item.setX(x);
    }
    
    public static void setY(VisualItem item, VisualItem referrer, double y) {
        double sy = item.getY();
        if ( Double.isNaN(sy) )
            sy = (referrer != null ? referrer.getY() : y);
        
        item.setStartY(sy);
        item.setEndY(y);
        item.setY(y);
    }
    
    // ------------------------------------------------------------------------
    // Group Name Methods
    
    public static boolean isChildGroup(String group) {
        return group.indexOf(GROUP_DELIMITER) != -1;
    }
    
    public static String getParentGroup(String group) {
        int idx = group.lastIndexOf(GROUP_DELIMITER);
        return (idx < 0 ? null : group.substring(0,idx));
    }

    public static String getChildGroup(String group) {
        int idx = group.lastIndexOf(GROUP_DELIMITER);
        return (idx < 0 ? null : group.substring(idx+1));
    }
    
    public static String getGroupName(String parent, String child) {
        return parent + GROUP_DELIMITER + child;
    }
    
    public static String getStartField(String field) {
        return field+":start";
    }
    
    public static String getEndField(String field) {
        return field+":end";
    }
    
    // ------------------------------------------------------------------------
    // Schema Routines
    
    public static Schema getVisualItemSchema() {
        Schema s = new Schema();
            
        // group name
        s.addColumn(VisualItem.GROUP, String.class);
        
        // booleans
        s.addColumn(VisualItem.VALIDATED, boolean.class, Boolean.FALSE);
        s.addColumn(VisualItem.VISIBLE, boolean.class, Boolean.TRUE);
        s.addColumn(VisualItem.STARTVISIBLE, boolean.class, Boolean.FALSE);
        s.addColumn(VisualItem.ENDVISIBLE, boolean.class, Boolean.TRUE);
        s.addColumn(VisualItem.INTERACTIVE, boolean.class, Boolean.TRUE);
        s.addColumn(VisualItem.EXPANDED, boolean.class, Boolean.TRUE);
        s.addColumn(VisualItem.FIXED, boolean.class, Boolean.FALSE);
        s.addColumn(VisualItem.HIGHLIGHT, boolean.class, Boolean.FALSE);
        s.addColumn(VisualItem.HOVER, boolean.class, Boolean.FALSE);
        
        s.addInterpolatedColumn(VisualItem.X, double.class);
        s.addInterpolatedColumn(VisualItem.Y, double.class);
        
        // bounding box
        s.addColumn(VisualItem.BOUNDS, Rectangle2D.class, new Rectangle2D.Double());
        
        // color
        Integer defStroke = new Integer(ColorLib.rgba(0,0,0,0));
        s.addInterpolatedColumn(VisualItem.STROKECOLOR, int.class, defStroke);

        Integer defFill = new Integer(ColorLib.rgba(0,0,0,0));
        s.addInterpolatedColumn(VisualItem.FILLCOLOR, int.class, defFill);

        Integer defTextColor = new Integer(ColorLib.rgba(0,0,0,0));
        s.addInterpolatedColumn(VisualItem.TEXTCOLOR, int.class, defTextColor);

        // size
        s.addInterpolatedColumn(VisualItem.SIZE, double.class, new Double(1));
        
        // font
        Font defFont = FontLib.getFont("SansSerif",Font.PLAIN,10);
        s.addInterpolatedColumn(VisualItem.FONT, Font.class, defFont);
        
        // degree-of-interest
        s.addColumn(VisualItem.DOI, double.class, new Double(Double.MIN_VALUE));

        return s;
    }
    
    public static Schema getMinimalVisualSchema() {
        Schema s = new Schema();
        
        // group name
        s.addColumn(VisualItem.GROUP, String.class);
        
        // booleans
        s.addColumn(VisualItem.VALIDATED, boolean.class, Boolean.FALSE);
        s.addColumn(VisualItem.VISIBLE, boolean.class, Boolean.TRUE);
        s.addColumn(VisualItem.STARTVISIBLE, boolean.class, Boolean.FALSE);
        s.addColumn(VisualItem.ENDVISIBLE, boolean.class, Boolean.TRUE);
        s.addColumn(VisualItem.INTERACTIVE, boolean.class, Boolean.TRUE);
        
        // bounding box
        s.addColumn(VisualItem.BOUNDS, Rectangle2D.class, new Rectangle2D.Double());
        
        return s;
    }
    
    public static Schema getAxisLabelSchema() {
        Schema s = getVisualItemSchema();

        s.setDefault(VisualItem.STARTVISIBLE, Boolean.FALSE);
        
        Integer defColor = new Integer(ColorLib.gray(230));
        s.setInterpolatedDefault(VisualItem.STROKECOLOR, defColor);
        
        defColor = new Integer(ColorLib.gray(150));
        s.setInterpolatedDefault(VisualItem.TEXTCOLOR, defColor);

        Double nan = new Double(Double.NaN);
        s.addInterpolatedColumn(VisualItem.X2, double.class);
        s.addInterpolatedColumn(VisualItem.Y2, double.class);
        
        s.addColumn(VisualItem.LABEL, String.class);
        s.addColumn(VisualItem.VALUE, double.class, nan);
        
        return s;
    }
    
} // end of class PrefuseLib
@


1.1.2.2
log
@Table method refactoring. Added PredicateChain, included in ColorFunction, SizeFunction, and RendererFactory. Added ItemBoundsListener, included in GraphView demo. Updated ColorMap to use int representation, moved palette creators to ColorLib. Added minExtent to JRangeSlider. Fixed round-off rendering glitches int optimized rendering, added RenderingAccuracy test class. Updated PrefuseConfig to support logging output to file system. Added DelmitedTextTableWriter. Added CompositeTupleSet. Added directionality to edges, increased support to EdgeRenderer, including reversed directionality.
@
text
@d98 3
a100 3
        item.set(getStartField(field), item.get(field));
        item.set(field, val);
        item.set(getEndField(field), val);
d104 3
a106 3
        item.setInt(getStartField(field), item.getInt(field));
        item.setInt(field, val);
        item.setInt(getEndField(field), val);
d110 3
a112 3
        item.setLong(getStartField(field), item.getLong(field));
        item.setLong(field, val);
        item.setLong(getEndField(field), val);
d117 3
a119 3
        item.setFloat(getStartField(field), item.getFloat(field));
        item.setFloat(field, val);
        item.setFloat(getEndField(field), val);
d124 3
a126 3
        item.setDouble(getStartField(field), item.getDouble(field));
        item.setDouble(field, val);
        item.setDouble(getEndField(field), val);
d131 3
a133 3
        item.setBoolean(getStartField(field), item.getBoolean(field));
        item.setBoolean(field, b);
        item.setBoolean(getEndField(field), b);
@


1.1.2.3
log
@Added support for aggregates as a visual data type (AggregateItem, AggregateTable).
Added listener callback to DataSourceWorker.
Reworked graph representation to use an internal table of adjacency lists (the "links" table).
Added spanning tree functionality for all graph instances.
Reworked RadialTreeLayout. Updated PolarLocationAnimator to use an externally defined set for linear Cartesian interpolation cases.
Fixed out-of-order row manager indexing bug in CascadedTable -- all row indexing is now complete once a table insert event is fired.
Made filterRows() public in CascadedTable.
Reorganized visual data support classes to prefuse.visual.tuple package.
@
text
@d196 3
d243 3
@


1.1.2.4
log
@Much more javadoc
@
text
@a16 4
    /**
     * Group delimiter string used to demarcate the hierarchical structure
     * of nested data groups; the default value is a dot (.).
     */
d19 1
a19 4
    /**
     * Scale factor for psychophysical scaling of area values, defaults to
     * 0.5, resulting in linear scaling.
     */
d22 1
a22 4
    /**
     * Prefix for visualization-specific data fields, such as those used by
     * VisualItem; the default is a single underscore (_).
     */
a34 4
    /**
     * Get a String showing current JVM memory usage in kilobytes.
     * @@return the memory usage String in KB
     */
d41 1
a41 5

    /**
     * Get a String showing current JVM memory usage in megabytes.
     * @@return the memory usage String in MB
     */
d85 1
a85 4
     * the area by the desired input size value. This is used to scale shapes
     * by total pixel area, rather than scaling each dimension by the
     * size value itself, which grows the pixel area quadratically rather
     * than linearly.
d91 3
a93 9
    /**
     * Get the distance between the x,y points of two VisualItems.
     * @@param vi1 the first VisualItem
     * @@param vi2 the second VisualItem
     * @@return the distance between the items' x,y coordinates
     */
    public static double distance(VisualItem vi1, VisualItem vi2) {
        double dx = vi1.getX() - vi2.getX();
        double dy = vi1.getY() - vi2.getY();
a96 10
    /**
     * Update the values in an interpolated column (a set of three columns
     * representing a current value along with starting and ending values).
     * The current value will become the new starting value, while the given
     * value will become the new current and ending values.
     * @@param item the VisualItem to update
     * @@param field the base field to update, start and ending fields will
     * also be updated, too.
     * @@param val the value to set
     */
a102 10
    /**
     * Update the values in an interpolated column (a set of three columns
     * representing a current value along with starting and ending values).
     * The current value will become the new starting value, while the given
     * value will become the new current and ending values.
     * @@param item the VisualItem to update
     * @@param field the base field to update, start and ending fields will
     * also be updated, too.
     * @@param val the value to set
     */
a108 10
    /**
     * Update the values in an interpolated column (a set of three columns
     * representing a current value along with starting and ending values).
     * The current value will become the new starting value, while the given
     * value will become the new current and ending values.
     * @@param item the VisualItem to update
     * @@param field the base field to update, start and ending fields will
     * also be updated, too.
     * @@param val the value to set
     */
a114 10
    /**
     * Update the values in an interpolated column (a set of three columns
     * representing a current value along with starting and ending values).
     * The current value will become the new starting value, while the given
     * value will become the new current and ending values.
     * @@param item the VisualItem to update
     * @@param field the base field to update, start and ending fields will
     * also be updated, too.
     * @@param val the value to set
     */
a121 10
    /**
     * Update the values in an interpolated column (a set of three columns
     * representing a current value along with starting and ending values).
     * The current value will become the new starting value, while the given
     * value will become the new current and ending values.
     * @@param item the VisualItem to update
     * @@param field the base field to update, start and ending fields will
     * also be updated, too.
     * @@param val the value to set
     */
a128 10
    /**
     * Update the values in an interpolated column (a set of three columns
     * representing a current value along with starting and ending values).
     * The current value will become the new starting value, while the given
     * value will become the new current and ending values.
     * @@param item the VisualItem to update
     * @@param field the base field to update, start and ending fields will
     * also be updated, too.
     * @@param val the value to set
     */
a135 7
    /**
     * Update the visibility of an item. The current visibility will become the
     * new starting visibility, while the given visibility value will become
     * the new current and ending visibility.
     * @@param item the VisualItem to update
     * @@param val the visibility value to set
     */
a141 10
    /**
     * Update the x-coordinate of an item. The current x value will become the
     * new starting x value, while the given value will become the new current
     * x and ending x values. This method also supports an optional referrer
     * item, whose x coordinate will become the new starting x coordinate
     * of item if item's current x value is NaN.
     * @@param item the VisualItem to update
     * @@param referrer an optional referrer VisualItem
     * @@param val the x value to set
     */
d151 1
a151 11

    /**
     * Update the y-coordinate of an item. The current y value will become the
     * new starting y value, while the given value will become the new current
     * x and ending y values. This method also supports an optional referrer
     * item, whose y coordinate will become the new starting y coordinate
     * of item if item's current x value is NaN.
     * @@param item the VisualItem to update
     * @@param referrer an optional referrer VisualItem
     * @@param val the y value to set
     */
a164 6
    /**
     * Indicates if a group is a child group, a non-top-level data group in
     * a set of nested data groups (e.g., the node or edge table of a
     * graph or tree).
     * @@return true if the group is a nested, or child, group
     */
a168 6
    /**
     * Get the parent group string of a child group, stripping off the
     * bottom-level group from the group name (e.g., graph.nodes --> graph).
     * @@param group the group name
     * @@return the stripped parent group name
     */
a173 6
    /**
     * Get the tail group name of a child group, stripping all but the
     * bottom-level group from the group name (e.g., graph.nodes --> nodes).
     * @@param group the group name
     * @@return the stripped child group name
     */
a178 7
    /**
     * Get the group name for the given parent and child group, simply
     * concatenating them together with a group delimiter in between.
     * @@param parent the parent group name
     * @@param child the child group name
     * @@return the combined group name
     */
a182 6
    /**
     * For a given interpolated field name, get the name of the start
     * field.
     * @@param field the data field
     * @@return the starting field for the interpolated column
     */
a186 6
    /**
     * For a given interpolated field name, get the name of the end
     * field.
     * @@param field the data field
     * @@return the ending field for the interpolated column
     */
a193 8
    /**
     * Get an instance of the default Schema used for VisualItem instances.
     * Contains all the data members commonly used to model a visual element,
     * such as x,y position, stroke, fill, and text, colors, size, font,
     * and validated, visibility, interactive, fixed, highlight, and mouse
     * hover fields.
     * @@return the VisualItem data Schema
     */
a236 6
    /**
     * Get the minimal Schema needed for a unique VisualItem. Can be useful
     * for derived groups that inherit other visual properties from a
     * another visual data group.
     * @@return the minimal VisualItem data Schema
     */
a252 7
    /**
     * Get the VisualItem Schema used for axis tick marks and labels. Extends
     * the VisualItem Schema with an additional end-point coordinate, a
     * String label field, and numeric value field for storing the value
     * which the axis label corresponds to.
     * @@return the Schema for axis tick marks and labels. 
     */
@


1.1.2.5
log
@Javadoc'd.
@
text
@d214 1
a214 1
     * @@param b the value to set
d244 1
a244 1
     * @@param x the x value to set
d264 1
a264 1
     * @@param y the y value to set
@


1.1.2.6
log
@Standardized @@author tag contents
Added toggle for enabling/disabling damage/redraw
EdgeRenderer now cleanly pulls edge widths from the size field
Refactored TupleManager to a single reusable class
@
text
@d13 1
a13 1
 * @@author <a href="http://jheer.org">jeffrey heer</a>
@


1.1.2.7
log
@Intermediate commit in run-up to release.
Upgraded Tuple, Node, and Edge to the data package.
Renamed "Function" classes to "Action" classes.
Added Shape to VisualItem Schema.
Added ShapeActions, moved Shape constants to Constants interface.
Added Background image handling to the Display class.
Added social network data file.
@
text
@a5 1
import prefuse.Constants;
a385 4
        // shape
        s.addColumn(VisualItem.SHAPE, int.class,
            new Integer(Constants.SHAPE_RECTANGLE));
        
@


