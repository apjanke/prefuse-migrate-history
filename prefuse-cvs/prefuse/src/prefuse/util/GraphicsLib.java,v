head	2.3;
access;
symbols
	java_1_5:2.3.0.4
	Root_java_1_5:2.3
	beta:2.3.0.2
	beta-20080113:2.3
	beta-20071021:2.3
	beta-20060220:2.2
	beta-20060209:2.0;
locks; strict;
comment	@# @;


2.3
date	2006.03.20.21.27.20;	author jheer;	state Exp;
branches
	2.3.4.1;
next	2.2;

2.2
date	2006.02.18.23.41.54;	author jheer;	state Exp;
branches;
next	2.1;

2.1
date	2006.02.17.18.08.28;	author jheer;	state Exp;
branches;
next	2.0;

2.0
date	2006.02.12.18.23.45;	author jheer;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.23.21.56.49;	author jheer;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2006.01.23.21.56.49;	author jheer;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2006.01.23.23.07.18;	author jheer;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2006.01.30.09.08.06;	author jheer;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2006.02.01.19.22.43;	author jheer;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2006.02.09.05.12.45;	author jheer;	state Exp;
branches;
next	;

2.3.4.1
date	2008.01.23.23.55.36;	author jogiles;	state Exp;
branches;
next	2.3.4.2;

2.3.4.2
date	2008.02.26.05.02.53;	author amarsden;	state Exp;
branches;
next	2.3.4.3;

2.3.4.3
date	2008.02.28.01.09.32;	author amarsden;	state Exp;
branches;
next	2.3.4.4;

2.3.4.4
date	2008.03.03.05.19.16;	author amarsden;	state Exp;
branches;
next	2.3.4.5;

2.3.4.5
date	2008.03.16.08.57.04;	author amarsden;	state Exp;
branches;
next	2.3.4.6;

2.3.4.6
date	2008.03.28.04.11.12;	author amarsden;	state Exp;
branches;
next	2.3.4.7;

2.3.4.7
date	2008.04.14.05.01.32;	author amarsden;	state Exp;
branches;
next	2.3.4.8;

2.3.4.8
date	2008.05.02.05.06.48;	author jogiles;	state Exp;
branches;
next	2.3.4.9;

2.3.4.9
date	2009.06.24.07.26.05;	author jogiles;	state Exp;
branches;
next	;


desc
@@


2.3
log
@Fixed duplicate angle removal bug in convex hull
@
text
@package prefuse.util;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.AffineTransform;
import java.awt.geom.Ellipse2D;
import java.awt.geom.GeneralPath;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.RectangularShape;
import java.awt.geom.RoundRectangle2D;

import prefuse.render.AbstractShapeRenderer;
import prefuse.visual.VisualItem;

/**
 * Library of useful computer graphics routines such as geometry routines
 * for computing the intersection of different shapes and rendering methods
 * for computing bounds and performing optimized drawing.
 * 
 * @@author <a href="http://jheer.org">jeffrey heer</a>
 */
public class GraphicsLib {

    /** Indicates no intersection between shapes */
    public static final int NO_INTERSECTION = 0;
    /** Indicates intersection between shapes */
    public static final int COINCIDENT      = -1;
    /** Indicates two lines are parallel */
    public static final int PARALLEL        = -2;
    
    /**
     * Compute the intersection of two line segments.
     * @@param a the first line segment
     * @@param b the second line segment
     * @@param intersect a Point in which to store the intersection point
     * @@return the intersection code. One of {@@link #NO_INTERSECTION},
     * {@@link #COINCIDENT}, or {@@link #PARALLEL}.
     */
    public static int intersectLineLine(Line2D a, Line2D b, Point2D intersect) {
        double a1x = a.getX1(), a1y = a.getY1();
        double a2x = a.getX2(), a2y = a.getY2();
        double b1x = b.getX1(), b1y = b.getY1();
        double b2x = b.getX2(), b2y = b.getY2();
        return intersectLineLine(a1x,a1y,a2x,a2y,b1x,b1y,b2x,b2y,intersect);
    }
    
    /**
     * Compute the intersection of two line segments.
     * @@param a1x the x-coordinate of the first endpoint of the first line
     * @@param a1y the y-coordinate of the first endpoint of the first line
     * @@param a2x the x-coordinate of the second endpoint of the first line
     * @@param a2y the y-coordinate of the second endpoint of the first line
     * @@param b1x the x-coordinate of the first endpoint of the second line
     * @@param b1y the y-coordinate of the first endpoint of the second line
     * @@param b2x the x-coordinate of the second endpoint of the second line
     * @@param b2y the y-coordinate of the second endpoint of the second line
     * @@param intersect a Point in which to store the intersection point
     * @@return the intersection code. One of {@@link #NO_INTERSECTION},
     * {@@link #COINCIDENT}, or {@@link #PARALLEL}.
     */
    public static int intersectLineLine(double a1x, double a1y, double a2x,
        double a2y, double b1x, double b1y, double b2x, double b2y, 
        Point2D intersect)
    {
        double ua_t = (b2x-b1x)*(a1y-b1y)-(b2y-b1y)*(a1x-b1x);
        double ub_t = (a2x-a1x)*(a1y-b1y)-(a2y-a1y)*(a1x-b1x);
        double u_b  = (b2y-b1y)*(a2x-a1x)-(b2x-b1x)*(a2y-a1y);

        if ( u_b != 0 ) {
            double ua = ua_t / u_b;
            double ub = ub_t / u_b;

            if ( 0 <= ua && ua <= 1 && 0 <= ub && ub <= 1 ) {
                intersect.setLocation(a1x+ua*(a2x-a1x), a1y+ua*(a2y-a1y));
                return 1;
            } else {
                return NO_INTERSECTION;
            }
        } else {
            return ( ua_t == 0 || ub_t == 0 ? COINCIDENT : PARALLEL );
        }
    }

    /**
     * Compute the intersection of a line and a rectangle.
     * @@param a1 the first endpoint of the line
     * @@param a2 the second endpoint of the line
     * @@param r the rectangle
     * @@param pts a length 2 or greater array of points in which to store
     * the results 
     * @@return the intersection code. One of {@@link #NO_INTERSECTION},
     * {@@link #COINCIDENT}, or {@@link #PARALLEL}.
     */
    public static int intersectLineRectangle(Point2D a1, Point2D a2, Rectangle2D r, Point2D[] pts) {
        double a1x = a1.getX(), a1y = a1.getY();
        double a2x = a2.getX(), a2y = a2.getY();
        double mxx = r.getMaxX(), mxy = r.getMaxY();
        double mnx = r.getMinX(), mny = r.getMinY();
        
        if ( pts[0] == null ) pts[0] = new Point2D.Double();
        if ( pts[1] == null ) pts[1] = new Point2D.Double();
        
        int i = 0;
        if ( intersectLineLine(mnx,mny,mxx,mny,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
        if ( intersectLineLine(mxx,mny,mxx,mxy,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
        if ( i == 2 ) return i;
        if ( intersectLineLine(mxx,mxy,mnx,mxy,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
        if ( i == 2 ) return i;
        if ( intersectLineLine(mnx,mxy,mnx,mny,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
        return i;
    }

    /**
     * Compute the intersection of a line and a rectangle.
     * @@param l the line
     * @@param r the rectangle
     * @@param pts a length 2 or greater array of points in which to store
     * the results 
     * @@return the intersection code. One of {@@link #NO_INTERSECTION},
     * {@@link #COINCIDENT}, or {@@link #PARALLEL}.
     */
    public static int intersectLineRectangle(Line2D l, Rectangle2D r, Point2D[] pts) {
        double a1x = l.getX1(), a1y = l.getY1();
        double a2x = l.getX2(), a2y = l.getY2();
        double mxx = r.getMaxX(), mxy = r.getMaxY();
        double mnx = r.getMinX(), mny = r.getMinY();
        
        if ( pts[0] == null ) pts[0] = new Point2D.Double();
        if ( pts[1] == null ) pts[1] = new Point2D.Double();
        
        int i = 0;
        if ( intersectLineLine(mnx,mny,mxx,mny,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
        if ( intersectLineLine(mxx,mny,mxx,mxy,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
        if ( i == 2 ) return i;
        if ( intersectLineLine(mxx,mxy,mnx,mxy,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
        if ( i == 2 ) return i;
        if ( intersectLineLine(mnx,mxy,mnx,mny,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
        return i;
    }
    
    /**
     * Computes the 2D convex hull of a set of points using Graham's
     * scanning algorithm. The algorithm has been implemented as described
     * in Cormen, Leiserson, and Rivest's Introduction to Algorithms.
     * 
     * The running time of this algorithm is O(n log n), where n is
     * the number of input points.
     * 
     * @@param pts the input points in [x0,y0,x1,y1,...] order
     * @@param len the length of the pts array to consider (2 * #points)
     * @@return the convex hull of the input points
     */
    public static double[] convexHull(double[] pts, int len) {
        if (len < 6) {
            throw new IllegalArgumentException(
                    "Input must have at least 3 points");
        }
        int plen = len/2-1;
        float[] angles = new float[plen];
        int[] idx    = new int[plen];
        int[] stack  = new int[len/2];
        return convexHull(pts, len, angles, idx, stack);
    }
    
    /**
     * Computes the 2D convex hull of a set of points using Graham's
     * scanning algorithm. The algorithm has been implemented as described
     * in Cormen, Leiserson, and Rivest's Introduction to Algorithms.
     * 
     * The running time of this algorithm is O(n log n), where n is
     * the number of input points.
     * 
     * @@param pts
     * @@return the convex hull of the input points
     */
    public static double[] convexHull(double[] pts, int len, 
            float[] angles, int[] idx, int[] stack)
    {
        // check arguments
        int plen = len/2 - 1;
        if (len < 6) {
            throw new IllegalArgumentException(
                    "Input must have at least 3 points");
        }
        if (angles.length < plen || idx.length < plen || stack.length < len/2) {
            throw new IllegalArgumentException(
                    "Pre-allocated data structure too small");
        }
        
        int i0 = 0;
        // find the starting ref point: leftmost point with the minimum y coord
        for ( int i=2; i < len; i += 2 ) {
            if ( pts[i+1] < pts[i0+1] ) {
                i0 = i;
            } else if ( pts[i+1] == pts[i0+1] ) {
                i0 = (pts[i] < pts[i0] ? i : i0);
            }
        }
        
        // calculate polar angles from ref point and sort
        for ( int i=0, j=0; i < len; i+=2 ) {
            if ( i == i0 ) continue;
            angles[j] = (float)Math.atan2(pts[i+1]-pts[i0+1], pts[i]-pts[i0]);
            idx[j++]  = i;
        }
        ArrayLib.sort(angles,idx,plen);
        
        // toss out duplicated angles
        float angle = angles[0];
        int ti = 0, tj = idx[0];
        for ( int i=1; i<plen; i++ ) {
            int j = idx[i];
            if ( angle == angles[i] ) {
                // keep whichever angle corresponds to the most distant
                // point from the reference point
                double x1 = pts[tj]   - pts[i0];
                double y1 = pts[tj+1] - pts[i0+1];
                double x2 = pts[j]    - pts[i0];
                double y2 = pts[j+1]  - pts[i0+1];
                double d1 = x1*x1 + y1*y1;
                double d2 = x2*x2 + y2*y2;
                if ( d1 >= d2 ) {
                    idx[i] = -1;
                } else {
                    idx[ti] = -1;
                    angle = angles[i];
                    ti = i;
                    tj = j;
                }
            } else {
                angle = angles[i];
                ti = i;
                tj = j;
            }
        }
        
        // initialize our stack
        int sp = 0;
        stack[sp++] = i0;
        int j = 0;
        for ( int k=0; k<2; j++ ) {
            if ( idx[j] != -1 ) {
                stack[sp++] = idx[j];
                k++;
            }
        }
        
        // do graham's scan
        for ( ; j < plen; j++ ) {
            if ( idx[j] == -1 ) continue; // skip tossed out points
            while ( isNonLeft(i0, stack[sp-2], stack[sp-1], idx[j], pts) ) {
                sp--;
            }
            stack[sp++] = idx[j];
        }

        // construct the hull
        double[] hull = new double[2*sp];
        for ( int i=0; i<sp; i++ ) {
            hull[2*i]   = pts[stack[i]];
            hull[2*i+1] = pts[stack[i]+1];
        }
        
        return hull;
    }

    /**
     * Convex hull helper method for detecting a non left turn about 3 points
     */
    private static boolean isNonLeft(int i0, int i1, int i2, int i3, double[] pts) {
        double l1, l2, l4, l5, l6, angle1, angle2, angle;

        l1 = Math.sqrt(Math.pow(pts[i2+1]-pts[i1+1],2) + Math.pow(pts[i2]-pts[i1],2));
        l2 = Math.sqrt(Math.pow(pts[i3+1]-pts[i2+1],2) + Math.pow(pts[i3]-pts[i2],2));
        l4 = Math.sqrt(Math.pow(pts[i3+1]-pts[i0+1],2) + Math.pow(pts[i3]-pts[i0],2));
        l5 = Math.sqrt(Math.pow(pts[i1+1]-pts[i0+1],2) + Math.pow(pts[i1]-pts[i0],2));
        l6 = Math.sqrt(Math.pow(pts[i2+1]-pts[i0+1],2) + Math.pow(pts[i2]-pts[i0],2));

        angle1 = Math.acos( ( (l2*l2)+(l6*l6)-(l4*l4) ) / (2*l2*l6) );
        angle2 = Math.acos( ( (l6*l6)+(l1*l1)-(l5*l5) ) / (2*l6*l1) );

        angle = (Math.PI - angle1) - angle2;

        if (angle <= 0.0) {
            return(true);
        } else {
            return(false);
        }
    }
    
    /**
     * Computes the mean, or centroid, of a set of points
     * @@param pts the points array, in x1, y1, x2, y2, ... arrangement.
     * @@param len the length of the array to consider
     * @@return the centroid as a length-2 float array
     */
    public static float[] centroid(float pts[], int len) {
        float[] c = new float[] {0, 0};
        for ( int i=0; i < len; i+=2 ) {
            c[0] += pts[i];
            c[1] += pts[i+1];
        }
        c[0] /= len/2;
        c[1] /= len/2;
        return c;
    }
    
    /**
     * Expand a polygon by adding the given distance along the line from
     * the centroid of the polyong.
     * @@param pts the polygon to expand, a set of points in a float array
     * @@param len the length of the range of the array to consider
     * @@param amt the amount by which to expand the polygon, each point
     * will be moved this distance along the line from the centroid of the
     * polygon to the given point.
     */
    public static void growPolygon(float pts[], int len, float amt) {
        float[] c = centroid(pts, len);
        for ( int i=0; i < len; i+=2 ) {
            float vx = pts[i]-c[0];
            float vy = pts[i+1]-c[1];
            float norm = (float)Math.sqrt(vx*vx+vy*vy);
            pts[i] += amt*vx/norm;
            pts[i+1] += amt*vy/norm;
        }
    }
    
    /**
     * Compute a cardinal spline, a series of cubic Bezier splines smoothly
     * connecting a set of points. Cardinal splines maintain C(1)
     * continuity, ensuring the connected spline segments form a differentiable
     * curve, ensuring at least a minimum level of smoothness.
     * @@param pts the points to interpolate with a cardinal spline
     * @@param slack a parameter controlling the "tightness" of the spline to
     * the control points, 0.10 is a typically suitable value
     * @@param closed true if the cardinal spline should be closed (i.e. return
     * to the starting point), false for an open curve
     * @@return the cardinal spline as a Java2D {@@link java.awt.geom.GeneralPath}
     * instance.
     */
    public static GeneralPath cardinalSpline(float pts[], float slack, boolean closed) {
        GeneralPath path = new GeneralPath();
        path.moveTo(pts[0], pts[1]);
        return cardinalSpline(path, pts, slack, closed, 0f, 0f);
    }
    
    /**
     * Compute a cardinal spline, a series of cubic Bezier splines smoothly
     * connecting a set of points. Cardinal splines maintain C(1)
     * continuity, ensuring the connected spline segments form a differentiable
     * curve, ensuring at least a minimum level of smoothness.
     * @@param pts the points to interpolate with a cardinal spline
     * @@param start the starting index from which to read points
     * @@param npoints the number of points to consider
     * @@param slack a parameter controlling the "tightness" of the spline to
     * the control points, 0.10 is a typically suitable value
     * @@param closed true if the cardinal spline should be closed (i.e. return
     * to the starting point), false for an open curve
     * @@return the cardinal spline as a Java2D {@@link java.awt.geom.GeneralPath}
     * instance.
     */
    public static GeneralPath cardinalSpline(float pts[], int start, int npoints,
            float slack, boolean closed)
    {
        GeneralPath path = new GeneralPath();
        path.moveTo(pts[start], pts[start+1]);
        return cardinalSpline(path, pts, start, npoints, slack, closed, 0f, 0f);
    }
    
    /**
     * Compute a cardinal spline, a series of cubic Bezier splines smoothly
     * connecting a set of points. Cardinal splines maintain C(1)
     * continuity, ensuring the connected spline segments form a differentiable
     * curve, ensuring at least a minimum level of smoothness.
     * @@param p the GeneralPath instance to use to store the result
     * @@param pts the points to interpolate with a cardinal spline
     * @@param slack a parameter controlling the "tightness" of the spline to
     * the control points, 0.10 is a typically suitable value
     * @@param closed true if the cardinal spline should be closed (i.e. return
     * to the starting point), false for an open curve
     * @@param tx a value by which to translate the curve along the x-dimension
     * @@param ty a value by which to translate the curve along the y-dimension
     * @@return the cardinal spline as a Java2D {@@link java.awt.geom.GeneralPath}
     * instance.
     */
    public static GeneralPath cardinalSpline(GeneralPath p, 
            float pts[], float slack, boolean closed, float tx, float ty)
    {
        int npoints = 0;
        for ( ; npoints<pts.length; ++npoints )
            if ( Float.isNaN(pts[npoints]) ) break;
        return cardinalSpline(p, pts, 0, npoints/2, slack, closed, tx, ty);
    }
    
    /**
     * Compute a cardinal spline, a series of cubic Bezier splines smoothly
     * connecting a set of points. Cardinal splines maintain C(1)
     * continuity, ensuring the connected spline segments form a differentiable
     * curve, ensuring at least a minimum level of smoothness.
     * @@param p the GeneralPath instance to use to store the result
     * @@param pts the points to interpolate with a cardinal spline
     * @@param start the starting index from which to read points
     * @@param npoints the number of points to consider
     * @@param slack a parameter controlling the "tightness" of the spline to
     * the control points, 0.10 is a typically suitable value
     * @@param closed true if the cardinal spline should be closed (i.e. return
     * to the starting point), false for an open curve
     * @@param tx a value by which to translate the curve along the x-dimension
     * @@param ty a value by which to translate the curve along the y-dimension
     * @@return the cardinal spline as a Java2D {@@link java.awt.geom.GeneralPath}
     * instance.
     */
    public static GeneralPath cardinalSpline(GeneralPath p, 
            float pts[], int start, int npoints,
            float slack, boolean closed, float tx, float ty)
    {
        // compute the size of the path
        int len = 2*npoints;
        int end = start+len;
        
        if ( len < 6 ) {
            throw new IllegalArgumentException(
                    "To create spline requires at least 3 points");
        }
        
        float dx1, dy1, dx2, dy2;
        
        // compute first control point
        if ( closed ) {
            dx2 = pts[start+2]-pts[end-2];
            dy2 = pts[start+3]-pts[end-1];
        } else {
            dx2 = pts[start+4]-pts[start];
            dy2 = pts[start+5]-pts[start+1];
        }
        
        // repeatedly compute next control point and append curve
        int i;
        for ( i=start+2; i<end-2; i+=2 ) {
            dx1 = dx2; dy1 = dy2;
            dx2 = pts[i+2]-pts[i-2];
            dy2 = pts[i+3]-pts[i-1];
            p.curveTo(tx+pts[i-2]+slack*dx1, ty+pts[i-1]+slack*dy1,
                      tx+pts[i]  -slack*dx2, ty+pts[i+1]-slack*dy2,
                      tx+pts[i],             ty+pts[i+1]);
        }
        
        // compute last control point
        if ( closed ) {
            dx1 = dx2; dy1 = dy2;
            dx2 = pts[start]-pts[i-2];
            dy2 = pts[start+1]-pts[i-1];
            p.curveTo(tx+pts[i-2]+slack*dx1, ty+pts[i-1]+slack*dy1,
                      tx+pts[i]  -slack*dx2, ty+pts[i+1]-slack*dy2,
                      tx+pts[i],             ty+pts[i+1]);
            
            dx1 = dx2; dy1 = dy2;
            dx2 = pts[start+2]-pts[end-2];
            dy2 = pts[start+3]-pts[end-1];
            p.curveTo(tx+pts[end-2]+slack*dx1, ty+pts[end-1]+slack*dy1,
                      tx+pts[0]    -slack*dx2, ty+pts[1]    -slack*dy2,
                      tx+pts[0],               ty+pts[1]);
            p.closePath();
        } else {
            p.curveTo(tx+pts[i-2]+slack*dx2, ty+pts[i-1]+slack*dy2,
                      tx+pts[i]  -slack*dx2, ty+pts[i+1]-slack*dy2,
                      tx+pts[i],             ty+pts[i+1]);
        }
        return p;
    }
    
    /**
     * Computes a set of curves using the cardinal spline approach, but
     * using straight lines for completely horizontal or vertical segments.
     * @@param p the GeneralPath instance to use to store the result
     * @@param pts the points to interpolate with the spline
     * @@param epsilon threshold value under which to treat the difference
     * between two values to be zero. Used to determine which segments to
     * treat as lines rather than curves.
     * @@param slack a parameter controlling the "tightness" of the spline to
     * the control points, 0.10 is a typically suitable value
     * @@param closed true if the spline should be closed (i.e. return
     * to the starting point), false for an open curve
     * @@param tx a value by which to translate the curve along the x-dimension
     * @@param ty a value by which to translate the curve along the y-dimension
     * @@return the stack spline as a Java2D {@@link java.awt.geom.GeneralPath}
     * instance.
     */
    public static GeneralPath stackSpline(GeneralPath p, float[] pts, 
            float epsilon, float slack, boolean closed, float tx, float ty)
    {
        int npoints = 0;
        for ( ; npoints<pts.length; ++npoints )
            if ( Float.isNaN(pts[npoints]) ) break;
        return stackSpline(p,pts,0,npoints/2,epsilon,slack,closed,tx,ty);
    }
    
    /**
     * Computes a set of curves using the cardinal spline approach, but
     * using straight lines for completely horizontal or vertical segments.
     * @@param p the GeneralPath instance to use to store the result
     * @@param pts the points to interpolate with the spline
     * @@param start the starting index from which to read points
     * @@param npoints the number of points to consider
     * @@param epsilon threshold value under which to treat the difference
     * between two values to be zero. Used to determine which segments to
     * treat as lines rather than curves.
     * @@param slack a parameter controlling the "tightness" of the spline to
     * the control points, 0.10 is a typically suitable value
     * @@param closed true if the spline should be closed (i.e. return
     * to the starting point), false for an open curve
     * @@param tx a value by which to translate the curve along the x-dimension
     * @@param ty a value by which to translate the curve along the y-dimension
     * @@return the stack spline as a Java2D {@@link java.awt.geom.GeneralPath}
     * instance.
     */
    public static GeneralPath stackSpline(GeneralPath p, 
            float pts[], int start, int npoints, float epsilon,
            float slack, boolean closed, float tx, float ty)
    {
        // compute the size of the path
        int len = 2*npoints;
        int end = start+len;
        
        if ( len < 6 ) {
            throw new IllegalArgumentException(
                    "To create spline requires at least 3 points");
        }
        
        float dx1, dy1, dx2, dy2;
        // compute first control point
        if ( closed ) {
            dx2 = pts[start+2]-pts[end-2];
            dy2 = pts[start+3]-pts[end-1];
        } else {
            dx2 = pts[start+4]-pts[start];
            dy2 = pts[start+5]-pts[start+1];
        }
        
        // repeatedly compute next control point and append curve
        int i;
        for ( i=start+2; i<end-2; i+=2 ) {
            dx1 = dx2; dy1 = dy2;
            dx2 = pts[i+2]-pts[i-2];
            dy2 = pts[i+3]-pts[i-1];            
            if ( Math.abs(pts[i]  -pts[i-2]) < epsilon ||
                 Math.abs(pts[i+1]-pts[i-1]) < epsilon )
            {
                p.lineTo(tx+pts[i], ty+pts[i+1]);
            } else {
                p.curveTo(tx+pts[i-2]+slack*dx1, ty+pts[i-1]+slack*dy1,
                          tx+pts[i]  -slack*dx2, ty+pts[i+1]-slack*dy2,
                          tx+pts[i],             ty+pts[i+1]);
            }
        }
        
        // compute last control point
        dx1 = dx2; dy1 = dy2;
        dx2 = pts[start]-pts[i-2];
        dy2 = pts[start+1]-pts[i-1];
        if ( Math.abs(pts[i]  -pts[i-2]) < epsilon ||
             Math.abs(pts[i+1]-pts[i-1]) < epsilon )
        {
             p.lineTo(tx+pts[i], ty+pts[i+1]);
        } else {
            p.curveTo(tx+pts[i-2]+slack*dx1, ty+pts[i-1]+slack*dy1,
                      tx+pts[i]  -slack*dx2, ty+pts[i+1]-slack*dy2,
                      tx+pts[i],             ty+pts[i+1]);
        }
        
        // close the curve if requested
        if ( closed ) {    
            if ( Math.abs(pts[end-2]-pts[0]) < epsilon ||
                 Math.abs(pts[end-1]-pts[1]) < epsilon )
            {
                p.lineTo(tx+pts[0], ty+pts[1]);
            } else {
                dx1 = dx2; dy1 = dy2;
                dx2 = pts[start+2]-pts[end-2];
                dy2 = pts[start+3]-pts[end-1];
                p.curveTo(tx+pts[end-2]+slack*dx1, ty+pts[end-1]+slack*dy1,
                          tx+pts[0]    -slack*dx2, ty+pts[1]    -slack*dy2,
                          tx+pts[0],               ty+pts[1]);
            }
            p.closePath();
        }
        return p;
    }
    
    /**
     * Expand a rectangle by the given amount.
     * @@param r the rectangle to expand
     * @@param amount the amount by which to expand the rectangle
     */
    public static void expand(Rectangle2D r, double amount) {
        r.setRect(r.getX()-amount, r.getY()-amount,
                  r.getWidth()+2*amount, r.getHeight()+2*amount);
    }
    
    // ------------------------------------------------------------------------
    
    /**
     * Sets a VisualItem's bounds based on its shape and stroke type. This
     * method is optimized to avoid calling .getBounds2D where it can, thus
     * avoiding object initialization and reducing object churn.
     * @@param item the VisualItem whose bounds are to be set
     * @@param shape a Shape from which to determine the item bounds
     * @@param stroke the stroke type that will be used for drawing the object,
     * and may affect the final bounds. A null value indicates the
     * default (line width = 1) stroke is used.
     */
    public static void setBounds(VisualItem item,
                                 Shape shape, BasicStroke stroke)
    {
        double x, y, w, h, lw, lw2;
        
        if ( shape instanceof RectangularShape ) {
            // this covers rectangle, rounded rectangle, ellipse, and arcs
            RectangularShape r = (RectangularShape)shape;
            x = r.getX();
            y = r.getY();
            w = r.getWidth();
            h = r.getHeight();
        } else if ( shape instanceof Line2D ) {
            // this covers straight lines
            Line2D l = (Line2D)shape;
            x = l.getX1();
            y = l.getY1();
            w = l.getX2();
            h = l.getY2();
            if ( w < x ) {
                lw = x;
                x = w;
                w = lw-x;
            } else {
                w = w-x;
            }
            if ( h < y ) {
                lw = y;
                y = h;
                h = lw-y;
            } else {
                h = h-y;
            }
        } else {
            // this covers any other arbitrary shapes, but
            // takes a small object allocation / garbage collection hit
            Rectangle2D r = shape.getBounds2D();
            x = r.getX();
            y = r.getY();
            w = r.getWidth();
            h = r.getHeight();
        }
        
        // adjust boundary for stoke length as necessary
        if ( stroke != null && (lw=stroke.getLineWidth()) > 1 ) {
            lw2 = lw/2.0;
            x -= lw2; y -= lw2; w += lw; h += lw;
        }
        item.setBounds(x, y, w, h);
    }
    
    /**
     * Render a shape associated with a VisualItem into a graphics context. This
     * method uses the {@@link java.awt.Graphics} interface methods when it can,
     * as opposed to the {@@link java.awt.Graphics2D} methods such as
     * {@@link java.awt.Graphics2D#draw(java.awt.Shape)} and
     * {@@link java.awt.Graphics2D#fill(java.awt.Shape)}, resulting in a
     * significant performance increase on the Windows platform, particularly
     * for rectangle and line drawing calls.
     * @@param g the graphics context to render to
     * @@param item the item being represented by the shape, this instance is
     * used to get the correct color values for the drawing
     * @@param shape the shape to render
     * @@param stroke the stroke type to use for drawing the object.
     * @@param type the rendering type indicating if the shape should be drawn,
     * filled, or both. One of
     * {@@link prefuse.render.AbstractShapeRenderer#RENDER_TYPE_DRAW},
     * {@@link prefuse.render.AbstractShapeRenderer#RENDER_TYPE_FILL},
     * {@@link prefuse.render.AbstractShapeRenderer#RENDER_TYPE_DRAW_AND_FILL}, or
     * {@@link prefuse.render.AbstractShapeRenderer#RENDER_TYPE_NONE}.
     */
    public static void paint(Graphics2D g, VisualItem item,
                             Shape shape, BasicStroke stroke, int type)
    {
        // if render type is NONE, then there is nothing to do
        if ( type == AbstractShapeRenderer.RENDER_TYPE_NONE )
            return;
        
        // set up colors
        Color strokeColor = ColorLib.getColor(item.getStrokeColor());
        Color fillColor = ColorLib.getColor(item.getFillColor());
        boolean sdraw = (type == AbstractShapeRenderer.RENDER_TYPE_DRAW ||
                         type == AbstractShapeRenderer.RENDER_TYPE_DRAW_AND_FILL) &&
                        strokeColor.getAlpha() != 0;
        boolean fdraw = (type == AbstractShapeRenderer.RENDER_TYPE_FILL ||
                         type == AbstractShapeRenderer.RENDER_TYPE_DRAW_AND_FILL) &&
                        fillColor.getAlpha() != 0;
        if ( !(sdraw || fdraw) ) return;
        
        Stroke origStroke = null;
        if ( sdraw ) {
            origStroke = g.getStroke();
            g.setStroke(stroke);
        }
        
        int x, y, w, h, aw, ah;
        double xx, yy, ww, hh;

        // see if an optimized (non-shape) rendering call is available for us
        // these can speed things up significantly on the windows JRE
        // it is stupid we have to do this, but we do what we must
        // if we are zoomed in, we have no choice but to use
        // full precision rendering methods.
        AffineTransform at = g.getTransform();
        double scale = Math.max(at.getScaleX(), at.getScaleY());
        if ( scale > 1.5 ) {
            if (fdraw) { g.setPaint(fillColor);   g.fill(shape); }
            if (sdraw) { g.setPaint(strokeColor); g.draw(shape); }
        }
        else if ( shape instanceof RectangularShape )
        {
            RectangularShape r = (RectangularShape)shape;
            xx = r.getX(); ww = r.getWidth(); 
            yy = r.getY(); hh = r.getHeight();
            
            x = (int)xx;
            y = (int)yy;
            w = (int)(ww+xx-x);
            h = (int)(hh+yy-y);
            
            if ( shape instanceof Rectangle2D ) {
                if (fdraw) {
                    g.setPaint(fillColor);
                    g.fillRect(x, y, w, h);
                }
                if (sdraw) {
                    g.setPaint(strokeColor);
                    g.drawRect(x, y, w, h);
                }
            } else if ( shape instanceof RoundRectangle2D ) {
                RoundRectangle2D rr = (RoundRectangle2D)shape;
                aw = (int)rr.getArcWidth();
                ah = (int)rr.getArcHeight();
                if (fdraw) {
                    g.setPaint(fillColor);
                    g.fillRoundRect(x, y, w, h, aw, ah);
                }
                if (sdraw) {
                    g.setPaint(strokeColor);
                    g.drawRoundRect(x, y, w, h, aw, ah);
                }
            } else if ( shape instanceof Ellipse2D ) {
                if (fdraw) {
                    g.setPaint(fillColor);
                    g.fillOval(x, y, w, h);
                }
                if (sdraw) {
                    g.setPaint(strokeColor);
                    g.drawOval(x, y, w, h);
                }
            } else {
                if (fdraw) { g.setPaint(fillColor);   g.fill(shape); }
                if (sdraw) { g.setPaint(strokeColor); g.draw(shape); }
            }
        } else if ( shape instanceof Line2D ) {
            if (sdraw) {
                Line2D l = (Line2D)shape;
                x = (int)(l.getX1()+0.5);
                y = (int)(l.getY1()+0.5);
                w = (int)(l.getX2()+0.5);
                h = (int)(l.getY2()+0.5);
                g.setPaint(strokeColor);
                g.drawLine(x, y, w, h);
            }
        } else {
            if (fdraw) { g.setPaint(fillColor);   g.fill(shape); }
            if (sdraw) { g.setPaint(strokeColor); g.draw(shape); }
        }
        if ( sdraw ) {
            g.setStroke(origStroke);
        }
    }
    
} // end of class GraphicsLib
@


2.3.4.1
log
@First import of a Java 1.5-targetted version of prefuse.
@
text
@a16 1
import prefuse.Alignment;
a17 1
import prefuse.render.AbstractShapeRenderer.RenderType;
d24 1
a24 1
 *
d29 7
a35 11
	public static enum IntersectionType {
		/** Indicates intersection between shapes */
		INTERSECTION,
	    /** Indicates no intersection between shapes */
		NO_INTERSECTION,
	    /** Indicates coincidence between shapes */
		COINCIDENT,
	    /** Indicates two lines are parallel */
		PARALLEL
	}

d44 1
a44 1
    public static IntersectionType intersectLineLine(Line2D a, Line2D b, Point2D intersect) {
d51 1
a51 1

d66 2
a67 2
    public static IntersectionType intersectLineLine(double a1x, double a1y, double a2x,
        double a2y, double b1x, double b1y, double b2x, double b2y,
d80 1
a80 1
                return IntersectionType.INTERSECTION;
d82 1
a82 1
                return IntersectionType.NO_INTERSECTION;
d85 1
a85 1
            return ua_t == 0 || ub_t == 0 ? IntersectionType.COINCIDENT : IntersectionType.PARALLEL;
d95 1
a95 1
     * the results
d104 4
a107 8

        if ( pts[0] == null ) {
			pts[0] = new Point2D.Double();
		}
        if ( pts[1] == null ) {
			pts[1] = new Point2D.Double();
		}

d109 6
a114 18
        if ( intersectLineLine(mnx,mny,mxx,mny,a1x,a1y,a2x,a2y,pts[i]) == IntersectionType.INTERSECTION ) {
			i++;
		}
        if ( intersectLineLine(mxx,mny,mxx,mxy,a1x,a1y,a2x,a2y,pts[i]) == IntersectionType.INTERSECTION ) {
			i++;
		}
        if ( i == 2 ) {
			return i;
		}
        if ( intersectLineLine(mxx,mxy,mnx,mxy,a1x,a1y,a2x,a2y,pts[i]) == IntersectionType.INTERSECTION ) {
			i++;
		}
        if ( i == 2 ) {
			return i;
		}
        if ( intersectLineLine(mnx,mxy,mnx,mny,a1x,a1y,a2x,a2y,pts[i]) == IntersectionType.INTERSECTION ) {
			i++;
		}
d123 1
a123 1
     * the results
d132 4
a135 8

        if ( pts[0] == null ) {
			pts[0] = new Point2D.Double();
		}
        if ( pts[1] == null ) {
			pts[1] = new Point2D.Double();
		}

d137 6
a142 18
        if ( intersectLineLine(mnx,mny,mxx,mny,a1x,a1y,a2x,a2y,pts[i]) == IntersectionType.INTERSECTION ) {
			i++;
		}
        if ( intersectLineLine(mxx,mny,mxx,mxy,a1x,a1y,a2x,a2y,pts[i]) == IntersectionType.INTERSECTION ) {
			i++;
		}
        if ( i == 2 ) {
			return i;
		}
        if ( intersectLineLine(mxx,mxy,mnx,mxy,a1x,a1y,a2x,a2y,pts[i]) == IntersectionType.INTERSECTION ) {
			i++;
		}
        if ( i == 2 ) {
			return i;
		}
        if ( intersectLineLine(mnx,mxy,mnx,mny,a1x,a1y,a2x,a2y,pts[i]) == IntersectionType.INTERSECTION ) {
			i++;
		}
d145 1
a145 1

d150 1
a150 1
     *
d153 1
a153 1
     *
d169 1
a169 1

d174 1
a174 1
     *
d177 1
a177 1
     *
d181 1
a181 1
    public static double[] convexHull(double[] pts, int len,
d194 1
a194 1

d201 1
a201 1
                i0 = pts[i] < pts[i0] ? i : i0;
d204 1
a204 1

d207 1
a207 3
            if ( i == i0 ) {
				continue;
			}
d212 1
a212 1

d241 1
a241 1

d252 1
a252 1

d255 1
a255 3
            if ( idx[j] == -1 ) {
				continue; // skip tossed out points
			}
d268 1
a268 1

d284 2
a285 2
        angle1 = Math.acos( ( l2*l2+l6*l6-l4*l4 ) / (2*l2*l6) );
        angle2 = Math.acos( ( l6*l6+l1*l1-l5*l5 ) / (2*l6*l1) );
d287 1
a287 1
        angle = Math.PI - angle1 - angle2;
d290 1
a290 1
            return true;
d292 1
a292 1
            return false;
d295 1
a295 1

d312 1
a312 1

d315 1
a315 1
     * the centroid of the polygon.
d332 1
a332 1

d351 1
a351 1

d374 1
a374 1

d391 1
a391 1
    public static GeneralPath cardinalSpline(GeneralPath p,
d395 2
a396 5
        for ( ; npoints<pts.length; ++npoints ) {
			if ( Float.isNaN(pts[npoints]) ) {
				break;
			}
		}
d399 1
a399 1

d418 1
a418 1
    public static GeneralPath cardinalSpline(GeneralPath p,
d425 1
a425 1

d430 1
a430 1

d432 1
a432 1

d441 1
a441 1

d452 1
a452 1

d461 1
a461 1

d476 1
a476 1

d494 1
a494 1
    public static GeneralPath stackSpline(GeneralPath p, float[] pts,
d498 2
a499 5
        for ( ; npoints<pts.length; ++npoints ) {
			if ( Float.isNaN(pts[npoints]) ) {
				break;
			}
		}
d502 1
a502 1

d522 1
a522 1
    public static GeneralPath stackSpline(GeneralPath p,
d529 1
a529 1

d534 1
a534 1

d544 1
a544 1

d550 1
a550 1
            dy2 = pts[i+3]-pts[i-1];
d561 1
a561 1

d575 1
a575 1

d577 1
a577 1
        if ( closed ) {
d594 1
a594 1

d604 1
a604 1

d606 1
a606 1

d617 1
a617 1
    public static void setBounds(VisualItem<?> item,
a619 20
    	// TODO: can this be made more efficient - like by avoiding construction of bounds object?
    	Rectangle2D bounds = new Rectangle2D.Double();
    	calculateBounds(item, shape, stroke, bounds);
        item.setBounds(bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight());
    }

    /**
     * Calculates a VisualItem's bounds based on its shape and stroke type. This
     * method is optimized to avoid calling .getBounds2D where it can, thus
     * avoiding object initialization and reducing object churn.
     * @@param item the VisualItem whose bounds are to be set
     * @@param shape a Shape from which to determine the item bounds
     * @@param stroke the stroke type that will be used for drawing the object,
     * and may affect the final bounds. A null value indicates the
     * default (line width = 1) stroke is used.
     * @@param bounds the rectangle to populate with the bounds
     */
    public static void calculateBounds(VisualItem<?> item,
                                 Shape shape, BasicStroke stroke, Rectangle2D bounds)
    {
d621 1
a621 1

d654 2
a655 2
            x = r.getMinX();
            y = r.getMinY();
d659 2
a660 2

        // adjust boundary for stroke length as necessary
d665 1
a665 2

        bounds.setRect(x, y, w, h);
d667 1
a667 2


d682 5
a686 1
     * filled, or both.
d688 2
a689 2
    public static void paint(Graphics2D g, VisualItem<?> item,
                             Shape shape, BasicStroke stroke, RenderType type)
d692 3
a694 4
        if ( type == AbstractShapeRenderer.RenderType.NONE ) {
			return;
		}

d698 2
a699 2
        boolean sdraw = (type == AbstractShapeRenderer.RenderType.DRAW ||
                         type == AbstractShapeRenderer.RenderType.DRAW_AND_FILL) &&
d701 2
a702 2
        boolean fdraw = (type == AbstractShapeRenderer.RenderType.FILL ||
                         type == AbstractShapeRenderer.RenderType.DRAW_AND_FILL) &&
d704 2
a705 4
        if ( !(sdraw || fdraw) ) {
			return;
		}

d711 1
a711 1

d729 1
a729 1
            xx = r.getX(); ww = r.getWidth();
d731 1
a731 1

d736 1
a736 1

d789 1
a789 20

	/**
	 * Helper method, which calculates the top-left co-ordinate of a rectangle
	 * given the rectangle's alignment.
	 */
	public static void getAlignedPoint(Point2D p, Rectangle2D r, Alignment xAlign, Alignment yAlign) {
	    double x = r.getX(), y = r.getY(), w = r.getWidth(), h = r.getHeight();
	    if ( xAlign == Alignment.CENTER ) {
	        x = x+w/2;
	    } else if ( xAlign == Alignment.RIGHT ) {
	        x = x+w;
	    }
	    if ( yAlign == Alignment.CENTER ) {
	        y = y+h/2;
	    } else if ( yAlign == Alignment.BOTTOM ) {
	        y = y+h;
	    }
	    p.setLocation(x,y);
	}

@


2.3.4.2
log
@Moved RenderType outside of AbstractShapeRenderer (it is now a top level enum)
@
text
@d18 2
a19 1
import prefuse.render.RenderType;
d758 1
a758 1
        if ( type == RenderType.NONE ) {
d765 2
a766 2
        boolean sdraw = (type == RenderType.DRAW ||
                         type == RenderType.DRAW_AND_FILL) &&
d768 2
a769 2
        boolean fdraw = (type == RenderType.FILL ||
                         type == RenderType.DRAW_AND_FILL) &&
@


2.3.4.3
log
@Documentation improvements
@
text
@d46 2
a47 2
     * @@return the intersection code. One of {@@link IntersectionType#NO_INTERSECTION},
     * {@@link IntersectionType#COINCIDENT}, or {@@link IntersectionType#PARALLEL}.
d68 2
a69 2
     * @@return the intersection code. One of {@@link IntersectionType#NO_INTERSECTION},
     * {@@link IntersectionType#COINCIDENT}, or {@@link IntersectionType#PARALLEL}.
d101 2
a102 2
     * @@return the intersection code. One of {@@link IntersectionType#NO_INTERSECTION},
     * {@@link IntersectionType#COINCIDENT}, or {@@link IntersectionType#PARALLEL}.
d145 2
a146 2
     * @@return the intersection code. One of {@@link IntersectionType#NO_INTERSECTION},
     * {@@link IntersectionType#COINCIDENT}, or {@@link IntersectionType#PARALLEL}.
@


2.3.4.4
log
@GraphicsLib is no longer aware of VisualItem. The Renderers now provide the necessary information to GraphicsLib
@
text
@d19 1
d655 1
a655 1
     * Calculates bounds based on a shape and stroke type. This
d658 21
a678 1
     * @@param shape a Shape from which to determine the bounds
d684 2
a685 1
    public static void calculateBounds(Shape shape, BasicStroke stroke, Rectangle2D bounds)
d753 1
a753 1
    public static void paint(Graphics2D g, Color strokeColor, Color fillColor,
d762 2
@


2.3.4.5
log
@reverted some changes - support for old methods reinstated
@
text
@a18 1
import prefuse.visual.VisualItem;
a653 19
     * Sets a VisualItem's bounds based on its shape and stroke type. This
     * method is optimized to avoid calling .getBounds2D where it can, thus
     * avoiding object initialization and reducing object churn.
     * @@param item the VisualItem whose bounds are to be set
     * @@param shape a Shape from which to determine the item bounds
     * @@param stroke the stroke type that will be used for drawing the object,
     * and may affect the final bounds. A null value indicates the
     * default (line width = 1) stroke is used.
     */
    public static void setBounds(VisualItem<?> item,
                                 Shape shape, BasicStroke stroke)
    {
    	// TODO: can this be made more efficient - like by avoiding construction of bounds object?
    	Rectangle2D bounds = new Rectangle2D.Double();
    	calculateBounds(shape, stroke, bounds);
        item.setBounds(bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight());
    }

    /**
d714 1
a729 23
     * @@deprecated use the other paint() method instead
     */
    public static void paint(Graphics2D g, VisualItem<?> item, Shape shape,
			BasicStroke stroke, RenderType type) {
		paint(g, ColorLib.getColor(item.getStrokeColor()), ColorLib
				.getColor(item.getFillColor()), shape, stroke, type);
	}
    
    /**
     * Render a shape associated with a VisualItem into a graphics context. This
     * method uses the {@@link java.awt.Graphics} interface methods when it can,
     * as opposed to the {@@link java.awt.Graphics2D} methods such as
     * {@@link java.awt.Graphics2D#draw(java.awt.Shape)} and
     * {@@link java.awt.Graphics2D#fill(java.awt.Shape)}, resulting in a
     * significant performance increase on the Windows platform, particularly
     * for rectangle and line drawing calls.
     * @@param g the graphics context to render to
     * @@param strokeColor the stroke color to use for drawing the object.
     * @@param fillColor the fill color to use for drawing the object.
     * @@param shape the shape to render
     * @@param stroke the stroke type to use for drawing the object.
     * @@param type the rendering type indicating if the shape should be drawn,
     * filled, or both.
@


2.3.4.6
log
@Removed TODO item
@
text
@d667 1
d756 1
a756 1

@


2.3.4.7
log
@added a new function to assist with curved edge rendering
@
text
@d22 3
a24 3
 * Library of useful computer graphics routines such as geometry routines for
 * computing the intersection of different shapes and rendering methods for
 * computing bounds and performing optimized drawing.
d33 1
a33 1
		/** Indicates no intersection between shapes */
d35 1
a35 1
		/** Indicates coincidence between shapes */
d37 1
a37 1
		/** Indicates two lines are parallel */
d41 68
a108 73
	/**
	 * Compute the intersection of two line segments.
	 *
	 * @@param a
	 *            the first line segment
	 * @@param b
	 *            the second line segment
	 * @@param intersect
	 *            a Point in which to store the intersection point
	 * @@return the intersection code. One of
	 *         {@@link IntersectionType#NO_INTERSECTION},
	 *         {@@link IntersectionType#COINCIDENT}, or
	 *         {@@link IntersectionType#PARALLEL}.
	 */
	public static IntersectionType intersectLineLine(Line2D a, Line2D b,
			Point2D intersect) {
		double a1x = a.getX1(), a1y = a.getY1();
		double a2x = a.getX2(), a2y = a.getY2();
		double b1x = b.getX1(), b1y = b.getY1();
		double b2x = b.getX2(), b2y = b.getY2();
		return intersectLineLine(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y,
				intersect);
	}

	/**
	 * Compute the intersection of two line segments.
	 *
	 * @@param a1x
	 *            the x-coordinate of the first endpoint of the first line
	 * @@param a1y
	 *            the y-coordinate of the first endpoint of the first line
	 * @@param a2x
	 *            the x-coordinate of the second endpoint of the first line
	 * @@param a2y
	 *            the y-coordinate of the second endpoint of the first line
	 * @@param b1x
	 *            the x-coordinate of the first endpoint of the second line
	 * @@param b1y
	 *            the y-coordinate of the first endpoint of the second line
	 * @@param b2x
	 *            the x-coordinate of the second endpoint of the second line
	 * @@param b2y
	 *            the y-coordinate of the second endpoint of the second line
	 * @@param intersect
	 *            a Point in which to store the intersection point
	 * @@return the intersection code. One of
	 *         {@@link IntersectionType#NO_INTERSECTION},
	 *         {@@link IntersectionType#COINCIDENT}, or
	 *         {@@link IntersectionType#PARALLEL}.
	 */
	public static IntersectionType intersectLineLine(double a1x, double a1y,
			double a2x, double a2y, double b1x, double b1y, double b2x,
			double b2y, Point2D intersect) {
		double ua_t = (b2x - b1x) * (a1y - b1y) - (b2y - b1y) * (a1x - b1x);
		double ub_t = (a2x - a1x) * (a1y - b1y) - (a2y - a1y) * (a1x - b1x);
		double u_b = (b2y - b1y) * (a2x - a1x) - (b2x - b1x) * (a2y - a1y);

		if (u_b != 0) {
			double ua = ua_t / u_b;
			double ub = ub_t / u_b;

			if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
				intersect.setLocation(a1x + ua * (a2x - a1x), a1y + ua
						* (a2y - a1y));
				return IntersectionType.INTERSECTION;
			} else {
				return IntersectionType.NO_INTERSECTION;
			}
		} else {
			return ua_t == 0 || ub_t == 0 ? IntersectionType.COINCIDENT
					: IntersectionType.PARALLEL;
		}
	}
d110 1
a110 25
	/**
	 * Compute the intersection of a line and a rectangle.
	 *
	 * @@param a1
	 *            the first endpoint of the line
	 * @@param a2
	 *            the second endpoint of the line
	 * @@param r
	 *            the rectangle
	 * @@param pts
	 *            a length 2 or greater array of points in which to store the
	 *            results
	 * @@return the intersection code. One of
	 *         {@@link IntersectionType#NO_INTERSECTION},
	 *         {@@link IntersectionType#COINCIDENT}, or
	 *         {@@link IntersectionType#PARALLEL}.
	 */
	public static int intersectLineRectangle(Point2D a1, Point2D a2,
			Rectangle2D r, Point2D[] pts) {
		double a1x = a1.getX(), a1y = a1.getY();
		double a2x = a2.getX(), a2y = a2.getY();
		double mxx = r.getMaxX(), mxy = r.getMaxY();
		double mnx = r.getMinX(), mny = r.getMinY();

		if (pts[0] == null) {
d113 1
a113 1
		if (pts[1] == null) {
d117 2
a118 2
		int i = 0;
		if (intersectLineLine(mnx, mny, mxx, mny, a1x, a1y, a2x, a2y, pts[i]) == IntersectionType.INTERSECTION) {
d121 1
a121 1
		if (intersectLineLine(mxx, mny, mxx, mxy, a1x, a1y, a2x, a2y, pts[i]) == IntersectionType.INTERSECTION) {
d124 1
a124 1
		if (i == 2) {
d127 1
a127 1
		if (intersectLineLine(mxx, mxy, mnx, mxy, a1x, a1y, a2x, a2y, pts[i]) == IntersectionType.INTERSECTION) {
d130 1
a130 1
		if (i == 2) {
d133 1
a133 1
		if (intersectLineLine(mnx, mxy, mnx, mny, a1x, a1y, a2x, a2y, pts[i]) == IntersectionType.INTERSECTION) {
d136 2
a137 2
		return i;
	}
d139 14
a152 21
	/**
	 * Compute the intersection of a line and a rectangle.
	 *
	 * @@param l
	 *            the line
	 * @@param r
	 *            the rectangle
	 * @@param pts
	 *            a length 2 or greater array of points in which to store the
	 *            results
	 * @@return the intersection code. One of
	 *         {@@link IntersectionType#NO_INTERSECTION},
	 *         {@@link IntersectionType#COINCIDENT}, or
	 *         {@@link IntersectionType#PARALLEL}.
	 */
	public static int intersectLineRectangle(Line2D l, Rectangle2D r,
			Point2D[] pts) {
		double a1x = l.getX1(), a1y = l.getY1();
		double a2x = l.getX2(), a2y = l.getY2();
		double mxx = r.getMaxX(), mxy = r.getMaxY();
		double mnx = r.getMinX(), mny = r.getMinY();
d154 1
a154 1
		if (pts[0] == null) {
d157 1
a157 1
		if (pts[1] == null) {
d161 2
a162 2
		int i = 0;
		if (intersectLineLine(mnx, mny, mxx, mny, a1x, a1y, a2x, a2y, pts[i]) == IntersectionType.INTERSECTION) {
d165 1
a165 1
		if (intersectLineLine(mxx, mny, mxx, mxy, a1x, a1y, a2x, a2y, pts[i]) == IntersectionType.INTERSECTION) {
d168 1
a168 1
		if (i == 2) {
d171 1
a171 1
		if (intersectLineLine(mxx, mxy, mnx, mxy, a1x, a1y, a2x, a2y, pts[i]) == IntersectionType.INTERSECTION) {
d174 1
a174 1
		if (i == 2) {
d177 1
a177 1
		if (intersectLineLine(mnx, mxy, mnx, mny, a1x, a1y, a2x, a2y, pts[i]) == IntersectionType.INTERSECTION) {
d180 2
a181 62
		return i;
	}

	/**
	 * Computes the 2D convex hull of a set of points using Graham's scanning
	 * algorithm. The algorithm has been implemented as described in Cormen,
	 * Leiserson, and Rivest's Introduction to Algorithms.
	 *
	 * The running time of this algorithm is O(n log n), where n is the number
	 * of input points.
	 *
	 * @@param pts
	 *            the input points in [x0,y0,x1,y1,...] order
	 * @@param len
	 *            the length of the pts array to consider (2 * #points)
	 * @@return the convex hull of the input points
	 */
	public static double[] convexHull(double[] pts, int len) {
		if (len < 6) {
			throw new IllegalArgumentException(
					"Input must have at least 3 points");
		}
		int plen = len / 2 - 1;
		float[] angles = new float[plen];
		int[] idx = new int[plen];
		int[] stack = new int[len / 2];
		return convexHull(pts, len, angles, idx, stack);
	}

	/**
	 * Computes the 2D convex hull of a set of points using Graham's scanning
	 * algorithm. The algorithm has been implemented as described in Cormen,
	 * Leiserson, and Rivest's Introduction to Algorithms.
	 *
	 * The running time of this algorithm is O(n log n), where n is the number
	 * of input points.
	 *
	 * @@param pts
	 * @@return the convex hull of the input points
	 */
	public static double[] convexHull(double[] pts, int len, float[] angles,
			int[] idx, int[] stack) {
		// check arguments
		int plen = len / 2 - 1;
		if (len < 6) {
			throw new IllegalArgumentException(
					"Input must have at least 3 points");
		}
		if (angles.length < plen || idx.length < plen || stack.length < len / 2) {
			throw new IllegalArgumentException(
					"Pre-allocated data structure too small");
		}

		int i0 = 0;
		// find the starting ref point: leftmost point with the minimum y coord
		for (int i = 2; i < len; i += 2) {
			if (pts[i + 1] < pts[i0 + 1]) {
				i0 = i;
			} else if (pts[i + 1] == pts[i0 + 1]) {
				i0 = pts[i] < pts[i0] ? i : i0;
			}
		}
d183 62
a244 3
		// calculate polar angles from ref point and sort
		for (int i = 0, j = 0; i < len; i += 2) {
			if (i == i0) {
d247 48
a294 49
			angles[j] = (float) Math.atan2(pts[i + 1] - pts[i0 + 1], pts[i]
					- pts[i0]);
			idx[j++] = i;
		}
		ArrayLib.sort(angles, idx, plen);

		// toss out duplicated angles
		float angle = angles[0];
		int ti = 0, tj = idx[0];
		for (int i = 1; i < plen; i++) {
			int j = idx[i];
			if (angle == angles[i]) {
				// keep whichever angle corresponds to the most distant
				// point from the reference point
				double x1 = pts[tj] - pts[i0];
				double y1 = pts[tj + 1] - pts[i0 + 1];
				double x2 = pts[j] - pts[i0];
				double y2 = pts[j + 1] - pts[i0 + 1];
				double d1 = x1 * x1 + y1 * y1;
				double d2 = x2 * x2 + y2 * y2;
				if (d1 >= d2) {
					idx[i] = -1;
				} else {
					idx[ti] = -1;
					angle = angles[i];
					ti = i;
					tj = j;
				}
			} else {
				angle = angles[i];
				ti = i;
				tj = j;
			}
		}

		// initialize our stack
		int sp = 0;
		stack[sp++] = i0;
		int j = 0;
		for (int k = 0; k < 2; j++) {
			if (idx[j] != -1) {
				stack[sp++] = idx[j];
				k++;
			}
		}

		// do graham's scan
		for (; j < plen; j++) {
			if (idx[j] == -1) {
d297 141
a437 170
			while (isNonLeft(i0, stack[sp - 2], stack[sp - 1], idx[j], pts)) {
				sp--;
			}
			stack[sp++] = idx[j];
		}

		// construct the hull
		double[] hull = new double[2 * sp];
		for (int i = 0; i < sp; i++) {
			hull[2 * i] = pts[stack[i]];
			hull[2 * i + 1] = pts[stack[i] + 1];
		}

		return hull;
	}

	/**
	 * Convex hull helper method for detecting a non left turn about 3 points
	 */
	private static boolean isNonLeft(int i0, int i1, int i2, int i3,
			double[] pts) {
		double l1, l2, l4, l5, l6, angle1, angle2, angle;

		l1 = Math.sqrt(Math.pow(pts[i2 + 1] - pts[i1 + 1], 2)
				+ Math.pow(pts[i2] - pts[i1], 2));
		l2 = Math.sqrt(Math.pow(pts[i3 + 1] - pts[i2 + 1], 2)
				+ Math.pow(pts[i3] - pts[i2], 2));
		l4 = Math.sqrt(Math.pow(pts[i3 + 1] - pts[i0 + 1], 2)
				+ Math.pow(pts[i3] - pts[i0], 2));
		l5 = Math.sqrt(Math.pow(pts[i1 + 1] - pts[i0 + 1], 2)
				+ Math.pow(pts[i1] - pts[i0], 2));
		l6 = Math.sqrt(Math.pow(pts[i2 + 1] - pts[i0 + 1], 2)
				+ Math.pow(pts[i2] - pts[i0], 2));

		angle1 = Math.acos((l2 * l2 + l6 * l6 - l4 * l4) / (2 * l2 * l6));
		angle2 = Math.acos((l6 * l6 + l1 * l1 - l5 * l5) / (2 * l6 * l1));

		angle = Math.PI - angle1 - angle2;

		if (angle <= 0.0) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Computes the mean, or centroid, of a set of points
	 *
	 * @@param pts
	 *            the points array, in x1, y1, x2, y2, ... arrangement.
	 * @@param len
	 *            the length of the array to consider
	 * @@return the centroid as a length-2 float array
	 */
	public static float[] centroid(float pts[], int len) {
		float[] c = new float[] { 0, 0 };
		for (int i = 0; i < len; i += 2) {
			c[0] += pts[i];
			c[1] += pts[i + 1];
		}
		c[0] /= len / 2;
		c[1] /= len / 2;
		return c;
	}

	/**
	 * Expand a polygon by adding the given distance along the line from the
	 * centroid of the polygon.
	 *
	 * @@param pts
	 *            the polygon to expand, a set of points in a float array
	 * @@param len
	 *            the length of the range of the array to consider
	 * @@param amt
	 *            the amount by which to expand the polygon, each point will be
	 *            moved this distance along the line from the centroid of the
	 *            polygon to the given point.
	 */
	public static void growPolygon(float pts[], int len, float amt) {
		float[] c = centroid(pts, len);
		for (int i = 0; i < len; i += 2) {
			float vx = pts[i] - c[0];
			float vy = pts[i + 1] - c[1];
			float norm = (float) Math.sqrt(vx * vx + vy * vy);
			pts[i] += amt * vx / norm;
			pts[i + 1] += amt * vy / norm;
		}
	}

	/**
	 * Compute a cardinal spline, a series of cubic Bezier splines smoothly
	 * connecting a set of points. Cardinal splines maintain C(1) continuity,
	 * ensuring the connected spline segments form a differentiable curve,
	 * ensuring at least a minimum level of smoothness.
	 *
	 * @@param pts
	 *            the points to interpolate with a cardinal spline
	 * @@param slack
	 *            a parameter controlling the "tightness" of the spline to the
	 *            control points, 0.10 is a typically suitable value
	 * @@param closed
	 *            true if the cardinal spline should be closed (i.e. return to
	 *            the starting point), false for an open curve
	 * @@return the cardinal spline as a Java2D {@@link java.awt.geom.GeneralPath}
	 *         instance.
	 */
	public static GeneralPath cardinalSpline(float pts[], float slack,
			boolean closed) {
		GeneralPath path = new GeneralPath();
		path.moveTo(pts[0], pts[1]);
		return cardinalSpline(path, pts, slack, closed, 0f, 0f);
	}

	/**
	 * Compute a cardinal spline, a series of cubic Bezier splines smoothly
	 * connecting a set of points. Cardinal splines maintain C(1) continuity,
	 * ensuring the connected spline segments form a differentiable curve,
	 * ensuring at least a minimum level of smoothness.
	 *
	 * @@param pts
	 *            the points to interpolate with a cardinal spline
	 * @@param start
	 *            the starting index from which to read points
	 * @@param npoints
	 *            the number of points to consider
	 * @@param slack
	 *            a parameter controlling the "tightness" of the spline to the
	 *            control points, 0.10 is a typically suitable value
	 * @@param closed
	 *            true if the cardinal spline should be closed (i.e. return to
	 *            the starting point), false for an open curve
	 * @@return the cardinal spline as a Java2D {@@link java.awt.geom.GeneralPath}
	 *         instance.
	 */
	public static GeneralPath cardinalSpline(float pts[], int start,
			int npoints, float slack, boolean closed) {
		GeneralPath path = new GeneralPath();
		path.moveTo(pts[start], pts[start + 1]);
		return cardinalSpline(path, pts, start, npoints, slack, closed, 0f, 0f);
	}

	/**
	 * Compute a cardinal spline, a series of cubic Bezier splines smoothly
	 * connecting a set of points. Cardinal splines maintain C(1) continuity,
	 * ensuring the connected spline segments form a differentiable curve,
	 * ensuring at least a minimum level of smoothness.
	 *
	 * @@param p
	 *            the GeneralPath instance to use to store the result
	 * @@param pts
	 *            the points to interpolate with a cardinal spline
	 * @@param slack
	 *            a parameter controlling the "tightness" of the spline to the
	 *            control points, 0.10 is a typically suitable value
	 * @@param closed
	 *            true if the cardinal spline should be closed (i.e. return to
	 *            the starting point), false for an open curve
	 * @@param tx
	 *            a value by which to translate the curve along the x-dimension
	 * @@param ty
	 *            a value by which to translate the curve along the y-dimension
	 * @@return the cardinal spline as a Java2D {@@link java.awt.geom.GeneralPath}
	 *         instance.
	 */
	public static GeneralPath cardinalSpline(GeneralPath p, float pts[],
			float slack, boolean closed, float tx, float ty) {
		int npoints = 0;
		for (; npoints < pts.length; ++npoints) {
			if (Float.isNaN(pts[npoints])) {
d441 2
a442 161
		return cardinalSpline(p, pts, 0, npoints / 2, slack, closed, tx, ty);
	}

	/**
	 * Compute a cardinal spline, a series of cubic Bezier splines smoothly
	 * connecting a set of points. Cardinal splines maintain C(1) continuity,
	 * ensuring the connected spline segments form a differentiable curve,
	 * ensuring at least a minimum level of smoothness.
	 *
	 * @@param p
	 *            the GeneralPath instance to use to store the result
	 * @@param pts
	 *            the points to interpolate with a cardinal spline
	 * @@param start
	 *            the starting index from which to read points
	 * @@param npoints
	 *            the number of points to consider
	 * @@param slack
	 *            a parameter controlling the "tightness" of the spline to the
	 *            control points, 0.10 is a typically suitable value
	 * @@param closed
	 *            true if the cardinal spline should be closed (i.e. return to
	 *            the starting point), false for an open curve
	 * @@param tx
	 *            a value by which to translate the curve along the x-dimension
	 * @@param ty
	 *            a value by which to translate the curve along the y-dimension
	 * @@return the cardinal spline as a Java2D {@@link java.awt.geom.GeneralPath}
	 *         instance.
	 */
	public static GeneralPath cardinalSpline(GeneralPath p, float pts[],
			int start, int npoints, float slack, boolean closed, float tx,
			float ty) {
		// compute the size of the path
		int len = 2 * npoints;
		int end = start + len;

		if (len < 6) {
			throw new IllegalArgumentException(
					"To create spline requires at least 3 points");
		}

		float dx1, dy1, dx2, dy2;

		// compute first control point
		if (closed) {
			dx2 = pts[start + 2] - pts[end - 2];
			dy2 = pts[start + 3] - pts[end - 1];
		} else {
			dx2 = pts[start + 4] - pts[start];
			dy2 = pts[start + 5] - pts[start + 1];
		}

		// repeatedly compute next control point and append curve
		int i;
		for (i = start + 2; i < end - 2; i += 2) {
			dx1 = dx2;
			dy1 = dy2;
			dx2 = pts[i + 2] - pts[i - 2];
			dy2 = pts[i + 3] - pts[i - 1];
			p.curveTo(tx + pts[i - 2] + slack * dx1, ty + pts[i - 1] + slack
					* dy1, tx + pts[i] - slack * dx2, ty + pts[i + 1] - slack
					* dy2, tx + pts[i], ty + pts[i + 1]);
		}

		// compute last control point
		if (closed) {
			dx1 = dx2;
			dy1 = dy2;
			dx2 = pts[start] - pts[i - 2];
			dy2 = pts[start + 1] - pts[i - 1];
			p.curveTo(tx + pts[i - 2] + slack * dx1, ty + pts[i - 1] + slack
					* dy1, tx + pts[i] - slack * dx2, ty + pts[i + 1] - slack
					* dy2, tx + pts[i], ty + pts[i + 1]);

			dx1 = dx2;
			dy1 = dy2;
			dx2 = pts[start + 2] - pts[end - 2];
			dy2 = pts[start + 3] - pts[end - 1];
			p.curveTo(tx + pts[end - 2] + slack * dx1, ty + pts[end - 1]
					+ slack * dy1, tx + pts[0] - slack * dx2, ty + pts[1]
					- slack * dy2, tx + pts[0], ty + pts[1]);
			p.closePath();
		} else {
			p.curveTo(tx + pts[i - 2] + slack * dx2, ty + pts[i - 1] + slack
					* dy2, tx + pts[i] - slack * dx2, ty + pts[i + 1] - slack
					* dy2, tx + pts[i], ty + pts[i + 1]);
		}
		return p;
	}

	/**
	 * Compute a cardinal spline, a series of cubic Bezier splines smoothly
	 * connecting a set of points. Cardinal splines maintain C(1) continuity,
	 * ensuring the connected spline segments form a differentiable curve,
	 * ensuring at least a minimum level of smoothness.
	 *
	 * @@param p
	 *            the GeneralPath instance to use to store the result
	 * @@param pts
	 *            the points to interpolate with a cardinal spline
	 * @@param start
	 *            the starting index from which to read points
	 * @@param npoints
	 *            the number of points to consider
	 * @@param slack
	 *            a parameter controlling the "tightness" of the spline to the
	 *            control points, 0.10 is a typically suitable value
	 * @@param closed
	 *            true if the cardinal spline should be closed (i.e. return to
	 *            the starting point), false for an open curve
	 * @@param tx
	 *            a value by which to translate the curve along the x-dimension
	 * @@param ty
	 *            a value by which to translate the curve along the y-dimension
	 * @@return the cardinal spline as a Java2D {@@link java.awt.geom.GeneralPath}
	 *         instance.
	 */
	public static GeneralPath cardinalSpline(GeneralPath p, float pts[],
			boolean[] invisibleSegments, float slack, float tx, float ty) {
		// compute the size of the path
		final int end = pts.length;

		if (end < 6) {
			throw new IllegalArgumentException(
					"To create spline requires at least 3 points");
		}
		if(pts.length / 2 != invisibleSegments.length + 1) {
			throw new IllegalArgumentException("Incorrect number of invisible segment flags: ");
		}

		float dx1, dy1, dx2, dy2;

		// compute first control point
		dx2 = pts[4] - pts[0];
		dy2 = pts[5] - pts[1];

		// repeatedly compute next control point and append curve
		int i;
		for (i = 2; i < end - 2; i += 2) {
			dx1 = dx2;
			dy1 = dy2;
			dx2 = pts[i + 2] - pts[i - 2];
			dy2 = pts[i + 3] - pts[i - 1];
			if (!invisibleSegments[i / 2 - 1]) {
				p.curveTo(tx + pts[i - 2] + slack * dx1, ty + pts[i - 1]
						+ slack * dy1, tx + pts[i] - slack * dx2, ty
						+ pts[i + 1] - slack * dy2, tx + pts[i], ty
						+ pts[i + 1]);
			}
		}

		// compute last control point
		if (!invisibleSegments[i / 2 - 1]) {
			p.curveTo(tx + pts[i - 2] + slack * dx2, ty + pts[i - 1] + slack
					* dy2, tx + pts[i] - slack * dx2, ty + pts[i + 1] - slack
					* dy2, tx + pts[i], ty + pts[i + 1]);
		}

		return p;
	}
d444 100
a543 30
	/**
	 * Computes a set of curves using the cardinal spline approach, but using
	 * straight lines for completely horizontal or vertical segments.
	 *
	 * @@param p
	 *            the GeneralPath instance to use to store the result
	 * @@param pts
	 *            the points to interpolate with the spline
	 * @@param epsilon
	 *            threshold value under which to treat the difference between
	 *            two values to be zero. Used to determine which segments to
	 *            treat as lines rather than curves.
	 * @@param slack
	 *            a parameter controlling the "tightness" of the spline to the
	 *            control points, 0.10 is a typically suitable value
	 * @@param closed
	 *            true if the spline should be closed (i.e. return to the
	 *            starting point), false for an open curve
	 * @@param tx
	 *            a value by which to translate the curve along the x-dimension
	 * @@param ty
	 *            a value by which to translate the curve along the y-dimension
	 * @@return the stack spline as a Java2D {@@link java.awt.geom.GeneralPath}
	 *         instance.
	 */
	public static GeneralPath stackSpline(GeneralPath p, float[] pts,
			float epsilon, float slack, boolean closed, float tx, float ty) {
		int npoints = 0;
		for (; npoints < pts.length; ++npoints) {
			if (Float.isNaN(pts[npoints])) {
d547 2
a548 105
		return stackSpline(p, pts, 0, npoints / 2, epsilon, slack, closed, tx,
				ty);
	}

	/**
	 * Computes a set of curves using the cardinal spline approach, but using
	 * straight lines for completely horizontal or vertical segments.
	 *
	 * @@param p
	 *            the GeneralPath instance to use to store the result
	 * @@param pts
	 *            the points to interpolate with the spline
	 * @@param start
	 *            the starting index from which to read points
	 * @@param npoints
	 *            the number of points to consider
	 * @@param epsilon
	 *            threshold value under which to treat the difference between
	 *            two values to be zero. Used to determine which segments to
	 *            treat as lines rather than curves.
	 * @@param slack
	 *            a parameter controlling the "tightness" of the spline to the
	 *            control points, 0.10 is a typically suitable value
	 * @@param closed
	 *            true if the spline should be closed (i.e. return to the
	 *            starting point), false for an open curve
	 * @@param tx
	 *            a value by which to translate the curve along the x-dimension
	 * @@param ty
	 *            a value by which to translate the curve along the y-dimension
	 * @@return the stack spline as a Java2D {@@link java.awt.geom.GeneralPath}
	 *         instance.
	 */
	public static GeneralPath stackSpline(GeneralPath p, float pts[],
			int start, int npoints, float epsilon, float slack, boolean closed,
			float tx, float ty) {
		// compute the size of the path
		int len = 2 * npoints;
		int end = start + len;

		if (len < 6) {
			throw new IllegalArgumentException(
					"To create spline requires at least 3 points");
		}

		float dx1, dy1, dx2, dy2;
		// compute first control point
		if (closed) {
			dx2 = pts[start + 2] - pts[end - 2];
			dy2 = pts[start + 3] - pts[end - 1];
		} else {
			dx2 = pts[start + 4] - pts[start];
			dy2 = pts[start + 5] - pts[start + 1];
		}

		// repeatedly compute next control point and append curve
		int i;
		for (i = start + 2; i < end - 2; i += 2) {
			dx1 = dx2;
			dy1 = dy2;
			dx2 = pts[i + 2] - pts[i - 2];
			dy2 = pts[i + 3] - pts[i - 1];
			if (Math.abs(pts[i] - pts[i - 2]) < epsilon
					|| Math.abs(pts[i + 1] - pts[i - 1]) < epsilon) {
				p.lineTo(tx + pts[i], ty + pts[i + 1]);
			} else {
				p.curveTo(tx + pts[i - 2] + slack * dx1, ty + pts[i - 1]
						+ slack * dy1, tx + pts[i] - slack * dx2, ty
						+ pts[i + 1] - slack * dy2, tx + pts[i], ty
						+ pts[i + 1]);
			}
		}

		// compute last control point
		dx1 = dx2;
		dy1 = dy2;
		dx2 = pts[start] - pts[i - 2];
		dy2 = pts[start + 1] - pts[i - 1];
		if (Math.abs(pts[i] - pts[i - 2]) < epsilon
				|| Math.abs(pts[i + 1] - pts[i - 1]) < epsilon) {
			p.lineTo(tx + pts[i], ty + pts[i + 1]);
		} else {
			p.curveTo(tx + pts[i - 2] + slack * dx1, ty + pts[i - 1] + slack
					* dy1, tx + pts[i] - slack * dx2, ty + pts[i + 1] - slack
					* dy2, tx + pts[i], ty + pts[i + 1]);
		}

		// close the curve if requested
		if (closed) {
			if (Math.abs(pts[end - 2] - pts[0]) < epsilon
					|| Math.abs(pts[end - 1] - pts[1]) < epsilon) {
				p.lineTo(tx + pts[0], ty + pts[1]);
			} else {
				dx1 = dx2;
				dy1 = dy2;
				dx2 = pts[start + 2] - pts[end - 2];
				dy2 = pts[start + 3] - pts[end - 1];
				p.curveTo(tx + pts[end - 2] + slack * dx1, ty + pts[end - 1]
						+ slack * dy1, tx + pts[0] - slack * dx2, ty + pts[1]
						- slack * dy2, tx + pts[0], ty + pts[1]);
			}
			p.closePath();
		}
		return p;
	}
d550 201
a750 129
	/**
	 * Expand a rectangle by the given amount.
	 *
	 * @@param r
	 *            the rectangle to expand
	 * @@param amount
	 *            the amount by which to expand the rectangle
	 */
	public static void expand(Rectangle2D r, double amount) {
		r.setRect(r.getX() - amount, r.getY() - amount, r.getWidth() + 2
				* amount, r.getHeight() + 2 * amount);
	}

	// ------------------------------------------------------------------------

	/**
	 * Sets a VisualItem's bounds based on its shape and stroke type. This
	 * method is optimized to avoid calling .getBounds2D where it can, thus
	 * avoiding object initialization and reducing object churn.
	 *
	 * @@param item
	 *            the VisualItem whose bounds are to be set
	 * @@param shape
	 *            a Shape from which to determine the item bounds
	 * @@param stroke
	 *            the stroke type that will be used for drawing the object, and
	 *            may affect the final bounds. A null value indicates the
	 *            default (line width = 1) stroke is used.
	 */
	public static void setBounds(VisualItem<?> item, Shape shape,
			BasicStroke stroke) {
		Rectangle2D bounds = new Rectangle2D.Double();
		calculateBounds(shape, stroke, bounds);
		item.setBounds(bounds.getX(), bounds.getY(), bounds.getWidth(), bounds
				.getHeight());
	}

	/**
	 * Calculates bounds based on a shape and stroke type. This method is
	 * optimized to avoid calling .getBounds2D where it can, thus avoiding
	 * object initialization and reducing object churn.
	 *
	 * @@param shape
	 *            a Shape from which to determine the bounds
	 * @@param stroke
	 *            the stroke type that will be used for drawing the object, and
	 *            may affect the final bounds. A null value indicates the
	 *            default (line width = 1) stroke is used.
	 * @@param bounds
	 *            the rectangle to populate with the bounds
	 */
	public static void calculateBounds(Shape shape, BasicStroke stroke,
			Rectangle2D bounds) {
		double x, y, w, h, lw, lw2;

		if (shape instanceof RectangularShape) {
			// this covers rectangle, rounded rectangle, ellipse, and arcs
			RectangularShape r = (RectangularShape) shape;
			x = r.getX();
			y = r.getY();
			w = r.getWidth();
			h = r.getHeight();
		} else if (shape instanceof Line2D) {
			// this covers straight lines
			Line2D l = (Line2D) shape;
			x = l.getX1();
			y = l.getY1();
			w = l.getX2();
			h = l.getY2();
			if (w < x) {
				lw = x;
				x = w;
				w = lw - x;
			} else {
				w = w - x;
			}
			if (h < y) {
				lw = y;
				y = h;
				h = lw - y;
			} else {
				h = h - y;
			}
		} else {
			// this covers any other arbitrary shapes, but
			// takes a small object allocation / garbage collection hit
			Rectangle2D r = shape.getBounds2D();
			x = r.getMinX();
			y = r.getMinY();
			w = r.getWidth();
			h = r.getHeight();
		}

		// adjust boundary for stroke length as necessary
		if (stroke != null && (lw = stroke.getLineWidth()) > 1) {
			lw2 = lw / 2.0;
			x -= lw2;
			y -= lw2;
			w += lw;
			h += lw;
		}

		bounds.setRect(x, y, w, h);
	}

	/**
	 * Render a shape associated with a VisualItem into a graphics context. This
	 * method uses the {@@link java.awt.Graphics} interface methods when it can,
	 * as opposed to the {@@link java.awt.Graphics2D} methods such as
	 * {@@link java.awt.Graphics2D#draw(java.awt.Shape)} and
	 * {@@link java.awt.Graphics2D#fill(java.awt.Shape)}, resulting in a
	 * significant performance increase on the Windows platform, particularly
	 * for rectangle and line drawing calls.
	 *
	 * @@param g
	 *            the graphics context to render to
	 * @@param item
	 *            the item being represented by the shape, this instance is used
	 *            to get the correct color values for the drawing
	 * @@param shape
	 *            the shape to render
	 * @@param stroke
	 *            the stroke type to use for drawing the object.
	 * @@param type
	 *            the rendering type indicating if the shape should be drawn,
	 *            filled, or both.
	 * @@deprecated use the other paint() method instead
	 */
	public static void paint(Graphics2D g, VisualItem<?> item, Shape shape,
d756 21
a776 27
	/**
	 * Render a shape associated with a VisualItem into a graphics context. This
	 * method uses the {@@link java.awt.Graphics} interface methods when it can,
	 * as opposed to the {@@link java.awt.Graphics2D} methods such as
	 * {@@link java.awt.Graphics2D#draw(java.awt.Shape)} and
	 * {@@link java.awt.Graphics2D#fill(java.awt.Shape)}, resulting in a
	 * significant performance increase on the Windows platform, particularly
	 * for rectangle and line drawing calls.
	 *
	 * @@param g
	 *            the graphics context to render to
	 * @@param strokeColor
	 *            the stroke color to use for drawing the object.
	 * @@param fillColor
	 *            the fill color to use for drawing the object.
	 * @@param shape
	 *            the shape to render
	 * @@param stroke
	 *            the stroke type to use for drawing the object.
	 * @@param type
	 *            the rendering type indicating if the shape should be drawn,
	 *            filled, or both.
	 */
	public static void paint(Graphics2D g, Color strokeColor, Color fillColor,
			Shape shape, BasicStroke stroke, RenderType type) {
		// if render type is NONE, then there is nothing to do
		if (type == RenderType.NONE) {
d780 8
a787 6
		// set up colors
		boolean sdraw = (type == RenderType.DRAW || type == RenderType.DRAW_AND_FILL)
				&& strokeColor.getAlpha() != 0;
		boolean fdraw = (type == RenderType.FILL || type == RenderType.DRAW_AND_FILL)
				&& fillColor.getAlpha() != 0;
		if (!(sdraw || fdraw)) {
d791 83
a873 101
		Stroke origStroke = null;
		if (sdraw) {
			origStroke = g.getStroke();
			g.setStroke(stroke);
		}

		int x, y, w, h, aw, ah;
		double xx, yy, ww, hh;

		// see if an optimized (non-shape) rendering call is available for us
		// these can speed things up significantly on the windows JRE
		// it is stupid we have to do this, but we do what we must
		// if we are zoomed in, we have no choice but to use
		// full precision rendering methods.
		AffineTransform at = g.getTransform();
		double scale = Math.max(at.getScaleX(), at.getScaleY());
		if (scale > 1.5) {
			if (fdraw) {
				g.setPaint(fillColor);
				g.fill(shape);
			}
			if (sdraw) {
				g.setPaint(strokeColor);
				g.draw(shape);
			}
		} else if (shape instanceof RectangularShape) {
			RectangularShape r = (RectangularShape) shape;
			xx = r.getX();
			ww = r.getWidth();
			yy = r.getY();
			hh = r.getHeight();

			x = (int) xx;
			y = (int) yy;
			w = (int) (ww + xx - x);
			h = (int) (hh + yy - y);

			if (shape instanceof Rectangle2D) {
				if (fdraw) {
					g.setPaint(fillColor);
					g.fillRect(x, y, w, h);
				}
				if (sdraw) {
					g.setPaint(strokeColor);
					g.drawRect(x, y, w, h);
				}
			} else if (shape instanceof RoundRectangle2D) {
				RoundRectangle2D rr = (RoundRectangle2D) shape;
				aw = (int) rr.getArcWidth();
				ah = (int) rr.getArcHeight();
				if (fdraw) {
					g.setPaint(fillColor);
					g.fillRoundRect(x, y, w, h, aw, ah);
				}
				if (sdraw) {
					g.setPaint(strokeColor);
					g.drawRoundRect(x, y, w, h, aw, ah);
				}
			} else if (shape instanceof Ellipse2D) {
				if (fdraw) {
					g.setPaint(fillColor);
					g.fillOval(x, y, w, h);
				}
				if (sdraw) {
					g.setPaint(strokeColor);
					g.drawOval(x, y, w, h);
				}
			} else {
				if (fdraw) {
					g.setPaint(fillColor);
					g.fill(shape);
				}
				if (sdraw) {
					g.setPaint(strokeColor);
					g.draw(shape);
				}
			}
		} else if (shape instanceof Line2D) {
			if (sdraw) {
				Line2D l = (Line2D) shape;
				x = (int) (l.getX1() + 0.5);
				y = (int) (l.getY1() + 0.5);
				w = (int) (l.getX2() + 0.5);
				h = (int) (l.getY2() + 0.5);
				g.setPaint(strokeColor);
				g.drawLine(x, y, w, h);
			}
		} else {
			if (fdraw) {
				g.setPaint(fillColor);
				g.fill(shape);
			}
			if (sdraw) {
				g.setPaint(strokeColor);
				g.draw(shape);
			}
		}
		if (sdraw) {
			g.setStroke(origStroke);
		}
	}
d879 13
a891 14
	public static void getAlignedPoint(Point2D p, Rectangle2D r,
			Alignment xAlign, Alignment yAlign) {
		double x = r.getX(), y = r.getY(), w = r.getWidth(), h = r.getHeight();
		if (xAlign == Alignment.CENTER) {
			x = x + w / 2;
		} else if (xAlign == Alignment.RIGHT) {
			x = x + w;
		}
		if (yAlign == Alignment.CENTER) {
			y = y + h / 2;
		} else if (yAlign == Alignment.BOTTOM) {
			y = y + h;
		}
		p.setLocation(x, y);
@


2.3.4.8
log
@removed unnecessary deprecation of paint method
@
text
@d22 4
a25 4
 * Library of useful computer graphics routines such as geometry routines for computing the
 * intersection of different shapes and rendering methods for computing bounds and performing
 * optimized drawing.
 * 
d43 1
a43 1
	 * 
d50 13
a62 9
	 * @@return the intersection code. One of {@@link IntersectionType#NO_INTERSECTION},
	 *         {@@link IntersectionType#COINCIDENT}, or {@@link IntersectionType#PARALLEL}.
	 */
	public static IntersectionType intersectLineLine(final Line2D a, final Line2D b, final Point2D intersect) {
		final double a1x = a.getX1(), a1y = a.getY1();
		final double a2x = a.getX2(), a2y = a.getY2();
		final double b1x = b.getX1(), b1y = b.getY1();
		final double b2x = b.getX2(), b2y = b.getY2();
		return intersectLineLine(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y, intersect);
d67 1
a67 1
	 * 
d86 11
a96 8
	 * @@return the intersection code. One of {@@link IntersectionType#NO_INTERSECTION},
	 *         {@@link IntersectionType#COINCIDENT}, or {@@link IntersectionType#PARALLEL}.
	 */
	public static IntersectionType intersectLineLine(final double a1x, final double a1y, final double a2x, final double a2y,
			final double b1x, final double b1y, final double b2x, final double b2y, final Point2D intersect) {
		final double ua_t = (b2x - b1x) * (a1y - b1y) - (b2y - b1y) * (a1x - b1x);
		final double ub_t = (a2x - a1x) * (a1y - b1y) - (a2y - a1y) * (a1x - b1x);
		final double u_b = (b2y - b1y) * (a2x - a1x) - (b2x - b1x) * (a2y - a1y);
d99 2
a100 2
			final double ua = ua_t / u_b;
			final double ub = ub_t / u_b;
d103 2
a104 1
				intersect.setLocation(a1x + ua * (a2x - a1x), a1y + ua * (a2y - a1y));
d110 2
a111 1
			return ua_t == 0 || ub_t == 0 ? IntersectionType.COINCIDENT : IntersectionType.PARALLEL;
d117 1
a117 1
	 * 
d125 13
a137 9
	 *            a length 2 or greater array of points in which to store the results
	 * @@return the intersection code. One of {@@link IntersectionType#NO_INTERSECTION},
	 *         {@@link IntersectionType#COINCIDENT}, or {@@link IntersectionType#PARALLEL}.
	 */
	public static int intersectLineRectangle(final Point2D a1, final Point2D a2, final Rectangle2D r, final Point2D[] pts) {
		final double a1x = a1.getX(), a1y = a1.getY();
		final double a2x = a2.getX(), a2y = a2.getY();
		final double mxx = r.getMaxX(), mxy = r.getMaxY();
		final double mnx = r.getMinX(), mny = r.getMinY();
d170 1
a170 1
	 * 
d176 13
a188 9
	 *            a length 2 or greater array of points in which to store the results
	 * @@return the intersection code. One of {@@link IntersectionType#NO_INTERSECTION},
	 *         {@@link IntersectionType#COINCIDENT}, or {@@link IntersectionType#PARALLEL}.
	 */
	public static int intersectLineRectangle(final Line2D l, final Rectangle2D r, final Point2D[] pts) {
		final double a1x = l.getX1(), a1y = l.getY1();
		final double a2x = l.getX2(), a2y = l.getY2();
		final double mxx = r.getMaxX(), mxy = r.getMaxY();
		final double mnx = r.getMinX(), mny = r.getMinY();
d220 7
a226 6
	 * Computes the 2D convex hull of a set of points using Graham's scanning algorithm. The
	 * algorithm has been implemented as described in Cormen, Leiserson, and Rivest's Introduction
	 * to Algorithms.
	 * 
	 * The running time of this algorithm is O(n log n), where n is the number of input points.
	 * 
d233 1
a233 1
	public static double[] convexHull(final double[] pts, final int len) {
d235 2
a236 1
			throw new IllegalArgumentException("Input must have at least 3 points");
d238 4
a241 4
		final int plen = len / 2 - 1;
		final float[] angles = new float[plen];
		final int[] idx = new int[plen];
		final int[] stack = new int[len / 2];
d246 7
a252 6
	 * Computes the 2D convex hull of a set of points using Graham's scanning algorithm. The
	 * algorithm has been implemented as described in Cormen, Leiserson, and Rivest's Introduction
	 * to Algorithms.
	 * 
	 * The running time of this algorithm is O(n log n), where n is the number of input points.
	 * 
d256 2
a257 1
	public static double[] convexHull(final double[] pts, final int len, final float[] angles, final int[] idx, final int[] stack) {
d259 1
a259 1
		final int plen = len / 2 - 1;
d261 2
a262 1
			throw new IllegalArgumentException("Input must have at least 3 points");
d265 2
a266 1
			throw new IllegalArgumentException("Pre-allocated data structure too small");
d284 2
a285 1
			angles[j] = (float) Math.atan2(pts[i + 1] - pts[i0 + 1], pts[i] - pts[i0]);
d294 1
a294 1
			final int j = idx[i];
d298 6
a303 6
				final double x1 = pts[tj] - pts[i0];
				final double y1 = pts[tj + 1] - pts[i0 + 1];
				final double x2 = pts[j] - pts[i0];
				final double y2 = pts[j + 1] - pts[i0 + 1];
				final double d1 = x1 * x1 + y1 * y1;
				final double d2 = x2 * x2 + y2 * y2;
d342 1
a342 1
		final double[] hull = new double[2 * sp];
d354 2
a355 1
	private static boolean isNonLeft(final int i0, final int i1, final int i2, final int i3, final double[] pts) {
d358 10
a367 5
		l1 = Math.sqrt(Math.pow(pts[i2 + 1] - pts[i1 + 1], 2) + Math.pow(pts[i2] - pts[i1], 2));
		l2 = Math.sqrt(Math.pow(pts[i3 + 1] - pts[i2 + 1], 2) + Math.pow(pts[i3] - pts[i2], 2));
		l4 = Math.sqrt(Math.pow(pts[i3 + 1] - pts[i0 + 1], 2) + Math.pow(pts[i3] - pts[i0], 2));
		l5 = Math.sqrt(Math.pow(pts[i1 + 1] - pts[i0 + 1], 2) + Math.pow(pts[i1] - pts[i0], 2));
		l6 = Math.sqrt(Math.pow(pts[i2 + 1] - pts[i0 + 1], 2) + Math.pow(pts[i2] - pts[i0], 2));
d383 1
a383 1
	 * 
d390 2
a391 2
	public static float[] centroid(final float pts[], final int len) {
		final float[] c = new float[] { 0, 0 };
d402 3
a404 3
	 * Expand a polygon by adding the given distance along the line from the centroid of the
	 * polygon.
	 * 
d410 3
a412 2
	 *            the amount by which to expand the polygon, each point will be moved this distance
	 *            along the line from the centroid of the polygon to the given point.
d414 2
a415 2
	public static void growPolygon(final float pts[], final int len, final float amt) {
		final float[] c = centroid(pts, len);
d417 3
a419 3
			final float vx = pts[i] - c[0];
			final float vy = pts[i + 1] - c[1];
			final float norm = (float) Math.sqrt(vx * vx + vy * vy);
d426 5
a430 4
	 * Compute a cardinal spline, a series of cubic Bezier splines smoothly connecting a set of
	 * points. Cardinal splines maintain C(1) continuity, ensuring the connected spline segments
	 * form a differentiable curve, ensuring at least a minimum level of smoothness.
	 * 
d434 2
a435 2
	 *            a parameter controlling the "tightness" of the spline to the control points, 0.10
	 *            is a typically suitable value
d437 8
a444 6
	 *            true if the cardinal spline should be closed (i.e. return to the starting point),
	 *            false for an open curve
	 * @@return the cardinal spline as a Java2D {@@link java.awt.geom.GeneralPath} instance.
	 */
	public static GeneralPath cardinalSpline(final float pts[], final float slack, final boolean closed) {
		final GeneralPath path = new GeneralPath();
d450 5
a454 4
	 * Compute a cardinal spline, a series of cubic Bezier splines smoothly connecting a set of
	 * points. Cardinal splines maintain C(1) continuity, ensuring the connected spline segments
	 * form a differentiable curve, ensuring at least a minimum level of smoothness.
	 * 
d462 2
a463 2
	 *            a parameter controlling the "tightness" of the spline to the control points, 0.10
	 *            is a typically suitable value
d465 8
a472 7
	 *            true if the cardinal spline should be closed (i.e. return to the starting point),
	 *            false for an open curve
	 * @@return the cardinal spline as a Java2D {@@link java.awt.geom.GeneralPath} instance.
	 */
	public static GeneralPath cardinalSpline(final float pts[], final int start, final int npoints, final float slack,
			final boolean closed) {
		final GeneralPath path = new GeneralPath();
d478 5
a482 4
	 * Compute a cardinal spline, a series of cubic Bezier splines smoothly connecting a set of
	 * points. Cardinal splines maintain C(1) continuity, ensuring the connected spline segments
	 * form a differentiable curve, ensuring at least a minimum level of smoothness.
	 * 
d488 2
a489 2
	 *            a parameter controlling the "tightness" of the spline to the control points, 0.10
	 *            is a typically suitable value
d491 2
a492 2
	 *            true if the cardinal spline should be closed (i.e. return to the starting point),
	 *            false for an open curve
d497 2
a498 1
	 * @@return the cardinal spline as a Java2D {@@link java.awt.geom.GeneralPath} instance.
d500 2
a501 2
	public static GeneralPath cardinalSpline(final GeneralPath p, final float pts[], final float slack, final boolean closed,
			final float tx, final float ty) {
d512 5
a516 4
	 * Compute a cardinal spline, a series of cubic Bezier splines smoothly connecting a set of
	 * points. Cardinal splines maintain C(1) continuity, ensuring the connected spline segments
	 * form a differentiable curve, ensuring at least a minimum level of smoothness.
	 * 
d526 2
a527 2
	 *            a parameter controlling the "tightness" of the spline to the control points, 0.10
	 *            is a typically suitable value
d529 2
a530 2
	 *            true if the cardinal spline should be closed (i.e. return to the starting point),
	 *            false for an open curve
d535 2
a536 1
	 * @@return the cardinal spline as a Java2D {@@link java.awt.geom.GeneralPath} instance.
d538 3
a540 2
	public static GeneralPath cardinalSpline(final GeneralPath p, final float pts[], final int start, final int npoints,
			final float slack, final boolean closed, final float tx, final float ty) {
d542 2
a543 2
		final int len = 2 * npoints;
		final int end = start + len;
d546 2
a547 1
			throw new IllegalArgumentException("To create spline requires at least 3 points");
d568 3
a570 2
			p.curveTo(tx + pts[i - 2] + slack * dx1, ty + pts[i - 1] + slack * dy1, tx + pts[i] - slack * dx2,
					ty + pts[i + 1] - slack * dy2, tx + pts[i], ty + pts[i + 1]);
d579 3
a581 2
			p.curveTo(tx + pts[i - 2] + slack * dx1, ty + pts[i - 1] + slack * dy1, tx + pts[i] - slack * dx2,
					ty + pts[i + 1] - slack * dy2, tx + pts[i], ty + pts[i + 1]);
d587 3
a589 2
			p.curveTo(tx + pts[end - 2] + slack * dx1, ty + pts[end - 1] + slack * dy1, tx + pts[0] - slack * dx2,
					ty + pts[1] - slack * dy2, tx + pts[0], ty + pts[1]);
d592 3
a594 2
			p.curveTo(tx + pts[i - 2] + slack * dx2, ty + pts[i - 1] + slack * dy2, tx + pts[i] - slack * dx2,
					ty + pts[i + 1] - slack * dy2, tx + pts[i], ty + pts[i + 1]);
d600 5
a604 4
	 * Compute a cardinal spline, a series of cubic Bezier splines smoothly connecting a set of
	 * points. Cardinal splines maintain C(1) continuity, ensuring the connected spline segments
	 * form a differentiable curve, ensuring at least a minimum level of smoothness.
	 * 
d614 2
a615 2
	 *            a parameter controlling the "tightness" of the spline to the control points, 0.10
	 *            is a typically suitable value
d617 2
a618 2
	 *            true if the cardinal spline should be closed (i.e. return to the starting point),
	 *            false for an open curve
d623 2
a624 1
	 * @@return the cardinal spline as a Java2D {@@link java.awt.geom.GeneralPath} instance.
d626 2
a627 2
	public static GeneralPath cardinalSpline(final GeneralPath p, final float pts[], final boolean[] invisibleSegments,
			final float slack, final float tx, final float ty) {
d632 2
a633 1
			throw new IllegalArgumentException("To create spline requires at least 3 points");
d635 1
a635 1
		if (pts.length / 2 != invisibleSegments.length + 1) {
d653 4
a656 2
				p.curveTo(tx + pts[i - 2] + slack * dx1, ty + pts[i - 1] + slack * dy1, tx + pts[i] - slack * dx2,
						ty + pts[i + 1] - slack * dy2, tx + pts[i], ty + pts[i + 1]);
d662 3
a664 2
			p.curveTo(tx + pts[i - 2] + slack * dx2, ty + pts[i - 1] + slack * dy2, tx + pts[i] - slack * dx2,
					ty + pts[i + 1] - slack * dy2, tx + pts[i], ty + pts[i + 1]);
d671 3
a673 3
	 * Computes a set of curves using the cardinal spline approach, but using straight lines for
	 * completely horizontal or vertical segments.
	 * 
d679 3
a681 2
	 *            threshold value under which to treat the difference between two values to be zero.
	 *            Used to determine which segments to treat as lines rather than curves.
d683 2
a684 2
	 *            a parameter controlling the "tightness" of the spline to the control points, 0.10
	 *            is a typically suitable value
d686 2
a687 2
	 *            true if the spline should be closed (i.e. return to the starting point), false for
	 *            an open curve
d692 2
a693 1
	 * @@return the stack spline as a Java2D {@@link java.awt.geom.GeneralPath} instance.
d695 2
a696 2
	public static GeneralPath stackSpline(final GeneralPath p, final float[] pts, final float epsilon, final float slack,
			final boolean closed, final float tx, final float ty) {
d703 2
a704 1
		return stackSpline(p, pts, 0, npoints / 2, epsilon, slack, closed, tx, ty);
d708 3
a710 3
	 * Computes a set of curves using the cardinal spline approach, but using straight lines for
	 * completely horizontal or vertical segments.
	 * 
d720 3
a722 2
	 *            threshold value under which to treat the difference between two values to be zero.
	 *            Used to determine which segments to treat as lines rather than curves.
d724 2
a725 2
	 *            a parameter controlling the "tightness" of the spline to the control points, 0.10
	 *            is a typically suitable value
d727 2
a728 2
	 *            true if the spline should be closed (i.e. return to the starting point), false for
	 *            an open curve
d733 2
a734 1
	 * @@return the stack spline as a Java2D {@@link java.awt.geom.GeneralPath} instance.
d736 3
a738 2
	public static GeneralPath stackSpline(final GeneralPath p, final float pts[], final int start, final int npoints,
			final float epsilon, final float slack, final boolean closed, final float tx, final float ty) {
d740 2
a741 2
		final int len = 2 * npoints;
		final int end = start + len;
d744 2
a745 1
			throw new IllegalArgumentException("To create spline requires at least 3 points");
d765 2
a766 1
			if (Math.abs(pts[i] - pts[i - 2]) < epsilon || Math.abs(pts[i + 1] - pts[i - 1]) < epsilon) {
d769 4
a772 2
				p.curveTo(tx + pts[i - 2] + slack * dx1, ty + pts[i - 1] + slack * dy1, tx + pts[i] - slack * dx2,
						ty + pts[i + 1] - slack * dy2, tx + pts[i], ty + pts[i + 1]);
d781 2
a782 1
		if (Math.abs(pts[i] - pts[i - 2]) < epsilon || Math.abs(pts[i + 1] - pts[i - 1]) < epsilon) {
d785 3
a787 2
			p.curveTo(tx + pts[i - 2] + slack * dx1, ty + pts[i - 1] + slack * dy1, tx + pts[i] - slack * dx2,
					ty + pts[i + 1] - slack * dy2, tx + pts[i], ty + pts[i + 1]);
d792 2
a793 1
			if (Math.abs(pts[end - 2] - pts[0]) < epsilon || Math.abs(pts[end - 1] - pts[1]) < epsilon) {
d800 3
a802 2
				p.curveTo(tx + pts[end - 2] + slack * dx1, ty + pts[end - 1] + slack * dy1, tx + pts[0] - slack * dx2,
						ty + pts[1] - slack * dy2, tx + pts[0], ty + pts[1]);
d811 1
a811 1
	 * 
d817 3
a819 2
	public static void expand(final Rectangle2D r, final double amount) {
		r.setRect(r.getX() - amount, r.getY() - amount, r.getWidth() + 2 * amount, r.getHeight() + 2 * amount);
d825 4
a828 4
	 * Sets a VisualItem's bounds based on its shape and stroke type. This method is optimized to
	 * avoid calling .getBounds2D where it can, thus avoiding object initialization and reducing
	 * object churn.
	 * 
d834 7
a840 5
	 *            the stroke type that will be used for drawing the object, and may affect the final
	 *            bounds. A null value indicates the default (line width = 1) stroke is used.
	 */
	public static void setBounds(final VisualItem<?> item, final Shape shape, final BasicStroke stroke) {
		final Rectangle2D bounds = new Rectangle2D.Double();
d842 2
a843 1
		item.setBounds(bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight());
d847 4
a850 3
	 * Calculates bounds based on a shape and stroke type. This method is optimized to avoid calling
	 * .getBounds2D where it can, thus avoiding object initialization and reducing object churn.
	 * 
d854 3
a856 2
	 *            the stroke type that will be used for drawing the object, and may affect the final
	 *            bounds. A null value indicates the default (line width = 1) stroke is used.
d860 2
a861 1
	public static void calculateBounds(final Shape shape, final BasicStroke stroke, final Rectangle2D bounds) {
d866 1
a866 1
			final RectangularShape r = (RectangularShape) shape;
d873 1
a873 1
			final Line2D l = (Line2D) shape;
d895 1
a895 1
			final Rectangle2D r = shape.getBounds2D();
d915 8
a922 6
	 * Render a shape associated with a VisualItem into a graphics context. This method uses the
	 * {@@link java.awt.Graphics} interface methods when it can, as opposed to the
	 * {@@link java.awt.Graphics2D} methods such as {@@link java.awt.Graphics2D#draw(java.awt.Shape)}
	 * and {@@link java.awt.Graphics2D#fill(java.awt.Shape)}, resulting in a significant performance
	 * increase on the Windows platform, particularly for rectangle and line drawing calls.
	 * 
d926 2
a927 2
	 *            the item being represented by the shape, this instance is used to get the correct
	 *            color values for the drawing
d933 8
a940 5
	 *            the rendering type indicating if the shape should be drawn, filled, or both.
	 */
	public static void paint(final Graphics2D g, final VisualItem<?> item, final Shape shape, final BasicStroke stroke,
			final RenderType type) {
		paint(g, ColorLib.getColor(item.getStrokeColor()), ColorLib.getColor(item.getFillColor()), shape, stroke, type);
d944 8
a951 6
	 * Render a shape associated with a VisualItem into a graphics context. This method uses the
	 * {@@link java.awt.Graphics} interface methods when it can, as opposed to the
	 * {@@link java.awt.Graphics2D} methods such as {@@link java.awt.Graphics2D#draw(java.awt.Shape)}
	 * and {@@link java.awt.Graphics2D#fill(java.awt.Shape)}, resulting in a significant performance
	 * increase on the Windows platform, particularly for rectangle and line drawing calls.
	 * 
d963 2
a964 1
	 *            the rendering type indicating if the shape should be drawn, filled, or both.
d966 2
a967 2
	public static void paint(final Graphics2D g, final Color strokeColor, final Color fillColor, final Shape shape,
			final BasicStroke stroke, final RenderType type) {
d974 4
a977 2
		final boolean sdraw = (type == RenderType.DRAW || type == RenderType.DRAW_AND_FILL) && strokeColor.getAlpha() != 0;
		final boolean fdraw = (type == RenderType.FILL || type == RenderType.DRAW_AND_FILL) && fillColor.getAlpha() != 0;
d996 2
a997 2
		final AffineTransform at = g.getTransform();
		final double scale = Math.max(at.getScaleX(), at.getScaleY());
d1008 1
a1008 1
			final RectangularShape r = (RectangularShape) shape;
d1029 1
a1029 1
				final RoundRectangle2D rr = (RoundRectangle2D) shape;
d1061 1
a1061 1
				final Line2D l = (Line2D) shape;
d1085 2
a1086 2
	 * Helper method, which calculates the top-left co-ordinate of a rectangle given the rectangle's
	 * alignment.
d1088 3
a1090 3
	public static void getAlignedPoint(final Point2D p, final Rectangle2D r, final Alignment xAlign, final Alignment yAlign) {
		double x = r.getX(), y = r.getY();
		final double w = r.getWidth(), h = r.getHeight();
@


2.3.4.9
log
@Small bug fix when drawing strokes at extremely small scales.
@
text
@a5 1
import java.awt.Rectangle;
a15 1
import java.util.Arrays;
d898 1
a898 1
		
a991 5
				// there is an issue deep within Java that shows itself if the 
				// scale values are incredibly small. 
				if (at.getScaleX() < 1e-5 || at.getScaleY()< 1e-5) {
					return;
				}
@


2.2
log
@Added stackSpline method in GraphicsLib
Updated PolygonRenderer, including new getter/setter methods
@
text
@d196 1
a196 1
        // find the starting ref point
d209 1
a209 2
            idx[j] = i;
            j += 1;
d215 1
a215 1
        int ti = 0;
d217 1
d219 8
a226 2
                double d1 = Math.sqrt(pts[i]*pts[i]   + pts[i+1]*pts[i+1]);
                double d2 = Math.sqrt(pts[ti]*pts[ti] + pts[ti+1]*pts[ti+1]);
d233 1
d238 1
@


2.1
log
@Added "stroke" visual property for configuring line drawing.
EdgeRenderer now draws directed edges (more) correctly, and allow parameterization of the arrow head size.
@
text
@d331 1
a331 1
     * @@param alpha a parameter controlling the "tightness" of the spline to
d338 1
a338 1
    public static GeneralPath cardinalSpline(float pts[], float alpha, boolean closed) {
d341 1
a341 1
        return cardinalSpline(path, pts, alpha, closed, 0f, 0f);
d352 1
a352 1
     * @@param alpha a parameter controlling the "tightness" of the spline to
d360 1
a360 1
            float alpha, boolean closed)
d364 1
a364 1
        return cardinalSpline(path, pts, start, npoints, alpha, closed, 0f, 0f);
d374 1
a374 1
     * @@param alpha a parameter controlling the "tightness" of the spline to
d384 1
a384 1
            float pts[], float alpha, boolean closed, float tx, float ty)
d389 1
a389 1
        return cardinalSpline(p, pts, 0, npoints/2, alpha, closed, tx, ty);
d401 1
a401 1
     * @@param alpha a parameter controlling the "tightness" of the spline to
d412 1
a412 1
            float alpha, boolean closed, float tx, float ty)
d440 2
a441 2
            p.curveTo(tx+pts[i-2]+alpha*dx1, ty+pts[i-1]+alpha*dy1,
                      tx+pts[i]  -alpha*dx2, ty+pts[i+1]-alpha*dy2,
d450 2
a451 2
            p.curveTo(tx+pts[i-2]+alpha*dx1, ty+pts[i-1]+alpha*dy1,
                      tx+pts[i]  -alpha*dx2, ty+pts[i+1]-alpha*dy2,
d457 2
a458 2
            p.curveTo(tx+pts[end-2]+alpha*dx1, ty+pts[end-1]+alpha*dy1,
                      tx+pts[0]    -alpha*dx2, ty+pts[1]    -alpha*dy2,
d462 2
a463 2
            p.curveTo(tx+pts[i-2]+alpha*dx2, ty+pts[i-1]+alpha*dy2,
                      tx+pts[i]  -alpha*dx2, ty+pts[i+1]-alpha*dy2,
d470 118
@


2.0
log
@Merge beta branch back onto main trunk
@
text
@d7 1
d489 1
a489 1
     * default stroke is used.
d491 2
a492 2
    public static void setBounds(VisualItem item, 
            Shape shape, BasicStroke stroke)
d553 2
a554 1
     * @@param s the shape to render
d562 3
a564 1
    public static void paint(Graphics2D g, VisualItem item, Shape s, int type) {
d580 12
d597 2
a598 3
            if (fdraw) { g.setPaint(fillColor);   g.fill(s); }
            if (sdraw) { g.setPaint(strokeColor); g.draw(s); }
            return;
d600 3
a602 8
        
        // see if an optimized (non-shape) rendering call is available for us
        // these can speed things up significantly on the windows JRE
        // it is stupid we have to do this, but we do what we must
        int x, y, w, h, aw, ah;
        double xx, yy, ww, hh;
        if ( s instanceof RectangularShape ) {
            RectangularShape r = (RectangularShape)s;
d611 1
a611 1
            if ( s instanceof Rectangle2D ) {
d620 2
a621 2
            } else if ( s instanceof RoundRectangle2D ) {
                RoundRectangle2D rr = (RoundRectangle2D)s;
d632 1
a632 1
            } else if ( s instanceof Ellipse2D ) {
d642 2
a643 2
                if (fdraw) { g.setPaint(fillColor);   g.fill(s); }
                if (sdraw) { g.setPaint(strokeColor); g.draw(s); }
d645 1
a645 1
        } else if ( s instanceof Line2D ) {
d647 1
a647 1
                Line2D l = (Line2D)s;
d656 5
a660 2
            if (fdraw) { g.setPaint(fillColor);   g.fill(s); }
            if (sdraw) { g.setPaint(strokeColor); g.draw(s); }
@


1.1
log
@file GraphicsLib.java was initially added on branch beta.
@
text
@d1 651
@


1.1.2.1
log
@Renamed GeometryLib to GraphicsLib. Fixed bounds calculation bug when stroke width was greater than 1.
@
text
@a0 498
package prefuse.util;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Ellipse2D;
import java.awt.geom.GeneralPath;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.RectangularShape;
import java.awt.geom.RoundRectangle2D;

import prefuse.render.ShapeRenderer;
import prefuse.visual.VisualItem;

/**
 * A library of useful geometry routines for computing the intersection
 * of different shapes.
 * 
 * @@version 1.0
 * @@author <a href="http://jheer.org">Jeffrey Heer</a> prefuse(AT)jheer.org
 */
public class GraphicsLib {

	public static final int NO_INTERSECTION = 0;
	public static final int COINCIDENT      = -1;
	public static final int PARALLEL        = -2;

	public static int intersectLineLine(Line2D a, Line2D b, Point2D intersect) {
		double a1x = a.getX1(), a1y = a.getY1();
		double a2x = a.getX2(), a2y = a.getY2();
		double b1x = b.getX1(), b1y = b.getY1();
		double b2x = b.getX2(), b2y = b.getY2();
		return intersectLineLine(a1x,a1y,a2x,a2y,b1x,b1y,b2x,b2y,intersect);
	} //
	
	public static int intersectLineLine(double a1x, double a1y, double a2x,
		double a2y, double b1x, double b1y, double b2x, double b2y, 
		Point2D intersect)
	{
		double ua_t = (b2x-b1x)*(a1y-b1y)-(b2y-b1y)*(a1x-b1x);
		double ub_t = (a2x-a1x)*(a1y-b1y)-(a2y-a1y)*(a1x-b1x);
		double u_b  = (b2y-b1y)*(a2x-a1x)-(b2x-b1x)*(a2y-a1y);

		if ( u_b != 0 ) {
			double ua = ua_t / u_b;
			double ub = ub_t / u_b;

			if ( 0 <= ua && ua <= 1 && 0 <= ub && ub <= 1 ) {
				intersect.setLocation(a1x+ua*(a2x-a1x), a1y+ua*(a2y-a1y));
				return 1;
			} else {
				return NO_INTERSECTION;
			}
		} else {
			return ( ua_t == 0 || ub_t == 0 ? COINCIDENT : PARALLEL );
		}
	} //

	public static int intersectLineRectangle(Point2D a1, Point2D a2, Rectangle2D r, Point2D[] pts) {
		double a1x = a1.getX(), a1y = a1.getY();
		double a2x = a2.getX(), a2y = a2.getY();
		double mxx = r.getMaxX(), mxy = r.getMaxY();
		double mnx = r.getMinX(), mny = r.getMinY();
		
		if ( pts[0] == null ) pts[0] = new Point2D.Double();
		if ( pts[1] == null ) pts[1] = new Point2D.Double();
		
		int i = 0;
		if ( intersectLineLine(mnx,mny,mxx,mny,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
		if ( intersectLineLine(mxx,mny,mxx,mxy,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
		if ( i == 2 ) return i;
		if ( intersectLineLine(mxx,mxy,mnx,mxy,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
		if ( i == 2 ) return i;
		if ( intersectLineLine(mnx,mxy,mnx,mny,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
		return i;
	} //

	public static int intersectLineRectangle(Line2D l, Rectangle2D r, Point2D[] pts) {
		double a1x = l.getX1(), a1y = l.getY1();
		double a2x = l.getX2(), a2y = l.getY2();
		double mxx = r.getMaxX(), mxy = r.getMaxY();
		double mnx = r.getMinX(), mny = r.getMinY();
		
		if ( pts[0] == null ) pts[0] = new Point2D.Double();
		if ( pts[1] == null ) pts[1] = new Point2D.Double();
		
		int i = 0;
		if ( intersectLineLine(mnx,mny,mxx,mny,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
		if ( intersectLineLine(mxx,mny,mxx,mxy,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
		if ( i == 2 ) return i;
		if ( intersectLineLine(mxx,mxy,mnx,mxy,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
		if ( i == 2 ) return i;
		if ( intersectLineLine(mnx,mxy,mnx,mny,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
		return i;
	} //
	
	/**
	 * Computes the 2D convex hull of a set of points using Graham's
	 * scanning algorithm. The algorithm has been implemented as described
	 * in Cormen, Leiserson, and Rivest's Introduction to Algorithms.
	 * 
	 * The running time of this algorithm is O(n log n), where n is
	 * the number of input points.
	 * 
	 * @@param pts the input points in [x0,y0,x1,y1,...] order
	 * @@param len the length of the pts array to consider (2 * #points)
	 * @@return
	 */
	public static double[] convexHull(double[] pts, int len) {
		if (len < 6) {
	        throw new IllegalArgumentException(
	                "Input must have at least 3 points");
	    }
	    int plen = len/2-1;
	    float[] angles = new float[plen];
        int[] idx    = new int[plen];
        int[] stack  = new int[len/2];
        return convexHull(pts, len, angles, idx, stack);
	}
	
	/**
	 * Computes the 2D convex hull of a set of points using Graham's
	 * scanning algorithm. The algorithm has been implemented as described
	 * in Cormen, Leiserson, and Rivest's Introduction to Algorithms.
	 * 
	 * The running time of this algorithm is O(n log n), where n is
	 * the number of input points.
	 * 
	 * @@param pts
	 * @@return
	 */
	public static double[] convexHull(double[] pts, int len, 
	        float[] angles, int[] idx, int[] stack)
	{
	    // check arguments
	    int plen = len/2 - 1;
	    if (len < 6) {
	        throw new IllegalArgumentException(
	                "Input must have at least 3 points");
	    }
	    if (angles.length < plen || idx.length < plen || stack.length < len/2) {
	        throw new IllegalArgumentException(
	                "Pre-allocated data structure too small");
	    }
	    
	    int i0 = 0;
	    // find the starting ref point
	    for ( int i=2; i < len; i += 2 ) {
	        if ( pts[i+1] < pts[i0+1] ) {
	            i0 = i;
	        } else if ( pts[i+1] == pts[i0+1] ) {
	            i0 = (pts[i] < pts[i0] ? i : i0);
	        }
	    }
	    
	    // calculate polar angles from ref point and sort
	    for ( int i=0, j=0; i < len; i+=2 ) {
	        if ( i == i0 ) continue;
	        angles[j] = (float)Math.atan2(pts[i+1]-pts[i0+1], pts[i]-pts[i0]);
	        idx[j] = i;
	        j += 1;
	    }
	    ArrayLib.sort(angles,idx,plen);
	    
	    // toss out duplicated angles
	    float angle = angles[0];
	    int ti = 0;
	    for ( int i=1; i<plen; i++ ) {
	        if ( angle == angles[i] ) {
	            double d1 = Math.sqrt(pts[i]*pts[i]   + pts[i+1]*pts[i+1]);
	            double d2 = Math.sqrt(pts[ti]*pts[ti] + pts[ti+1]*pts[ti+1]);
	            if ( d1 >= d2 ) {
	                idx[i] = -1;
	            } else {
	                idx[ti] = -1;
	                angle = angles[i];
	                ti = i;
	            }
	        } else {
	            angle = angles[i];
	            ti = i;
	        }
	    }
	    
	    // initialize our stack
	    int sp = 0;
	    stack[sp++] = i0;
	    int j = 0;
	    for ( int k=0; k<2; j++ ) {
	        if ( idx[j] != -1 ) {
	            stack[sp++] = idx[j];
	            k++;
	        }
	    }
	    
	    // do graham's scan
	    for ( ; j < plen; j++ ) {
	        if ( idx[j] == -1 ) continue; // skip tossed out points
	        while ( isNonLeft(i0, stack[sp-2], stack[sp-1], idx[j], pts) ) {
	            sp--;
	        }
	        stack[sp++] = idx[j];
	    }

	    // construct the hull
	    double[] hull = new double[2*sp];
	    for ( int i=0; i<sp; i++ ) {
	        hull[2*i]   = pts[stack[i]];
	        hull[2*i+1] = pts[stack[i]+1];
	    }
	    
	    return hull;
	} //

	private static boolean isNonLeft(int i0, int i1, int i2, int i3, double[] pts) {
	    double l1, l2, l4, l5, l6, angle1, angle2, angle;

	    l1 = Math.sqrt(Math.pow(pts[i2+1]-pts[i1+1],2) + Math.pow(pts[i2]-pts[i1],2));
	    l2 = Math.sqrt(Math.pow(pts[i3+1]-pts[i2+1],2) + Math.pow(pts[i3]-pts[i2],2));
	    l4 = Math.sqrt(Math.pow(pts[i3+1]-pts[i0+1],2) + Math.pow(pts[i3]-pts[i0],2));
	    l5 = Math.sqrt(Math.pow(pts[i1+1]-pts[i0+1],2) + Math.pow(pts[i1]-pts[i0],2));
	    l6 = Math.sqrt(Math.pow(pts[i2+1]-pts[i0+1],2) + Math.pow(pts[i2]-pts[i0],2));

	    angle1 = Math.acos( ( (l2*l2)+(l6*l6)-(l4*l4) ) / (2*l2*l6) );
	    angle2 = Math.acos( ( (l6*l6)+(l1*l1)-(l5*l5) ) / (2*l6*l1) );

	    angle = (Math.PI - angle1) - angle2;

	    if (angle <= 0.0) {
	        return(true);
	    } else {
	        return(false);
	    }
	} //
	
	public static float[] centroid(float pts[], int len) {
	    float[] c = new float[] {0, 0};
	    for ( int i=0; i < len; i+=2 ) {
	        c[0] += pts[i];
	        c[1] += pts[i+1];
	    }
	    c[0] /= len/2;
	    c[1] /= len/2;
	    return c;
	} //
	
	public static void growPolygon(float pts[], int len, float amt) {
	    float[] c = centroid(pts, len);
	    for ( int i=0; i < len; i+=2 ) {
	        float vx = pts[i]-c[0];
	        float vy = pts[i+1]-c[1];
	        float norm = (float)Math.sqrt(vx*vx+vy*vy);
	        pts[i] += amt*vx/norm;
	        pts[i+1] += amt*vy/norm;
	    }
	} //
	
	public static GeneralPath cardinalSpline(float pts[], float alpha, boolean closed) {
	    GeneralPath path = new GeneralPath();
        path.moveTo(pts[0], pts[1]);
	    return cardinalSpline(path, pts, alpha, closed, 0f, 0f);
	} //
	
    public static GeneralPath cardinalSpline(float pts[], int start, int npoints,
            float alpha, boolean closed)
    {
        GeneralPath path = new GeneralPath();
        path.moveTo(pts[start], pts[start+1]);
        return cardinalSpline(path, pts, start, npoints, alpha, closed, 0f, 0f);
    } //
    
    public static GeneralPath cardinalSpline(GeneralPath p, 
            float pts[], float alpha, boolean closed, float tx, float ty)
    {
    	int npoints = 0;
    	for ( ; npoints<pts.length; ++npoints )
    		if ( Float.isNaN(pts[npoints]) ) break;
        return cardinalSpline(p, pts, 0, npoints/2, alpha, closed, tx, ty);
    }
    
	public static GeneralPath cardinalSpline(GeneralPath p, 
	        float pts[], int start, int npoints,
            float alpha, boolean closed, float tx, float ty)
	{
	    // compute the size of the path
	    int len = 2*npoints;
        int end = start+len;
	    
	    if ( len < 6 ) {
	        throw new IllegalArgumentException(
	                "To create spline requires at least 3 points");
	    }
	    
	    float dx1, dy1, dx2, dy2;
	    
	    // compute first control point
	    if ( closed ) {
	        dx2 = pts[start+2]-pts[end-2];
	        dy2 = pts[start+3]-pts[end-1];
	    } else {
	        dx2 = pts[start+4]-pts[start];
	        dy2 = pts[start+5]-pts[start+1];
	    }
	    
	    // repeatedly compute next control point and append curve
	    int i;
	    for ( i=start+2; i<end-2; i+=2 ) {
	        dx1 = dx2; dy1 = dy2;
	        dx2 = pts[i+2]-pts[i-2];
	        dy2 = pts[i+3]-pts[i-1];
	        p.curveTo(tx+pts[i-2]+alpha*dx1, ty+pts[i-1]+alpha*dy1,
	                  tx+pts[i]  -alpha*dx2, ty+pts[i+1]-alpha*dy2,
	                  tx+pts[i],             ty+pts[i+1]);
	    }
	    
	    // compute last control point
	    if ( closed ) {
	        dx1 = dx2; dy1 = dy2;
	        dx2 = pts[start]-pts[i-2];
	        dy2 = pts[start+1]-pts[i-1];
	        p.curveTo(tx+pts[i-2]+alpha*dx1, ty+pts[i-1]+alpha*dy1,
	                  tx+pts[i]  -alpha*dx2, ty+pts[i+1]-alpha*dy2,
	                  tx+pts[i],             ty+pts[i+1]);
	        
	        dx1 = dx2; dy1 = dy2;
	        dx2 = pts[start+2]-pts[end-2];
	        dy2 = pts[start+3]-pts[end-1];
	        p.curveTo(tx+pts[end-2]+alpha*dx1, ty+pts[end-1]+alpha*dy1,
	                  tx+pts[0]    -alpha*dx2, ty+pts[1]    -alpha*dy2,
	                  tx+pts[0],               ty+pts[1]);
	        p.closePath();
	    } else {
	        p.curveTo(tx+pts[i-2]+alpha*dx2, ty+pts[i-1]+alpha*dy2,
	                  tx+pts[i]  -alpha*dx2, ty+pts[i+1]-alpha*dy2,
	                  tx+pts[i],             ty+pts[i+1]);
	    }
	    return p;
	}
	
    public static void expand(Rectangle2D r, double amount) {
        r.setRect(r.getX()-amount, r.getY()-amount,
                  r.getWidth()+2*amount, r.getHeight()+2*amount);
    }
    
    // ------------------------------------------------------------------------
    
    /**
     * Sets a VisualItem's bounds based on its shape and stroke type. This
     * method is optimized to avoid calling .getBounds2D where it can, thus
     * avoiding object initialization and reducing object churn.
     */
    public static void setBounds(VisualItem item, 
            Shape shape, BasicStroke stroke)
    {
        double x, y, w, h, lw, lw2;
        
        if ( shape instanceof RectangularShape ) {
            // this covers rectangle, rounded rectangle, ellipse, and arcs
            RectangularShape r = (RectangularShape)shape;
            x = r.getX();
            y = r.getY();
            w = r.getWidth();
            h = r.getHeight();
        } else if ( shape instanceof Line2D ) {
            // this covers straight lines
            Line2D l = (Line2D)shape;
            x = l.getX1();
            y = l.getY1();
            w = l.getX2();
            h = l.getY2();
            if ( w < x ) {
                lw = x;
                x = w;
                w = lw-x;
            } else {
                w = w-x;
            }
            if ( h < y ) {
                lw = y;
                y = h;
                h = lw-y;
            } else {
                h = h-y;
            }
        } else {
            // this covers any other arbitrary shapes, but
            // takes a small object allocation / garbage collection hit
            Rectangle2D r = shape.getBounds2D();
            x = r.getX();
            y = r.getY();
            w = r.getWidth();
            h = r.getHeight();
        }
        
        // adjust boundary for stoke length as necessary
        if ( stroke != null && (lw=stroke.getLineWidth()) > 1 ) {
            lw2 = lw/2.0;
            x -= lw2; y -= lw2; w += lw; h += lw;
        }
        item.setBounds(x, y, w, h);
    }
        
    public static void paint(Graphics2D g, VisualItem item, Shape s, int type) {
        // if render type is NONE, then there is nothing to do
        if ( type == ShapeRenderer.RENDER_TYPE_NONE )
            return;
        
        // set up colors
        Color strokeColor = ColorLib.getColor(item.getStrokeColor());
        Color fillColor = ColorLib.getColor(item.getFillColor());
        boolean sdraw = (type == ShapeRenderer.RENDER_TYPE_DRAW ||
                         type == ShapeRenderer.RENDER_TYPE_DRAW_AND_FILL) &&
                        strokeColor.getAlpha() != 0;
        boolean fdraw = (type == ShapeRenderer.RENDER_TYPE_FILL ||
                         type == ShapeRenderer.RENDER_TYPE_DRAW_AND_FILL) &&
                        fillColor.getAlpha() != 0;
        if ( !(sdraw || fdraw) ) return;
        
        // if we are zoomed in, we have no choice but to use
        // full precision rendering methods.
        AffineTransform at = g.getTransform();
        double scale = Math.max(at.getScaleX(), at.getScaleY());
        if ( scale > 1.5 ) {
            if (fdraw) { g.setPaint(fillColor);   g.fill(s); }
            if (sdraw) { g.setPaint(strokeColor); g.draw(s); }
            return;
        }
        
        // see if an optimized (non-shape) rendering call is available for us
        // these can speed things up significantly on the windows JRE
        // it is stupid we have to do this, but we do what we must
        int x, y, w, h, aw, ah;
        double xx, yy, ww, hh;
        if ( s instanceof RectangularShape ) {
            RectangularShape r = (RectangularShape)s;
            xx = r.getX(); ww = r.getWidth(); 
            yy = r.getY(); hh = r.getHeight();
            
            x = (int)xx;
    		y = (int)yy;
    		w = (int)(ww+xx-x);
    		h = (int)(hh+yy-y);
            
            if ( s instanceof Rectangle2D ) {
                if (fdraw) {
                    g.setPaint(fillColor);
                    g.fillRect(x, y, w, h);
                }
                if (sdraw) {
                    g.setPaint(strokeColor);
                    g.drawRect(x, y, w, h);
                }
            } else if ( s instanceof RoundRectangle2D ) {
                RoundRectangle2D rr = (RoundRectangle2D)s;
                aw = (int)rr.getArcWidth();
                ah = (int)rr.getArcHeight();
                if (fdraw) {
                    g.setPaint(fillColor);
                    g.fillRoundRect(x, y, w, h, aw, ah);
                }
                if (sdraw) {
                    g.setPaint(strokeColor);
                    g.drawRoundRect(x, y, w, h, aw, ah);
                }
            } else if ( s instanceof Ellipse2D ) {
                if (fdraw) {
                    g.setPaint(fillColor);
                    g.fillOval(x, y, w, h);
                }
                if (sdraw) {
                    g.setPaint(strokeColor);
                    g.drawOval(x, y, w, h);
                }
            } else {
                if (fdraw) { g.setPaint(fillColor);   g.fill(s); }
                if (sdraw) { g.setPaint(strokeColor); g.draw(s); }
            }
        } else if ( s instanceof Line2D ) {
            if (sdraw) {
                Line2D l = (Line2D)s;
                x = (int)(l.getX1()+0.5);
                y = (int)(l.getY1()+0.5);
                w = (int)(l.getX2()+0.5);
                h = (int)(l.getY2()+0.5);
                g.setPaint(strokeColor);
                g.drawLine(x, y, w, h);
            }
        } else {
            if (fdraw) { g.setPaint(fillColor);   g.fill(s); }
            if (sdraw) { g.setPaint(strokeColor); g.draw(s); }
        }
    }
    
} // end of class GeometryLib
@


1.1.2.2
log
@Replaced all tab characters with 4 spaces.
Ensured UNIX style line endings.
@
text
@d28 92
a119 92
    public static final int NO_INTERSECTION = 0;
    public static final int COINCIDENT      = -1;
    public static final int PARALLEL        = -2;

    public static int intersectLineLine(Line2D a, Line2D b, Point2D intersect) {
        double a1x = a.getX1(), a1y = a.getY1();
        double a2x = a.getX2(), a2y = a.getY2();
        double b1x = b.getX1(), b1y = b.getY1();
        double b2x = b.getX2(), b2y = b.getY2();
        return intersectLineLine(a1x,a1y,a2x,a2y,b1x,b1y,b2x,b2y,intersect);
    } //
    
    public static int intersectLineLine(double a1x, double a1y, double a2x,
        double a2y, double b1x, double b1y, double b2x, double b2y, 
        Point2D intersect)
    {
        double ua_t = (b2x-b1x)*(a1y-b1y)-(b2y-b1y)*(a1x-b1x);
        double ub_t = (a2x-a1x)*(a1y-b1y)-(a2y-a1y)*(a1x-b1x);
        double u_b  = (b2y-b1y)*(a2x-a1x)-(b2x-b1x)*(a2y-a1y);

        if ( u_b != 0 ) {
            double ua = ua_t / u_b;
            double ub = ub_t / u_b;

            if ( 0 <= ua && ua <= 1 && 0 <= ub && ub <= 1 ) {
                intersect.setLocation(a1x+ua*(a2x-a1x), a1y+ua*(a2y-a1y));
                return 1;
            } else {
                return NO_INTERSECTION;
            }
        } else {
            return ( ua_t == 0 || ub_t == 0 ? COINCIDENT : PARALLEL );
        }
    } //

    public static int intersectLineRectangle(Point2D a1, Point2D a2, Rectangle2D r, Point2D[] pts) {
        double a1x = a1.getX(), a1y = a1.getY();
        double a2x = a2.getX(), a2y = a2.getY();
        double mxx = r.getMaxX(), mxy = r.getMaxY();
        double mnx = r.getMinX(), mny = r.getMinY();
        
        if ( pts[0] == null ) pts[0] = new Point2D.Double();
        if ( pts[1] == null ) pts[1] = new Point2D.Double();
        
        int i = 0;
        if ( intersectLineLine(mnx,mny,mxx,mny,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
        if ( intersectLineLine(mxx,mny,mxx,mxy,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
        if ( i == 2 ) return i;
        if ( intersectLineLine(mxx,mxy,mnx,mxy,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
        if ( i == 2 ) return i;
        if ( intersectLineLine(mnx,mxy,mnx,mny,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
        return i;
    } //

    public static int intersectLineRectangle(Line2D l, Rectangle2D r, Point2D[] pts) {
        double a1x = l.getX1(), a1y = l.getY1();
        double a2x = l.getX2(), a2y = l.getY2();
        double mxx = r.getMaxX(), mxy = r.getMaxY();
        double mnx = r.getMinX(), mny = r.getMinY();
        
        if ( pts[0] == null ) pts[0] = new Point2D.Double();
        if ( pts[1] == null ) pts[1] = new Point2D.Double();
        
        int i = 0;
        if ( intersectLineLine(mnx,mny,mxx,mny,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
        if ( intersectLineLine(mxx,mny,mxx,mxy,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
        if ( i == 2 ) return i;
        if ( intersectLineLine(mxx,mxy,mnx,mxy,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
        if ( i == 2 ) return i;
        if ( intersectLineLine(mnx,mxy,mnx,mny,a1x,a1y,a2x,a2y,pts[i]) > 0 ) i++;
        return i;
    } //
    
    /**
     * Computes the 2D convex hull of a set of points using Graham's
     * scanning algorithm. The algorithm has been implemented as described
     * in Cormen, Leiserson, and Rivest's Introduction to Algorithms.
     * 
     * The running time of this algorithm is O(n log n), where n is
     * the number of input points.
     * 
     * @@param pts the input points in [x0,y0,x1,y1,...] order
     * @@param len the length of the pts array to consider (2 * #points)
     * @@return
     */
    public static double[] convexHull(double[] pts, int len) {
        if (len < 6) {
            throw new IllegalArgumentException(
                    "Input must have at least 3 points");
        }
        int plen = len/2-1;
        float[] angles = new float[plen];
d123 141
a263 141
    }
    
    /**
     * Computes the 2D convex hull of a set of points using Graham's
     * scanning algorithm. The algorithm has been implemented as described
     * in Cormen, Leiserson, and Rivest's Introduction to Algorithms.
     * 
     * The running time of this algorithm is O(n log n), where n is
     * the number of input points.
     * 
     * @@param pts
     * @@return
     */
    public static double[] convexHull(double[] pts, int len, 
            float[] angles, int[] idx, int[] stack)
    {
        // check arguments
        int plen = len/2 - 1;
        if (len < 6) {
            throw new IllegalArgumentException(
                    "Input must have at least 3 points");
        }
        if (angles.length < plen || idx.length < plen || stack.length < len/2) {
            throw new IllegalArgumentException(
                    "Pre-allocated data structure too small");
        }
        
        int i0 = 0;
        // find the starting ref point
        for ( int i=2; i < len; i += 2 ) {
            if ( pts[i+1] < pts[i0+1] ) {
                i0 = i;
            } else if ( pts[i+1] == pts[i0+1] ) {
                i0 = (pts[i] < pts[i0] ? i : i0);
            }
        }
        
        // calculate polar angles from ref point and sort
        for ( int i=0, j=0; i < len; i+=2 ) {
            if ( i == i0 ) continue;
            angles[j] = (float)Math.atan2(pts[i+1]-pts[i0+1], pts[i]-pts[i0]);
            idx[j] = i;
            j += 1;
        }
        ArrayLib.sort(angles,idx,plen);
        
        // toss out duplicated angles
        float angle = angles[0];
        int ti = 0;
        for ( int i=1; i<plen; i++ ) {
            if ( angle == angles[i] ) {
                double d1 = Math.sqrt(pts[i]*pts[i]   + pts[i+1]*pts[i+1]);
                double d2 = Math.sqrt(pts[ti]*pts[ti] + pts[ti+1]*pts[ti+1]);
                if ( d1 >= d2 ) {
                    idx[i] = -1;
                } else {
                    idx[ti] = -1;
                    angle = angles[i];
                    ti = i;
                }
            } else {
                angle = angles[i];
                ti = i;
            }
        }
        
        // initialize our stack
        int sp = 0;
        stack[sp++] = i0;
        int j = 0;
        for ( int k=0; k<2; j++ ) {
            if ( idx[j] != -1 ) {
                stack[sp++] = idx[j];
                k++;
            }
        }
        
        // do graham's scan
        for ( ; j < plen; j++ ) {
            if ( idx[j] == -1 ) continue; // skip tossed out points
            while ( isNonLeft(i0, stack[sp-2], stack[sp-1], idx[j], pts) ) {
                sp--;
            }
            stack[sp++] = idx[j];
        }

        // construct the hull
        double[] hull = new double[2*sp];
        for ( int i=0; i<sp; i++ ) {
            hull[2*i]   = pts[stack[i]];
            hull[2*i+1] = pts[stack[i]+1];
        }
        
        return hull;
    } //

    private static boolean isNonLeft(int i0, int i1, int i2, int i3, double[] pts) {
        double l1, l2, l4, l5, l6, angle1, angle2, angle;

        l1 = Math.sqrt(Math.pow(pts[i2+1]-pts[i1+1],2) + Math.pow(pts[i2]-pts[i1],2));
        l2 = Math.sqrt(Math.pow(pts[i3+1]-pts[i2+1],2) + Math.pow(pts[i3]-pts[i2],2));
        l4 = Math.sqrt(Math.pow(pts[i3+1]-pts[i0+1],2) + Math.pow(pts[i3]-pts[i0],2));
        l5 = Math.sqrt(Math.pow(pts[i1+1]-pts[i0+1],2) + Math.pow(pts[i1]-pts[i0],2));
        l6 = Math.sqrt(Math.pow(pts[i2+1]-pts[i0+1],2) + Math.pow(pts[i2]-pts[i0],2));

        angle1 = Math.acos( ( (l2*l2)+(l6*l6)-(l4*l4) ) / (2*l2*l6) );
        angle2 = Math.acos( ( (l6*l6)+(l1*l1)-(l5*l5) ) / (2*l6*l1) );

        angle = (Math.PI - angle1) - angle2;

        if (angle <= 0.0) {
            return(true);
        } else {
            return(false);
        }
    } //
    
    public static float[] centroid(float pts[], int len) {
        float[] c = new float[] {0, 0};
        for ( int i=0; i < len; i+=2 ) {
            c[0] += pts[i];
            c[1] += pts[i+1];
        }
        c[0] /= len/2;
        c[1] /= len/2;
        return c;
    } //
    
    public static void growPolygon(float pts[], int len, float amt) {
        float[] c = centroid(pts, len);
        for ( int i=0; i < len; i+=2 ) {
            float vx = pts[i]-c[0];
            float vy = pts[i+1]-c[1];
            float norm = (float)Math.sqrt(vx*vx+vy*vy);
            pts[i] += amt*vx/norm;
            pts[i+1] += amt*vy/norm;
        }
    } //
    
    public static GeneralPath cardinalSpline(float pts[], float alpha, boolean closed) {
        GeneralPath path = new GeneralPath();
d265 3
a267 3
        return cardinalSpline(path, pts, alpha, closed, 0f, 0f);
    } //
    
d279 3
a281 3
        int npoints = 0;
        for ( ; npoints<pts.length; ++npoints )
            if ( Float.isNaN(pts[npoints]) ) break;
d285 2
a286 2
    public static GeneralPath cardinalSpline(GeneralPath p, 
            float pts[], int start, int npoints,
d288 3
a290 3
    {
        // compute the size of the path
        int len = 2*npoints;
d292 52
a343 52
        
        if ( len < 6 ) {
            throw new IllegalArgumentException(
                    "To create spline requires at least 3 points");
        }
        
        float dx1, dy1, dx2, dy2;
        
        // compute first control point
        if ( closed ) {
            dx2 = pts[start+2]-pts[end-2];
            dy2 = pts[start+3]-pts[end-1];
        } else {
            dx2 = pts[start+4]-pts[start];
            dy2 = pts[start+5]-pts[start+1];
        }
        
        // repeatedly compute next control point and append curve
        int i;
        for ( i=start+2; i<end-2; i+=2 ) {
            dx1 = dx2; dy1 = dy2;
            dx2 = pts[i+2]-pts[i-2];
            dy2 = pts[i+3]-pts[i-1];
            p.curveTo(tx+pts[i-2]+alpha*dx1, ty+pts[i-1]+alpha*dy1,
                      tx+pts[i]  -alpha*dx2, ty+pts[i+1]-alpha*dy2,
                      tx+pts[i],             ty+pts[i+1]);
        }
        
        // compute last control point
        if ( closed ) {
            dx1 = dx2; dy1 = dy2;
            dx2 = pts[start]-pts[i-2];
            dy2 = pts[start+1]-pts[i-1];
            p.curveTo(tx+pts[i-2]+alpha*dx1, ty+pts[i-1]+alpha*dy1,
                      tx+pts[i]  -alpha*dx2, ty+pts[i+1]-alpha*dy2,
                      tx+pts[i],             ty+pts[i+1]);
            
            dx1 = dx2; dy1 = dy2;
            dx2 = pts[start+2]-pts[end-2];
            dy2 = pts[start+3]-pts[end-1];
            p.curveTo(tx+pts[end-2]+alpha*dx1, ty+pts[end-1]+alpha*dy1,
                      tx+pts[0]    -alpha*dx2, ty+pts[1]    -alpha*dy2,
                      tx+pts[0],               ty+pts[1]);
            p.closePath();
        } else {
            p.curveTo(tx+pts[i-2]+alpha*dx2, ty+pts[i-1]+alpha*dy2,
                      tx+pts[i]  -alpha*dx2, ty+pts[i+1]-alpha*dy2,
                      tx+pts[i],             ty+pts[i+1]);
        }
        return p;
    }
    
d444 3
a446 3
            y = (int)yy;
            w = (int)(ww+xx-x);
            h = (int)(hh+yy-y);
@


1.1.2.3
log
@Much more javadoc
@
text
@d20 2
a21 3
 * Library of useful computer graphics routines such as geometry routines
 * for computing the intersection of different shapes and rendering methods
 * for computing bounds and performing optimized drawing.
d23 2
a24 1
 * @@author <a href="http://jheer.org">jeffrey heer</a>
a27 1
    /** Indicates no intersection between shapes */
a28 1
    /** Indicates intersection between shapes */
a29 1
    /** Indicates two lines are parallel */
d31 1
a31 9
    
    /**
     * Compute the intersection of two line segments.
     * @@param a the first line segment
     * @@param b the second line segment
     * @@param intersect a Point in which to store the intersection point
     * @@return the intersection code. One of {@@link #NO_INTERSECTION},
     * {@@link #COINCIDENT}, or {@@link #PARALLEL}.
     */
d38 1
a38 1
    }
a39 14
    /**
     * Compute the intersection of two line segments.
     * @@param a1x the x-coordinate of the first endpoint of the first line
     * @@param a1y the y-coordinate of the first endpoint of the first line
     * @@param a2x the x-coordinate of the second endpoint of the first line
     * @@param a2y the y-coordinate of the second endpoint of the first line
     * @@param b1x the x-coordinate of the first endpoint of the second line
     * @@param b1y the y-coordinate of the first endpoint of the second line
     * @@param b2x the x-coordinate of the second endpoint of the second line
     * @@param b2y the y-coordinate of the second endpoint of the second line
     * @@param intersect a Point in which to store the intersection point
     * @@return the intersection code. One of {@@link #NO_INTERSECTION},
     * {@@link #COINCIDENT}, or {@@link #PARALLEL}.
     */
d61 1
a61 1
    }
a62 10
    /**
     * Compute the intersection of a line and a rectangle.
     * @@param a1 the first endpoint of the line
     * @@param a2 the second endpoint of the line
     * @@param r the rectangle
     * @@param pts a length 2 or greater array of points in which to store
     * the results 
     * @@return the intersection code. One of {@@link #NO_INTERSECTION},
     * {@@link #COINCIDENT}, or {@@link #PARALLEL}.
     */
d80 1
a80 1
    }
a81 9
    /**
     * Compute the intersection of a line and a rectangle.
     * @@param l the line
     * @@param r the rectangle
     * @@param pts a length 2 or greater array of points in which to store
     * the results 
     * @@return the intersection code. One of {@@link #NO_INTERSECTION},
     * {@@link #COINCIDENT}, or {@@link #PARALLEL}.
     */
d99 1
a99 1
    }
d111 1
a111 1
     * @@return the convex hull of the input points
d134 1
a134 1
     * @@return the convex hull of the input points
d217 1
a217 1
    }
a218 3
    /**
     * Convex hull helper method for detecting a non left turn about 3 points
     */
d238 1
a238 1
    }
a239 6
    /**
     * Computes the mean, or centroid, of a set of points
     * @@param pts the points array, in x1, y1, x2, y2, ... arrangement.
     * @@param len the length of the array to consider
     * @@return the centroid as a length-2 float array
     */
d249 1
a249 1
    }
a250 9
    /**
     * Expand a polygon by adding the given distance along the line from
     * the centroid of the polyong.
     * @@param pts the polygon to expand, a set of points in a float array
     * @@param len the length of the range of the array to consider
     * @@param amt the amount by which to expand the polygon, each point
     * will be moved this distance along the line from the centroid of the
     * polygon to the given point.
     */
d260 1
a260 1
    }
a261 13
    /**
     * Compute a cardinal spline, a series of cubic Bezier splines smoothly
     * connecting a set of points. Cardinal splines maintain C(1)
     * continuity, ensuring the connected spline segments form a differentiable
     * curve, ensuring at least a minimum level of smoothness.
     * @@param pts the points to interpolate with a cardinal spline
     * @@param alpha a parameter controlling the "tightness" of the spline to
     * the control points, 0.10 is a typically suitable value
     * @@param closed true if the cardinal spline should be closed (i.e. return
     * to the starting point), false for an open curve
     * @@return the cardinal spline as a Java2D {@@link java.awt.geom.GeneralPath}
     * instance.
     */
d266 1
a266 1
    }
a267 15
    /**
     * Compute a cardinal spline, a series of cubic Bezier splines smoothly
     * connecting a set of points. Cardinal splines maintain C(1)
     * continuity, ensuring the connected spline segments form a differentiable
     * curve, ensuring at least a minimum level of smoothness.
     * @@param pts the points to interpolate with a cardinal spline
     * @@param the starting index from which to read points
     * @@param npoints the number of points to consider
     * @@param alpha a parameter controlling the "tightness" of the spline to
     * the control points, 0.10 is a typically suitable value
     * @@param closed true if the cardinal spline should be closed (i.e. return
     * to the starting point), false for an open curve
     * @@return the cardinal spline as a Java2D {@@link java.awt.geom.GeneralPath}
     * instance.
     */
d274 1
a274 1
    }
a275 16
    /**
     * Compute a cardinal spline, a series of cubic Bezier splines smoothly
     * connecting a set of points. Cardinal splines maintain C(1)
     * continuity, ensuring the connected spline segments form a differentiable
     * curve, ensuring at least a minimum level of smoothness.
     * @@param p the GeneralPath instance to use to store the result
     * @@param pts the points to interpolate with a cardinal spline
     * @@param alpha a parameter controlling the "tightness" of the spline to
     * the control points, 0.10 is a typically suitable value
     * @@param closed true if the cardinal spline should be closed (i.e. return
     * to the starting point), false for an open curve
     * @@param tx a value by which to translate the curve along the x-dimension
     * @@param ty a value by which to translate the curve along the y-dimension
     * @@return the cardinal spline as a Java2D {@@link java.awt.geom.GeneralPath}
     * instance.
     */
a284 18
    /**
     * Compute a cardinal spline, a series of cubic Bezier splines smoothly
     * connecting a set of points. Cardinal splines maintain C(1)
     * continuity, ensuring the connected spline segments form a differentiable
     * curve, ensuring at least a minimum level of smoothness.
     * @@param p the GeneralPath instance to use to store the result
     * @@param pts the points to interpolate with a cardinal spline
     * @@param the starting index from which to read points
     * @@param npoints the number of points to consider
     * @@param alpha a parameter controlling the "tightness" of the spline to
     * the control points, 0.10 is a typically suitable value
     * @@param closed true if the cardinal spline should be closed (i.e. return
     * to the starting point), false for an open curve
     * @@param tx a value by which to translate the curve along the x-dimension
     * @@param ty a value by which to translate the curve along the y-dimension
     * @@return the cardinal spline as a Java2D {@@link java.awt.geom.GeneralPath}
     * instance.
     */
a343 5
    /**
     * Expand a rectangle by the given amount.
     * @@param r the rectangle to expand
     * @@param amount the amount by which to expand the rectangle
     */
a354 5
     * @@param item the VisualItem whose bounds are to be set
     * @@param shape a Shape from which to determine the item bounds
     * @@Param the stroke type that will be used for drawing the object,
     * and may affect the final bounds. A null value indicates the
     * default stroke is used.
d406 1
a406 20
    
    /**
     * Render a shape associated with a VisualItem into a graphics context. This
     * method uses the {@@link java.awt.Graphics} interface methods when it can,
     * as opposed to the {@@link java.awt.Graphics2D} methods such as
     * {@@link java.awt.Graphics2D#draw(java.awt.Shape)} and
     * {@@link java.awt.Graphics2D#fill(java.awt.Shape)}, resulting in a
     * significant performance increase on the Windows platform, particularly
     * for rectangle and line drawing calls.
     * @@param g the graphics context to render to
     * @@param item the item being represented by the shape, this instance is
     * used to get the correct color values for the drawing
     * @@param s the shape to render
     * @@param type the rendering type indicating if the shape should be drawn,
     * filled, or both. One of
     * {@@link prefuse.render.ShapeRenderer#RENDER_TYPE_DRAW},
     * {@@link prefuse.render.ShapeRenderer#RENDER_TYPE_FILL},
     * {@@link prefuse.render.ShapeRenderer#RENDER_TYPE_DRAW_AND_FILL}, or
     * {@@link prefuse.render.ShapeRenderer#RENDER_TYPE_NONE}.
     */
d498 1
a498 1
} // end of class GraphicsLib
@


1.1.2.4
log
@Javadoc'd.
@
text
@d349 1
a349 1
     * @@param start the starting index from which to read points
d398 1
a398 1
     * @@param start the starting index from which to read points
d486 1
a486 1
     * @@param stroke the stroke type that will be used for drawing the object,
@


1.1.2.5
log
@Various pre-release edits
Added RadialGraphView
Added new applets
Renamed ShapeRenderer to AbstractShapeRenderer
Renamed ShapeItemRenderer to ShapeRenderer
Merged TextItemRenderer and ImageItemRenderer into LabelRenderer
Removed demo launcher (and commented line in build.xml), will reintroduce demo launcher later
@
text
@d16 1
a16 1
import prefuse.render.AbstractShapeRenderer;
d555 4
a558 4
     * {@@link prefuse.render.AbstractShapeRenderer#RENDER_TYPE_DRAW},
     * {@@link prefuse.render.AbstractShapeRenderer#RENDER_TYPE_FILL},
     * {@@link prefuse.render.AbstractShapeRenderer#RENDER_TYPE_DRAW_AND_FILL}, or
     * {@@link prefuse.render.AbstractShapeRenderer#RENDER_TYPE_NONE}.
d562 1
a562 1
        if ( type == AbstractShapeRenderer.RENDER_TYPE_NONE )
d568 2
a569 2
        boolean sdraw = (type == AbstractShapeRenderer.RENDER_TYPE_DRAW ||
                         type == AbstractShapeRenderer.RENDER_TYPE_DRAW_AND_FILL) &&
d571 2
a572 2
        boolean fdraw = (type == AbstractShapeRenderer.RENDER_TYPE_FILL ||
                         type == AbstractShapeRenderer.RENDER_TYPE_DRAW_AND_FILL) &&
@


