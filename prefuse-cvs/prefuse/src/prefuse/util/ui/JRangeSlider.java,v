head	2.1;
access;
symbols
	java_1_5:2.1.0.4
	Root_java_1_5:2.1
	beta:2.1.0.2
	beta-20080113:2.1
	beta-20071021:2.1
	beta-20060220:2.0
	beta-20060209:2.0;
locks; strict;
comment	@# @;


2.1
date	2007.10.21.21.36.05;	author jheer;	state Exp;
branches
	2.1.4.1;
next	2.0;

2.0
date	2006.02.12.18.23.46;	author jheer;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.30.09.13.31;	author jheer;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2005.12.30.09.13.31;	author jheer;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2006.01.16.20.07.41;	author jheer;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2006.01.23.23.07.18;	author jheer;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2006.01.30.09.08.05;	author jheer;	state Exp;
branches;
next	;

2.1.4.1
date	2008.01.23.23.55.36;	author jogiles;	state Exp;
branches;
next	;


desc
@@


2.1
log
@Added root node checks to TreeNodeIterator to avoid iteration errors
Updated IOLib to support relative file paths (Bug #1775875 from anonymous)
Updated JRangeSlider to support drags from arrow buttons (Bug #1747778 from colincombe)
Updated ExpressionParser to avoid long parse bug (Bug #1741759)
Updated TupleManager to expand tuple list in face of valid rows from CascadedTable instances (Bug #1741106)
Added checks for min==max condition in NumberRangeModel (Bug #1731911)
Added patch to Activity and ActivityManager to avoid deadlock on Activity.cancel() (Bug #1708926 fix from joperry)
Fixed javadoc example for DefaultRendererFactory (Bug #1674371 from cab938)
Fixed ENDPOLYGON field in VisualItem (Bug #1554408 from dimerman)
Fixed FisheyeMenu demo to avoid deadlock (Bug #1672798)
Updated Tree.getDepth to return -1 if node is valid (in the node table) but not in tree (fix from joperry)
Added Display.reset method to release used memory from an idle, unused Display instance
Added Graph.removeAllGraphListeners() method
Added Table.removeAllTableListeners() method
Added isAsynchronous / setAsynchronous methods to ImageFactory
Updated Visualization.invalidate to invalidate just the group specified (it incorrectly was invalidating all groups)
Updated ActivityManager._schedule to call notifyAll when an already scheduled item is re-scheduled
@
text
@package prefuse.util.ui;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.util.ArrayList;
import java.util.Iterator;

import javax.swing.BoundedRangeModel;
import javax.swing.DefaultBoundedRangeModel;
import javax.swing.JComponent;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

/**
 * <p>Implements a Swing-based Range slider, which allows the user to enter a 
 * range (minimum and maximum) value.</p>
 * 
 * @@author Ben Bederson
 * @@author Jesse Grosjean
 * @@author Jon Meyer
 * @@author Lance Good
 * @@author jeffrey heer
 * @@author Colin Combe
 */
public class JRangeSlider extends JComponent 
    implements MouseListener, MouseMotionListener, KeyListener
{   
    /*
     * NOTE: This is a modified version of the original class distributed by
     * Ben Bederson, Jesse Grosjean, and Jon Meyer as part of an HCIL Tech
     * Report.  It is modified to allow both vertical and horitonal modes.
     * It also fixes a bug with offset on the buttons. Also fixed a bug with
     * rendering using (x,y) instead of (0,0) as origin.  Also modified to
     * render arrows as a series of lines rather than as a GeneralPath.
     * Also modified to fix rounding errors on toLocal and toScreen.
     * 
     * With inclusion in prefuse, this class has been further modified to use a
     * bounded range model, support keyboard commands and more extensize
     * parameterization of rendering/appearance options. Furthermore, a stub
     * method has been introduced to allow subclasses to perform custom
     * rendering within the slider through.
     */
    
    final public static int VERTICAL = 0;
    final public static int HORIZONTAL = 1;
    final public static int LEFTRIGHT_TOPBOTTOM = 0;
    final public static int RIGHTLEFT_BOTTOMTOP = 1;
    
    final public static int PREFERRED_BREADTH = 16;
    final public static int PREFERRED_LENGTH = 300;
    final protected static int ARROW_SZ = 16;
    final protected static int ARROW_WIDTH = 8;
    final protected static int ARROW_HEIGHT = 4;

    protected BoundedRangeModel model;
    protected int orientation;
    protected int direction;
    protected boolean empty;
    protected int increment = 1;
    protected int minExtent = 0; // min extent, in pixels
    
    protected ArrayList listeners = new ArrayList();
    protected ChangeEvent changeEvent = null;
    protected ChangeListener lstnr;
 
    protected Color thumbColor = new Color(150,180,220);
    
    // ------------------------------------------------------------------------

    /** 
     * Create a new range slider. 
     *
     * @@param minimum - the minimum value of the range.
     * @@param maximum - the maximum value of the range.
     * @@param lowValue - the current low value shown by the range slider's bar.
     * @@param highValue - the current high value shown by the range slider's bar.
     * @@param orientation - construct a horizontal or vertical slider?
     */
    public JRangeSlider(int minimum, int maximum, int lowValue, int highValue, int orientation) {
        this(new DefaultBoundedRangeModel(lowValue, highValue - lowValue, minimum, maximum),
                orientation,LEFTRIGHT_TOPBOTTOM);
    }

    /** 
     * Create a new range slider. 
     *
     * @@param minimum - the minimum value of the range.
     * @@param maximum - the maximum value of the range.
     * @@param lowValue - the current low value shown by the range slider's bar.
     * @@param highValue - the current high value shown by the range slider's bar.
     * @@param orientation - construct a horizontal or vertical slider?
     * @@param direction - Is the slider left-to-right/top-to-bottom or right-to-left/bottom-to-top
     */
    public JRangeSlider(int minimum, int maximum, int lowValue, int highValue, int orientation, int direction) {
        this(new DefaultBoundedRangeModel(lowValue, highValue - lowValue, minimum, maximum), 
                orientation, direction);
    }
    
    /** 
     * Create a new range slider. 
     *
     * @@param model - a BoundedRangeModel specifying the slider's range
     * @@param orientation - construct a horizontal or vertical slider?
     * @@param direction - Is the slider left-to-right/top-to-bottom or right-to-left/bottom-to-top
     */
    public JRangeSlider(BoundedRangeModel model, int orientation, int direction) {
        super.setFocusable(true);
        this.model = model;
        this.orientation = orientation;     
        this.direction = direction;
        
        setForeground(Color.LIGHT_GRAY);
        
        this.lstnr = createListener();
        model.addChangeListener(lstnr);
        
        addMouseListener(this);
        addMouseMotionListener(this);
        addKeyListener(this);
    }
    
    /**
     * Create a listener to relay change events from the bounded range model.
     * @@return a ChangeListener to relay events from the range model
     */
    protected ChangeListener createListener() {
        return new RangeSliderChangeListener();
    }
    
    /**
     * Listener that fires a change event when it receives  change event from
     * the slider list model.
     */
    protected class RangeSliderChangeListener implements ChangeListener {
        public void stateChanged(ChangeEvent e) {
            fireChangeEvent();
        }
    }
    
    /** 
     * Returns the current "low" value shown by the range slider's bar. The low
     * value meets the constraint minimum <= lowValue <= highValue <= maximum. 
     */
    public int getLowValue() {
        return model.getValue();
    }

    /** 
     * Sets the low value shown by this range slider. This causes the range slider to be
     * repainted and a ChangeEvent to be fired.
     * @@param lowValue the low value to use
     */
    public void setLowValue(int lowValue) {
        int e = (model.getValue()-lowValue)+model.getExtent();
        model.setRangeProperties(lowValue, e,
            model.getMinimum(), model.getMaximum(), false);
        model.setValue(lowValue);
    }

    /** 
     * Returns the current "high" value shown by the range slider's bar. The high
     * value meets the constraint minimum <= lowValue <= highValue <= maximum. 
     */
    public int getHighValue() {
        return model.getValue()+model.getExtent();
    }

    /** 
     * Sets the high value shown by this range slider. This causes the range slider to be
     * repainted and a ChangeEvent to be fired.
     * @@param highValue the high value to use
     */
    public void setHighValue(int highValue) {
        model.setExtent(highValue-model.getValue());
    }
    
    /**
     * Set the slider range span.
     * @@param lowValue the low value of the slider range
     * @@param highValue the high value of the slider range
     */
    public void setRange(int lowValue, int highValue) {
        model.setRangeProperties(lowValue, highValue-lowValue,
                model.getMinimum(), model.getMaximum(), false);
    }

    /**
     * Gets the minimum possible value for either the low value or the high value.
     * @@return the minimum possible range value
     */
    public int getMinimum() {
        return model.getMinimum();
    }

    /**
     * Sets the minimum possible value for either the low value or the high value.
     * @@param minimum the minimum possible range value
     */
    public void setMinimum(int minimum) {
        model.setMinimum(minimum);
    }

    /**
     * Gets the maximum possible value for either the low value or the high value.
     * @@return the maximum possible range value
     */
    public int getMaximum() {
        return model.getMaximum();
    }

    /**
     * Sets the maximum possible value for either the low value or the high value.
     * @@param maximum the maximum possible range value
     */
    public void setMaximum(int maximum) {
        model.setMaximum(maximum);
    }

    /**
     * Sets the minimum extent (difference between low and high values).
     * This method <strong>does not</strong> change the current state of the
     * model, but can affect all subsequent interaction.
     * @@param minExtent the minimum extent allowed in subsequent interaction
     */
    public void setMinExtent(int minExtent) {
        this.minExtent = minExtent;
    }
    
    /**
     * Sets whether this slider is empty.
     * @@param empty true if set to empty, false otherwise
     */
    public void setEmpty(boolean empty) {
        this.empty = empty;
        repaint();
    }

    /**
     * Get the slider thumb color. This is the part of the slider between
     * the range resize buttons.
     * @@return the slider thumb color
     */
    public Color getThumbColor() {
        return thumbColor;
    }
    
    /**
     * Set the slider thumb color. This is the part of the slider between
     * the range resize buttons.
     * @@param thumbColor the slider thumb color
     */
    public void setThumbColor(Color thumbColor) {
        this.thumbColor = thumbColor;
    }
    
    /**
     * Get the BoundedRangeModel backing this slider.
     * @@return the slider's range model
     */
    public BoundedRangeModel getModel() {
        return model;
    }
    
    /**
     * Set the BoundedRangeModel backing this slider.
     * @@param brm the slider range model to use
     */
    public void setModel(BoundedRangeModel brm) {
        model.removeChangeListener(lstnr);
        model = brm;
        model.addChangeListener(lstnr);
        repaint();
    }
    
    /** 
     * Registers a listener for ChangeEvents.
     * @@param cl the ChangeListener to add
     */
    public void addChangeListener(ChangeListener cl) {
        if ( !listeners.contains(cl) )
            listeners.add(cl);
    }

    /** 
     * Removes a listener for ChangeEvents.
     * @@param cl the ChangeListener to remove
     */
    public void removeChangeListener(ChangeListener cl) {
        listeners.remove(cl);
    }
    
    /**
     * Fire a change event to all listeners.
     */
    protected void fireChangeEvent() {
        repaint();
        if ( changeEvent == null )
            changeEvent = new ChangeEvent(this);
        Iterator iter = listeners.iterator();
        while ( iter.hasNext() )
            ((ChangeListener)iter.next()).stateChanged(changeEvent);
    }

    /**
     * @@see java.awt.Component#getPreferredSize()
     */
    public Dimension getPreferredSize() {
        if (orientation == VERTICAL) {
            return new Dimension(PREFERRED_BREADTH, PREFERRED_LENGTH);
        }
        else {
            return new Dimension(PREFERRED_LENGTH, PREFERRED_BREADTH);
        }
    }

    // ------------------------------------------------------------------------
    // Rendering

    /**
     * Override this method to perform custom painting of the slider trough.
     * @@param g a Graphics2D context for rendering
     * @@param width the width of the slider trough
     * @@param height the height of the slider trough
     */
    protected void customPaint(Graphics2D g, int width, int height) {
        // does nothing in this class
        // subclasses can override to perform custom painting
    }
    
    /**
     * @@see javax.swing.JComponent#paintComponent(java.awt.Graphics)
     */
    public void paintComponent(Graphics g) {        
        Rectangle bounds = getBounds();
        int width = (int)bounds.getWidth() - 1;
        int height = (int)bounds.getHeight() - 1;

        int min = toScreen(getLowValue());
        int max = toScreen(getHighValue());

        // Paint the full slider if the slider is marked as empty
        if (empty) {
            if (direction == LEFTRIGHT_TOPBOTTOM) {
                min = ARROW_SZ;
                max = (orientation == VERTICAL) ? height-ARROW_SZ : width-ARROW_SZ;
            }
            else {
                min = (orientation == VERTICAL) ? height-ARROW_SZ : width-ARROW_SZ;
                max = ARROW_SZ;                 
            }
        }

        Graphics2D g2 = (Graphics2D)g;
        g2.setColor(getBackground());
        g2.fillRect(0, 0, width, height);
        g2.setColor(getForeground());
        g2.drawRect(0, 0, width, height);

        customPaint(g2, width, height);
        
        // Draw arrow and thumb backgrounds
        g2.setStroke(new BasicStroke(1));
        if (orientation == VERTICAL) {  
            if (direction == LEFTRIGHT_TOPBOTTOM) {
                g2.setColor(getForeground());
                g2.fillRect(0, min - ARROW_SZ, width, ARROW_SZ-1);
                paint3DRectLighting(g2,0,min-ARROW_SZ,width,ARROW_SZ-1);
            
                if ( thumbColor != null ) {
                    g2.setColor(thumbColor);
                    g2.fillRect(0, min, width, max - min-1);
                    paint3DRectLighting(g2,0,min,width,max-min-1);
                }
                
                g2.setColor(getForeground());
                g2.fillRect(0, max, width, ARROW_SZ-1);
                paint3DRectLighting(g2,0,max,width,ARROW_SZ-1);
            
                // Draw arrows          
                g2.setColor(Color.black);
                paintArrow(g2, (width-ARROW_WIDTH) / 2.0, min - ARROW_SZ + (ARROW_SZ-ARROW_HEIGHT) / 2.0, ARROW_WIDTH, ARROW_HEIGHT, true);
                paintArrow(g2, (width-ARROW_WIDTH) / 2.0, max + (ARROW_SZ-ARROW_HEIGHT) / 2.0, ARROW_WIDTH, ARROW_HEIGHT, false);
            }
            else {
                g2.setColor(getForeground());
                g2.fillRect(0, min, width, ARROW_SZ-1);
                paint3DRectLighting(g2,0,min,width,ARROW_SZ-1);
            
                if ( thumbColor != null ) {
                    g2.setColor(thumbColor);
                    g2.fillRect(0, max, width, min-max-1);
                    paint3DRectLighting(g2,0,max,width,min-max-1);
                }
            
                g2.setColor(getForeground());
                g2.fillRect(0, max-ARROW_SZ, width, ARROW_SZ-1);
                paint3DRectLighting(g2,0,max-ARROW_SZ,width,ARROW_SZ-1);
            
                // Draw arrows          
                g2.setColor(Color.black);
                paintArrow(g2, (width-ARROW_WIDTH) / 2.0, min + (ARROW_SZ-ARROW_HEIGHT) / 2.0, ARROW_WIDTH, ARROW_HEIGHT, false);
                paintArrow(g2, (width-ARROW_WIDTH) / 2.0, max - ARROW_SZ + (ARROW_SZ-ARROW_HEIGHT) / 2.0, ARROW_WIDTH, ARROW_HEIGHT, true);             
            }
        }
        else {
            if (direction == LEFTRIGHT_TOPBOTTOM) {
                g2.setColor(getForeground());
                g2.fillRect(min - ARROW_SZ, 0, ARROW_SZ-1, height);
                paint3DRectLighting(g2,min-ARROW_SZ,0,ARROW_SZ-1,height);
            
                if ( thumbColor != null ) {
                    g2.setColor(thumbColor);
                    g2.fillRect(min, 0, max - min - 1, height);
                    paint3DRectLighting(g2,min,0,max-min-1,height);
                }

                g2.setColor(getForeground());
                g2.fillRect(max, 0, ARROW_SZ-1, height);
                paint3DRectLighting(g2,max,0,ARROW_SZ-1,height);
            
                // Draw arrows          
                g2.setColor(Color.black);
                paintArrow(g2, min - ARROW_SZ + (ARROW_SZ-ARROW_HEIGHT) / 2.0, (height-ARROW_WIDTH) / 2.0, ARROW_HEIGHT, ARROW_WIDTH, true);
                paintArrow(g2, max + (ARROW_SZ-ARROW_HEIGHT) / 2.0, (height-ARROW_WIDTH) / 2.0, ARROW_HEIGHT, ARROW_WIDTH, false);
            }
            else {
                g2.setColor(getForeground());
                g2.fillRect(min, 0, ARROW_SZ - 1, height);
                paint3DRectLighting(g2,min,0,ARROW_SZ-1,height);
                
                if ( thumbColor != null ) {
                    g2.setColor(thumbColor);
                    g2.fillRect(max, 0, min - max - 1, height);
                    paint3DRectLighting(g2,max,0,min-max-1,height); 
                }
                
                g2.setColor(getForeground());
                g2.fillRect(max-ARROW_SZ, 0, ARROW_SZ-1, height);
                paint3DRectLighting(g2,max-ARROW_SZ,0,ARROW_SZ-1,height); 
            
                // Draw arrows          
                g2.setColor(Color.black);
                paintArrow(g2, min + (ARROW_SZ-ARROW_HEIGHT) / 2.0, (height-ARROW_WIDTH) / 2.0, ARROW_HEIGHT, ARROW_WIDTH, true);
                paintArrow(g2, max - ARROW_SZ + (ARROW_SZ-ARROW_HEIGHT) / 2.0, (height-ARROW_WIDTH) / 2.0, ARROW_HEIGHT, ARROW_WIDTH, false);                   
            }
        }               
    }

    /**
     * This draws an arrow as a series of lines within the specified box.
     * The last boolean specifies whether the point should be at the 
     * right/bottom or left/top. 
     */
    protected void paintArrow(Graphics2D g2, double x, double y, int w, int h,
                              boolean topDown)
    {
        int intX = (int)(x+0.5);
        int intY = (int)(y+0.5);
        
        if (orientation == VERTICAL) {
            if (w % 2 == 0) {
                w = w - 1;
            }
            
            if (topDown) {
                for(int i=0; i<(w/2+1); i++) {
                    g2.drawLine(intX+i,intY+i,intX+w-i-1,intY+i);
                }
            }
            else {
                for(int i=0; i<(w/2+1); i++) {
                    g2.drawLine(intX+w/2-i,intY+i,intX+w-w/2+i-1,intY+i);
                }               
            }
        }
        else {
            if (h % 2 == 0) {
                h = h - 1;
            }
                        
            if (topDown) {
                for(int i=0; i<(h/2+1); i++) {
                    g2.drawLine(intX+i,intY+i,intX+i,intY+h-i-1);
                }
            }
            else {
                for(int i=0; i<(h/2+1); i++) {
                    g2.drawLine(intX+i,intY+h/2-i,intX+i,intY+h-h/2+i-1);
                }               
            }           
        }
    }
    
    /**
     * Adds Windows2K type 3D lighting effects
     */
    protected void paint3DRectLighting(Graphics2D g2, int x, int y,
                                       int width, int height)
    {
        g2.setColor(Color.white);
        g2.drawLine(x+1,y+1,x+1,y+height-1);
        g2.drawLine(x+1,y+1,x+width-1,y+1);
        g2.setColor(Color.gray);
        g2.drawLine(x+1,y+height-1,x+width-1,y+height-1);
        g2.drawLine(x+width-1,y+1,x+width-1,y+height-1);
        g2.setColor(Color.darkGray);
        g2.drawLine(x,y+height,x+width,y+height);
        g2.drawLine(x+width,y,x+width,y+height);        
    }

    /**
     * Converts from screen coordinates to a range value.
     */
    protected int toLocal(int xOrY) {
        Dimension sz = getSize();
        int min = getMinimum();
        double scale;
        if (orientation == VERTICAL) {
            scale = (sz.height - (2 * ARROW_SZ)) / (double) (getMaximum() - min);           
        }
        else {
            scale = (sz.width - (2 * ARROW_SZ)) / (double) (getMaximum() - min);
        }

        if (direction == LEFTRIGHT_TOPBOTTOM) {
            return (int) (((xOrY - ARROW_SZ) / scale) + min + 0.5);         
        }
        else {
            if (orientation == VERTICAL) {
                return (int) ((sz.height - xOrY - ARROW_SZ) / scale + min + 0.5);
            }
            else {
                return (int) ((sz.width - xOrY - ARROW_SZ) / scale + min + 0.5);
            }
        }
    }

    /**
     * Converts from a range value to screen coordinates.
     */
    protected int toScreen(int xOrY) {
        Dimension sz = getSize();
        int min = getMinimum();
        double scale;
        if (orientation == VERTICAL) {
            scale = (sz.height - (2 * ARROW_SZ)) / (double) (getMaximum() - min);           
        }
        else {
            scale = (sz.width - (2 * ARROW_SZ)) / (double) (getMaximum() - min);
        }

        // If the direction is left/right_top/bottom then we subtract the min and multiply times scale
        // Otherwise, we have to invert the number by subtracting the value from the height
        if (direction == LEFTRIGHT_TOPBOTTOM) {
            return (int)(ARROW_SZ + ((xOrY - min) * scale) + 0.5);
        }
        else {
            if (orientation == VERTICAL) {
                return (int)(sz.height-(xOrY - min) * scale - ARROW_SZ + 0.5);
            }
            else {
                return (int)(sz.width-(xOrY - min) * scale - ARROW_SZ + 0.5);
            }
        }
    }

    /**
     * Converts from a range value to screen coordinates.
     */
    protected double toScreenDouble(int xOrY) {
        Dimension sz = getSize();
        int min = getMinimum();
        double scale;
        if (orientation == VERTICAL) {
            scale = (sz.height - (2 * ARROW_SZ)) / (double) (getMaximum()+1 - min);         
        }
        else {
            scale = (sz.width - (2 * ARROW_SZ)) / (double) (getMaximum()+1 - min);
        }

        // If the direction is left/right_top/bottom then we subtract the min and multiply times scale
        // Otherwise, we have to invert the number by subtracting the value from the height
        if (direction == LEFTRIGHT_TOPBOTTOM) {
            return ARROW_SZ + ((xOrY - min) * scale);
        }
        else {
            if (orientation == VERTICAL) {
                return sz.height-(xOrY - min) * scale - ARROW_SZ;
            }
            else {
                return sz.width-(xOrY - min) * scale - ARROW_SZ;
            }
        }
    }

    
    // ------------------------------------------------------------------------
    // Event Handling

    static final int PICK_NONE = 0;
    static final int PICK_LEFT_OR_TOP = 1;
    static final int PICK_THUMB = 2;
    static final int PICK_RIGHT_OR_BOTTOM = 3;
    int pick;
    int pickOffsetLow;
    int pickOffsetHigh;
    int mouse;

    private int pickHandle(int xOrY) {
        int min = toScreen(getLowValue());
        int max = toScreen(getHighValue());
        int pick = PICK_NONE;
        
        if (direction == LEFTRIGHT_TOPBOTTOM) {
            if ((xOrY > (min - ARROW_SZ)) && (xOrY < min)) {
                pick = PICK_LEFT_OR_TOP;
            } else if ((xOrY >= min) && (xOrY <= max)) {
                pick = PICK_THUMB;
            } else if ((xOrY > max) && (xOrY < (max + ARROW_SZ))) {
                pick = PICK_RIGHT_OR_BOTTOM;
            }
        }
        else {
            if ((xOrY > min) && (xOrY < (min + ARROW_SZ))) {
                pick = PICK_LEFT_OR_TOP;
            } else if ((xOrY <= min) && (xOrY >= max)) {
                pick = PICK_THUMB;
            } else if ((xOrY > (max - ARROW_SZ) && (xOrY < max))) {
                pick = PICK_RIGHT_OR_BOTTOM;
            }           
        }
        
        return pick;
    }

    private void offset(int dxOrDy) {
        model.setValue(model.getValue()+dxOrDy);
    }

    /**
     * @@see java.awt.event.MouseListener#mousePressed(java.awt.event.MouseEvent)
     */
    public void mousePressed(MouseEvent e) {        
        if (orientation == VERTICAL) {
            pick = pickHandle(e.getY());
            pickOffsetLow = e.getY() - toScreen(getLowValue());
            pickOffsetHigh = e.getY() - toScreen(getHighValue());
            mouse = e.getY();
        }
        else {
            pick = pickHandle(e.getX());
            pickOffsetLow = e.getX() - toScreen(getLowValue());
            pickOffsetHigh = e.getX() - toScreen(getHighValue());
            mouse = e.getX();           
        }
        repaint();
    }

    /**
     * @@see java.awt.event.MouseMotionListener#mouseDragged(java.awt.event.MouseEvent)
     */
    public void mouseDragged(MouseEvent e) {
        requestFocus();
        int value = (orientation == VERTICAL) ? e.getY() : e.getX();
        
        int minimum = getMinimum();
        int maximum = getMaximum();
        int lowValue = getLowValue();
        int highValue = getHighValue();
        
        switch (pick) {
            case PICK_LEFT_OR_TOP:
                int low = toLocal(value-pickOffsetLow);
            
                if (low < minimum) {
                    low = minimum;
                }
                if (low > maximum - minExtent) {
                    low = maximum - minExtent;
                }
                if (low > highValue-minExtent) {
                    setRange(low, low + minExtent);
                }
                else
                    setLowValue(low);
                break;

            case PICK_RIGHT_OR_BOTTOM:
                int high = toLocal(value-pickOffsetHigh);
                
                if (high < minimum + minExtent) {
                    high = minimum + minExtent;
                }
                if (high > maximum) {
                    high = maximum;
                }
                if (high < lowValue+minExtent) {
                    setRange(high - minExtent, high);
                }
                else
                    setHighValue(high);
                break;

            case PICK_THUMB:
                int dxOrDy = toLocal(value - pickOffsetLow) - lowValue;
                if ((dxOrDy < 0) && ((lowValue + dxOrDy) < minimum)) {
                    dxOrDy = minimum - lowValue;
                }
                if ((dxOrDy > 0) && ((highValue + dxOrDy) > maximum)) {
                    dxOrDy = maximum - highValue;
                }
                if (dxOrDy != 0) {
                    offset(dxOrDy);
                }
                break;
        }
    }

    /**
     * @@see java.awt.event.MouseListener#mouseReleased(java.awt.event.MouseEvent)
     */
    public void mouseReleased(MouseEvent e) {
        pick = PICK_NONE;
        repaint();
    }

    /**
     * @@see java.awt.event.MouseMotionListener#mouseMoved(java.awt.event.MouseEvent)
     */
    public void mouseMoved(MouseEvent e) {
        if (orientation == VERTICAL) {
            switch (pickHandle(e.getY())) {
                case PICK_LEFT_OR_TOP:
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                    break;
                case PICK_RIGHT_OR_BOTTOM:
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                    break;
                case PICK_THUMB:
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                    break;
                case PICK_NONE :
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                    break;
            }
        }
        else {
            switch (pickHandle(e.getX())) {
                case PICK_LEFT_OR_TOP:
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                    break;
                case PICK_RIGHT_OR_BOTTOM:
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                    break;
                case PICK_THUMB:
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                    break;
                case PICK_NONE :
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                    break;
            }           
        }
    }

    /**
     * @@see java.awt.event.MouseListener#mouseClicked(java.awt.event.MouseEvent)
     */
    public void mouseClicked(MouseEvent e) {
    }
    /**
     * @@see java.awt.event.MouseListener#mouseEntered(java.awt.event.MouseEvent)
     */
    public void mouseEntered(MouseEvent e) {
    }
    /**
     * @@see java.awt.event.MouseListener#mouseExited(java.awt.event.MouseEvent)
     */
    public void mouseExited(MouseEvent e) {
    }

    private void grow(int increment) {
        model.setRangeProperties(model.getValue()-increment,
            model.getExtent()+2*increment, 
            model.getMinimum(), model.getMaximum(), false);
    }
    
    /**
     * @@see java.awt.event.KeyListener#keyPressed(java.awt.event.KeyEvent)
     */
    public void keyPressed(KeyEvent e) {
        int kc = e.getKeyCode();
        boolean v = (orientation == VERTICAL);
        boolean d = (kc == KeyEvent.VK_DOWN);
        boolean u = (kc == KeyEvent.VK_UP);
        boolean l = (kc == KeyEvent.VK_LEFT);
        boolean r = (kc == KeyEvent.VK_RIGHT);
        
        int minimum = getMinimum();
        int maximum = getMaximum();
        int lowValue = getLowValue();
        int highValue = getHighValue();
        
        if ( v&&r || !v&&u ) {
            if ( lowValue-increment >= minimum &&
                 highValue+increment <= maximum ) {
                grow(increment);
            }
        } else if ( v&&l || !v&&d ) { 
            if ( highValue-lowValue >= 2*increment ) {
                grow(-1*increment);
            }
        } else if ( v&&d || !v&&l ) {
            if ( lowValue-increment >= minimum ) {
                offset(-increment);
            }
        } else if ( v&&u || !v&&r ) {
            if ( highValue+increment <= maximum ) {
                offset(increment);
            }
        }
    }
    
    /**
     * @@see java.awt.event.KeyListener#keyReleased(java.awt.event.KeyEvent)
     */
    public void keyReleased(KeyEvent e) {
    }
    /**
     * @@see java.awt.event.KeyListener#keyTyped(java.awt.event.KeyEvent)
     */
    public void keyTyped(KeyEvent e) {
    }
    
} // end of class JRangeSlider
@


2.1.4.1
log
@First import of a Java 1.5-targetted version of prefuse.
@
text
@d16 1
a16 1
import java.util.List;
d25 1
a25 1
 * <p>Implements a Swing-based Range slider, which allows the user to enter a
d27 1
a27 1
 *
d35 1
a35 1
public class JRangeSlider extends JComponent
d37 1
a37 1
{
d41 1
a41 1
     * Report.  It is modified to allow both vertical and horizontal modes.
d46 1
a46 1
     *
d48 1
a48 1
     * bounded range model, support keyboard commands and more extensive
d53 6
a58 11

	public static enum Orientation {
		VERTICAL,
		HORIZONTAL
	}

	public static enum Direction {
		LEFTRIGHT_TOPBOTTOM,
		RIGHTLEFT_BOTTOMTOP
	}

d66 2
a67 2
    protected Orientation orientation;
    protected Direction direction;
d71 2
a72 2

    protected List<ChangeListener> listeners = new ArrayList<ChangeListener>();
d75 1
a75 1

d77 1
a77 1

d80 2
a81 2
    /**
     * Create a new range slider.
d89 1
a89 1
    public JRangeSlider(int minimum, int maximum, int lowValue, int highValue, Orientation orientation) {
d91 1
a91 1
                orientation, Direction.LEFTRIGHT_TOPBOTTOM);
d94 2
a95 2
    /**
     * Create a new range slider.
d104 2
a105 2
    public JRangeSlider(int minimum, int maximum, int lowValue, int highValue, Orientation orientation, Direction direction) {
        this(new DefaultBoundedRangeModel(lowValue, highValue - lowValue, minimum, maximum),
d108 3
a110 3

    /**
     * Create a new range slider.
d116 1
a116 1
    public JRangeSlider(BoundedRangeModel model, Orientation orientation, Direction direction) {
d119 1
a119 1
        this.orientation = orientation;
d121 1
a121 1

d123 1
a123 1

d126 1
a126 1

d131 1
a131 1

d139 1
a139 1

d149 2
a150 2

    /**
d152 1
a152 1
     * value meets the constraint minimum <= lowValue <= highValue <= maximum.
d158 1
a158 1
    /**
d170 1
a170 1
    /**
d172 1
a172 1
     * value meets the constraint minimum <= lowValue <= highValue <= maximum.
d178 1
a178 1
    /**
d186 1
a186 1

d238 1
a238 1

d256 1
a256 1

d265 1
a265 1

d273 1
a273 1

d284 2
a285 2

    /**
d294 1
a294 1
    /**
d301 1
a301 1

d309 3
a311 3
        for(ChangeListener listener : listeners) {
        	listener.stateChanged(changeEvent);
        }
d318 1
a318 1
        if (orientation == Orientation.VERTICAL) {
d339 1
a339 1

d343 1
a343 1
    public void paintComponent(Graphics g) {
d353 1
a353 1
            if (direction == Direction.LEFTRIGHT_TOPBOTTOM) {
d355 1
a355 1
                max = (orientation == Orientation.VERTICAL) ? height-ARROW_SZ : width-ARROW_SZ;
d358 2
a359 2
                min = (orientation == Orientation.VERTICAL) ? height-ARROW_SZ : width-ARROW_SZ;
                max = ARROW_SZ;
d370 1
a370 1

d373 2
a374 2
        if (orientation == Orientation.VERTICAL) {
            if (direction == Direction.LEFTRIGHT_TOPBOTTOM) {
d378 1
a378 1

d384 1
a384 1

d388 2
a389 2

                // Draw arrows
d398 1
a398 1

d404 1
a404 1

d408 2
a409 2

                // Draw arrows
d412 1
a412 1
                paintArrow(g2, (width-ARROW_WIDTH) / 2.0, max - ARROW_SZ + (ARROW_SZ-ARROW_HEIGHT) / 2.0, ARROW_WIDTH, ARROW_HEIGHT, true);
d416 1
a416 1
            if (direction == Direction.LEFTRIGHT_TOPBOTTOM) {
d420 1
a420 1

d430 2
a431 2

                // Draw arrows
d440 1
a440 1

d444 1
a444 1
                    paint3DRectLighting(g2,max,0,min-max-1,height);
d446 1
a446 1

d449 3
a451 3
                paint3DRectLighting(g2,max-ARROW_SZ,0,ARROW_SZ-1,height);

                // Draw arrows
d454 1
a454 1
                paintArrow(g2, max - ARROW_SZ + (ARROW_SZ-ARROW_HEIGHT) / 2.0, (height-ARROW_WIDTH) / 2.0, ARROW_HEIGHT, ARROW_WIDTH, false);
d456 1
a456 1
        }
d461 2
a462 2
     * The last boolean specifies whether the point should be at the
     * right/bottom or left/top.
d469 2
a470 2

        if (orientation == Orientation.VERTICAL) {
d474 1
a474 1

d483 1
a483 1
                }
d490 1
a490 1

d499 2
a500 2
                }
            }
d503 1
a503 1

d518 1
a518 1
        g2.drawLine(x+width,y,x+width,y+height);
d528 2
a529 2
        if (orientation == Orientation.VERTICAL) {
            scale = (sz.height - (2 * ARROW_SZ)) / (double) (getMaximum() - min);
d535 2
a536 2
        if (direction == Direction.LEFTRIGHT_TOPBOTTOM) {
            return (int) (((xOrY - ARROW_SZ) / scale) + min + 0.5);
d539 1
a539 1
            if (orientation == Orientation.VERTICAL) {
d555 2
a556 2
        if (orientation == Orientation.VERTICAL) {
            scale = (sz.height - (2 * ARROW_SZ)) / (double) (getMaximum() - min);
d564 1
a564 1
        if (direction == Direction.LEFTRIGHT_TOPBOTTOM) {
d568 1
a568 1
            if (orientation == Orientation.VERTICAL) {
d584 2
a585 2
        if (orientation == Orientation.VERTICAL) {
            scale = (sz.height - (2 * ARROW_SZ)) / (double) (getMaximum()+1 - min);
d593 1
a593 1
        if (direction == Direction.LEFTRIGHT_TOPBOTTOM) {
d597 1
a597 1
            if (orientation == Orientation.VERTICAL) {
d606 1
a606 1

d623 2
a624 2

        if (direction == Direction.LEFTRIGHT_TOPBOTTOM) {
d640 1
a640 1
            }
d642 1
a642 1

d653 2
a654 2
    public void mousePressed(MouseEvent e) {
        if (orientation == Orientation.VERTICAL) {
d664 1
a664 1
            mouse = e.getX();
d674 2
a675 2
        int value = (orientation == Orientation.VERTICAL) ? e.getY() : e.getX();

d680 1
a680 1

d684 1
a684 1

d700 1
a700 1

d741 1
a741 1
        if (orientation == Orientation.VERTICAL) {
d771 1
a771 1
            }
d793 1
a793 1
            model.getExtent()+2*increment,
d796 1
a796 1

d802 1
a802 1
        boolean v = (orientation == Orientation.VERTICAL);
d807 1
a807 1

d812 1
a812 1

d818 1
a818 1
        } else if ( v&&l || !v&&d ) {
d832 1
a832 1

d843 1
a843 1

@


2.0
log
@Merge beta branch back onto main trunk
@
text
@d33 1
d90 1
a90 1
        this(new DefaultBoundedRangeModel(lowValue,highValue,minimum,maximum),
d105 1
a105 1
        this(new DefaultBoundedRangeModel(lowValue, highValue, minimum, maximum), 
d688 2
a689 2
                if (low > maximum) {
                    low = maximum;
d692 1
a692 1
                    low = highValue-minExtent;
d694 2
a695 1
                setLowValue(low);
d701 2
a702 2
                if (high < minimum) {
                    high = minimum;
d708 1
a708 1
                    high = lowValue+minExtent;
d710 2
a711 1
                setHighValue(high);
@


1.1
log
@file JRangeSlider.java was initially added on branch beta.
@
text
@d1 841
@


1.1.2.1
log
@Initial commit of prefuse beta
@
text
@a0 800
package prefuse.util.ui;

import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Panel;
import java.awt.Rectangle;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.util.ArrayList;
import java.util.Iterator;

import javax.swing.BoundedRangeModel;
import javax.swing.BoxLayout;
import javax.swing.DefaultBoundedRangeModel;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

/**
 * Implements a Swing-based Range slider, which allows the user to enter a 
 * range (minimum and maximum) value.
 * 
 * This version is implemented with an entirely "custom" implementation,
 * meaning that it has a simple data structure (the "model"), a paint
 * method which generates the visual display of the widget based on the 
 * model (the "view"), and event handlers which responds to user interaction
 * (the "controller").
 * 
 * NOTE: This is a modified version of the original class distributed by Ben Bederson, 
 * Jesse Grosjean, and Jon Meyer as part of an HCIL Tech Report.  It is modified to allow 
 * both vertical and horitonal modes.  It also fixes a bug with offset on the buttons.   
 * Also fixed a bug with rendering using (x,y) instead of (0,0) as origin.  Also modified to
 * render arrows as a series of lines rather than as a GeneralPath.  Also modified to fix
 * rounding errors on toLocal and toScreen.
 * 
 * Developed at the Human-Computer Interaction Laboratory of the University of Maryland.
 */
public class JRangeSlider extends JComponent 
	implements MouseListener, MouseMotionListener, KeyListener
{	
	final public static int VERTICAL = 0;
	final public static int HORIZONTAL = 1;
	final public static int LEFTRIGHT_TOPBOTTOM = 0;
	final public static int RIGHTLEFT_BOTTOMTOP = 1;
	
	final public static int PREFERRED_BREADTH = 16;
	final public static int PREFERRED_LENGTH = 300;
	final protected static int ARROW_SZ = 16;
	final protected static int ARROW_WIDTH = 8;
	final protected static int ARROW_HEIGHT = 4;

    protected BoundedRangeModel model;
    protected int orientation;
	protected int direction;
	protected boolean empty;
	protected int increment = 1;
    
	protected ArrayList listeners = new ArrayList();
    protected ChangeEvent changeEvent = null;
    protected ChangeListener lstnr;
 
	protected Color thumbColor = new Color(150,180,220);
	

	//////////////////////////////////
	// PUBLIC API
	//////////////////////////////////

	/** 
	 * Constructs a new range slider. 
	 *
	 * @@param minimum - the minimum value of the range.
	 * @@param maximum - the maximum value of the range.
	 * @@param lowValue - the current low value shown by the range slider's bar.
	 * @@param highValue - the current high value shown by the range slider's bar.
	 * @@param orientation - construct a horizontal or vertical slider?
	 */
	public JRangeSlider(int minimum, int maximum, int lowValue, int highValue, int orientation) {
		this(new DefaultBoundedRangeModel(lowValue,highValue,minimum,maximum),
                orientation,LEFTRIGHT_TOPBOTTOM);
	}

	/** 
	 * Constructs a new range slider. 
	 *
	 * @@param minimum - the minimum value of the range.
	 * @@param maximum - the maximum value of the range.
	 * @@param lowValue - the current low value shown by the range slider's bar.
	 * @@param highValue - the current high value shown by the range slider's bar.
	 * @@param orientation - construct a horizontal or vertical slider?
	 * @@param direction - Is the slider left-to-right/top-to-bottom or right-to-left/bottom-to-top
	 */
	public JRangeSlider(int minimum, int maximum, int lowValue, int highValue, int orientation, int direction) {
		this(new DefaultBoundedRangeModel(lowValue, highValue, minimum, maximum), 
                orientation, direction);
	}
    
    public JRangeSlider(BoundedRangeModel model, int orientation, int direction) {
        super.setFocusable(true);
        this.model = model;
        this.orientation = orientation;     
        this.direction = direction;
        
        setForeground(Color.LIGHT_GRAY);
        
        this.lstnr = createListener();
        model.addChangeListener(lstnr);
        
        addMouseListener(this);
        addMouseMotionListener(this);
        addKeyListener(this);
    }
    
    protected ChangeListener createListener() {
        return new RangeSliderChangeListener();
    }
    
    protected class RangeSliderChangeListener implements ChangeListener {
        public void stateChanged(ChangeEvent e) {
            fireChangeEvent();
        }
    }
    
	/** 
	 * Returns the current "low" value shown by the range slider's bar. The low
	 * value meets the constraint minimum <= lowValue <= highValue <= maximum. 
	 */
	public int getLowValue() {
		return model.getValue();
	}

	/** 
	 * Sets the low value shown by this range slider. This causes the range slider to be
	 * repainted and a RangeEvent to be fired.
	 */
	public void setLowValue(int lowValue) {
        int e = (model.getValue()-lowValue)+model.getExtent();
        model.setRangeProperties(lowValue, e,
            model.getMinimum(), model.getMaximum(), false);
        model.setValue(lowValue);
	}

	/** 
	 * Returns the current "high" value shown by the range slider's bar. The high
	 * value meets the constraint minimum <= lowValue <= highValue <= maximum. 
	 */
	public int getHighValue() {
		return model.getValue()+model.getExtent();
	}

	/** 
	 * Sets the high value shown by this range slider. This causes the range slider to be
	 * repainted and a RangeEvent to be fired.
	 */
	public void setHighValue(int highValue) {
        model.setExtent(highValue-model.getValue());
	}
	
	public void setRange(int lowValue, int highValue) {
        model.setRangeProperties(lowValue, highValue-lowValue,
                model.getMinimum(), model.getMaximum(), false);
	}

	/**
	 * Returns the minimum possible value for either the low value or the high value.
	 */
	public int getMinimum() {
		return model.getMinimum();
	}

	/**
	 * Sets the minimum.
	 * @@param minimum The minimum to set
	 */
	public void setMinimum(int minimum) {
        model.setMinimum(minimum);
	}

	/**
	 * Returns the maximum possible value for either the low value or the high value.
	 */
	public int getMaximum() {
		return model.getMaximum();
	}

	/**
	 * Sets the maximum.
	 * @@param maximum The maximum to set
	 */
	public void setMaximum(int maximum) {
        model.setMaximum(maximum);
	}

	/**
	 * Set whether this slider is empty
	 * @@param r
	 */
	public void setEmpty(boolean empty) {
		this.empty = empty;
		repaint();
	}

    /**
     * @@return Returns the slider thumb color.
     */
    public Color getThumbColor() {
        return thumbColor;
    }
    
    /**
     * @@param thumbColor The slider thumb color to set.
     */
    public void setThumbColor(Color thumbColor) {
        this.thumbColor = thumbColor;
    }
	
    /**
     * Returns the BoundedRangeModel backing this slider
     * @@return the slider's model
     */
    public BoundedRangeModel getModel() {
        return model;
    }
    
    public void setModel(BoundedRangeModel brm) {
        model.removeChangeListener(lstnr);
        model = brm;
        model.addChangeListener(lstnr);
        repaint();
    }
    
	/** 
	 * Registers a listener for ChangeEvents.
	 */
	public void addChangeListener(ChangeListener cl) {
		if ( !listeners.contains(cl) )
            listeners.add(cl);
	}

	/** 
	 * Removes a listener for ChangeEvents.
	 */
	public void removeChangeListener(ChangeListener cl) {
		listeners.remove(cl);
	}
    
    protected void fireChangeEvent() {
        repaint();
        if ( changeEvent == null )
            changeEvent = new ChangeEvent(this);
        Iterator iter = listeners.iterator();
        while ( iter.hasNext() )
            ((ChangeListener)iter.next()).stateChanged(changeEvent);
    }

	public Dimension getPreferredSize() {
		if (orientation == VERTICAL) {
			return new Dimension(PREFERRED_BREADTH, PREFERRED_LENGTH);
		}
		else {
			return new Dimension(PREFERRED_LENGTH, PREFERRED_BREADTH);
		}
	}

	//////////////////////////////////
	// PAINT METHOD
	//////////////////////////////////

	/**
	 * Override this method to perform custom painting of the slider trough
	 */
	protected void customPaint(Graphics2D g, int width, int height) {
	    // does nothing in this class
	    // subclasses can override to perform custom painting
	}
	
	public void paintComponent(Graphics g) {		
		Rectangle bounds = getBounds();
		int width = (int)bounds.getWidth() - 1;
		int height = (int)bounds.getHeight() - 1;

		int min = toScreen(getLowValue());
		int max = toScreen(getHighValue());

		// Paint the full slider if the slider is marked as empty
		if (empty) {
			if (direction == LEFTRIGHT_TOPBOTTOM) {
				min = ARROW_SZ;
				max = (orientation == VERTICAL) ? height-ARROW_SZ : width-ARROW_SZ;
			}
			else {
				min = (orientation == VERTICAL) ? height-ARROW_SZ : width-ARROW_SZ;
				max = ARROW_SZ; 				
			}
		}

		Graphics2D g2 = (Graphics2D)g;
		g2.setColor(getBackground());
		g2.fillRect(0, 0, width, height);
		g2.setColor(getForeground());
		g2.drawRect(0, 0, width, height);

		customPaint(g2, width, height);
		
		// Draw arrow and thumb backgrounds
		g2.setStroke(new BasicStroke(1));
		if (orientation == VERTICAL) {	
			if (direction == LEFTRIGHT_TOPBOTTOM) {
				g2.setColor(getForeground());
				g2.fillRect(0, min - ARROW_SZ, width, ARROW_SZ-1);
				paint3DRectLighting(g2,0,min-ARROW_SZ,width,ARROW_SZ-1);
			
				if ( thumbColor != null ) {
				    g2.setColor(thumbColor);
				    g2.fillRect(0, min, width, max - min-1);
				    paint3DRectLighting(g2,0,min,width,max-min-1);
				}
				
				g2.setColor(getForeground());
				g2.fillRect(0, max, width, ARROW_SZ-1);
				paint3DRectLighting(g2,0,max,width,ARROW_SZ-1);
			
				// Draw arrows			
				g2.setColor(Color.black);
				paintArrow(g2, (width-ARROW_WIDTH) / 2.0, min - ARROW_SZ + (ARROW_SZ-ARROW_HEIGHT) / 2.0, ARROW_WIDTH, ARROW_HEIGHT, true);
				paintArrow(g2, (width-ARROW_WIDTH) / 2.0, max + (ARROW_SZ-ARROW_HEIGHT) / 2.0, ARROW_WIDTH, ARROW_HEIGHT, false);
			}
			else {
				g2.setColor(getForeground());
				g2.fillRect(0, min, width, ARROW_SZ-1);
				paint3DRectLighting(g2,0,min,width,ARROW_SZ-1);
			
				if ( thumbColor != null ) {
				    g2.setColor(thumbColor);
				    g2.fillRect(0, max, width, min-max-1);
				    paint3DRectLighting(g2,0,max,width,min-max-1);
				}
			
				g2.setColor(getForeground());
				g2.fillRect(0, max-ARROW_SZ, width, ARROW_SZ-1);
				paint3DRectLighting(g2,0,max-ARROW_SZ,width,ARROW_SZ-1);
			
				// Draw arrows			
				g2.setColor(Color.black);
				paintArrow(g2, (width-ARROW_WIDTH) / 2.0, min + (ARROW_SZ-ARROW_HEIGHT) / 2.0, ARROW_WIDTH, ARROW_HEIGHT, false);
				paintArrow(g2, (width-ARROW_WIDTH) / 2.0, max - ARROW_SZ + (ARROW_SZ-ARROW_HEIGHT) / 2.0, ARROW_WIDTH, ARROW_HEIGHT, true);				
			}
		}
		else {
			if (direction == LEFTRIGHT_TOPBOTTOM) {
				g2.setColor(getForeground());
				g2.fillRect(min - ARROW_SZ, 0, ARROW_SZ-1, height);
				paint3DRectLighting(g2,min-ARROW_SZ,0,ARROW_SZ-1,height);
			
				if ( thumbColor != null ) {
				    g2.setColor(thumbColor);
				    g2.fillRect(min, 0, max - min - 1, height);
				    paint3DRectLighting(g2,min,0,max-min-1,height);
				}

				g2.setColor(getForeground());
				g2.fillRect(max, 0, ARROW_SZ-1, height);
				paint3DRectLighting(g2,max,0,ARROW_SZ-1,height);
			
				// Draw arrows			
				g2.setColor(Color.black);
				paintArrow(g2, min - ARROW_SZ + (ARROW_SZ-ARROW_HEIGHT) / 2.0, (height-ARROW_WIDTH) / 2.0, ARROW_HEIGHT, ARROW_WIDTH, true);
				paintArrow(g2, max + (ARROW_SZ-ARROW_HEIGHT) / 2.0, (height-ARROW_WIDTH) / 2.0, ARROW_HEIGHT, ARROW_WIDTH, false);
			}
			else {
				g2.setColor(getForeground());
				g2.fillRect(min, 0, ARROW_SZ - 1, height);
				paint3DRectLighting(g2,min,0,ARROW_SZ-1,height);
				
				if ( thumbColor != null ) {
				    g2.setColor(thumbColor);
				    g2.fillRect(max, 0, min - max - 1, height);
				    paint3DRectLighting(g2,max,0,min-max-1,height); 
				}
				
				g2.setColor(getForeground());
				g2.fillRect(max-ARROW_SZ, 0, ARROW_SZ-1, height);
				paint3DRectLighting(g2,max-ARROW_SZ,0,ARROW_SZ-1,height); 
			
				// Draw arrows			
				g2.setColor(Color.black);
				paintArrow(g2, min + (ARROW_SZ-ARROW_HEIGHT) / 2.0, (height-ARROW_WIDTH) / 2.0, ARROW_HEIGHT, ARROW_WIDTH, true);
				paintArrow(g2, max - ARROW_SZ + (ARROW_SZ-ARROW_HEIGHT) / 2.0, (height-ARROW_WIDTH) / 2.0, ARROW_HEIGHT, ARROW_WIDTH, false);					
			}
		}				
	}

	/**
	 * This draws an arrow as a series of lines within the specified box.  The last boolean
	 * specifies whether the point should be at the right/bottom or left/top. 
	 */
	public void paintArrow(Graphics2D g2, double x, double y, int w, int h, boolean topDown) {
		int intX = (int)(x+0.5);
		int intY = (int)(y+0.5);
		
		if (orientation == VERTICAL) {
			if (w % 2 == 0) {
				w = w - 1;
			}
			
			if (topDown) {
				for(int i=0; i<(w/2+1); i++) {
					g2.drawLine(intX+i,intY+i,intX+w-i-1,intY+i);
				}
			}
			else {
				for(int i=0; i<(w/2+1); i++) {
					g2.drawLine(intX+w/2-i,intY+i,intX+w-w/2+i-1,intY+i);
				}				
			}
		}
		else {
			if (h % 2 == 0) {
				h = h - 1;
			}
						
			if (topDown) {
				for(int i=0; i<(h/2+1); i++) {
					g2.drawLine(intX+i,intY+i,intX+i,intY+h-i-1);
				}
			}
			else {
				for(int i=0; i<(h/2+1); i++) {
					g2.drawLine(intX+i,intY+h/2-i,intX+i,intY+h-h/2+i-1);
				}				
			}			
		}
	}
	
	/**
	 * Adds Windows2K type 3D lighting effects
	 */
	public void paint3DRectLighting(Graphics2D g2, int x, int y, int width, int height) {
		g2.setColor(Color.white);
		g2.drawLine(x+1,y+1,x+1,y+height-1);
		g2.drawLine(x+1,y+1,x+width-1,y+1);
		g2.setColor(Color.gray);
		g2.drawLine(x+1,y+height-1,x+width-1,y+height-1);
		g2.drawLine(x+width-1,y+1,x+width-1,y+height-1);
		g2.setColor(Color.darkGray);
		g2.drawLine(x,y+height,x+width,y+height);
		g2.drawLine(x+width,y,x+width,y+height);		
	}

	// Converts from screen coordinates to a range value.
	protected int toLocal(int xOrY) {
		Dimension sz = getSize();
        int min = getMinimum();
		double scale;
		if (orientation == VERTICAL) {
			scale = (sz.height - (2 * ARROW_SZ)) / (double) (getMaximum() - min);			
		}
		else {
			scale = (sz.width - (2 * ARROW_SZ)) / (double) (getMaximum() - min);
		}

		if (direction == LEFTRIGHT_TOPBOTTOM) {
			return (int) (((xOrY - ARROW_SZ) / scale) + min + 0.5);			
		}
		else {
			if (orientation == VERTICAL) {
				return (int) ((sz.height - xOrY - ARROW_SZ) / scale + min + 0.5);
			}
			else {
				return (int) ((sz.width - xOrY - ARROW_SZ) / scale + min + 0.5);
			}
		}
	}

	// Converts from a range value to screen coordinates.
	protected int toScreen(int xOrY) {
		Dimension sz = getSize();
        int min = getMinimum();
		double scale;
		if (orientation == VERTICAL) {
			scale = (sz.height - (2 * ARROW_SZ)) / (double) (getMaximum() - min);			
		}
		else {
			scale = (sz.width - (2 * ARROW_SZ)) / (double) (getMaximum() - min);
		}

		// If the direction is left/right_top/bottom then we subtract the min and multiply times scale
		// Otherwise, we have to invert the number by subtracting the value from the height
		if (direction == LEFTRIGHT_TOPBOTTOM) {
			return (int)(ARROW_SZ + ((xOrY - min) * scale) + 0.5);
		}
		else {
			if (orientation == VERTICAL) {
				return (int)(sz.height-(xOrY - min) * scale - ARROW_SZ + 0.5);
			}
			else {
				return (int)(sz.width-(xOrY - min) * scale - ARROW_SZ + 0.5);
			}
		}
	}

	// Converts from a range value to screen coordinates.
	protected double toScreenDouble(int xOrY) {
		Dimension sz = getSize();
        int min = getMinimum();
		double scale;
		if (orientation == VERTICAL) {
			scale = (sz.height - (2 * ARROW_SZ)) / (double) (getMaximum()+1 - min);			
		}
		else {
			scale = (sz.width - (2 * ARROW_SZ)) / (double) (getMaximum()+1 - min);
		}

		// If the direction is left/right_top/bottom then we subtract the min and multiply times scale
		// Otherwise, we have to invert the number by subtracting the value from the height
		if (direction == LEFTRIGHT_TOPBOTTOM) {
			return ARROW_SZ + ((xOrY - min) * scale);
		}
		else {
			if (orientation == VERTICAL) {
				return sz.height-(xOrY - min) * scale - ARROW_SZ;
			}
			else {
				return sz.width-(xOrY - min) * scale - ARROW_SZ;
			}
		}
	}

	
	//////////////////////////////////
	// EVENT HANDLING
	//////////////////////////////////

	static final int PICK_NONE = 0;
	static final int PICK_LEFT_OR_TOP = 1;
	static final int PICK_THUMB = 2;
	static final int PICK_RIGHT_OR_BOTTOM = 3;
	int pick;
	int pickOffsetLow;
	int pickOffsetHigh;
	int mouse;

	private int pickHandle(int xOrY) {
		int min = toScreen(getLowValue());
		int max = toScreen(getHighValue());
		int pick = PICK_NONE;
		
		if (direction == LEFTRIGHT_TOPBOTTOM) {
			if ((xOrY > (min - ARROW_SZ)) && (xOrY < min)) {
				pick = PICK_LEFT_OR_TOP;
			} else if ((xOrY >= min) && (xOrY <= max)) {
				pick = PICK_THUMB;
			} else if ((xOrY > max) && (xOrY < (max + ARROW_SZ))) {
				pick = PICK_RIGHT_OR_BOTTOM;
			}
		}
		else {
			if ((xOrY > min) && (xOrY < (min + ARROW_SZ))) {
				pick = PICK_LEFT_OR_TOP;
			} else if ((xOrY <= min) && (xOrY >= max)) {
				pick = PICK_THUMB;
			} else if ((xOrY > (max - ARROW_SZ) && (xOrY < max))) {
				pick = PICK_RIGHT_OR_BOTTOM;
			}			
		}
		
		return pick;
	}

	private void offset(int dxOrDy) {
        model.setValue(model.getValue()+dxOrDy);
	}

	public void mousePressed(MouseEvent e) {		
		if (orientation == VERTICAL) {
			pick = pickHandle(e.getY());
			pickOffsetLow = e.getY() - toScreen(getLowValue());
			pickOffsetHigh = e.getY() - toScreen(getHighValue());
			mouse = e.getY();
		}
		else {
			pick = pickHandle(e.getX());
			pickOffsetLow = e.getX() - toScreen(getLowValue());
			pickOffsetHigh = e.getX() - toScreen(getHighValue());
			mouse = e.getX();			
		}
		repaint();
	}

	public void mouseDragged(MouseEvent e) {
        requestFocus();
		int value = (orientation == VERTICAL) ? e.getY() : e.getX();
		
        int minimum = getMinimum();
        int maximum = getMaximum();
        int lowValue = getLowValue();
        int highValue = getHighValue();
        
		switch (pick) {
			case PICK_LEFT_OR_TOP:
				int low = toLocal(value-pickOffsetLow);
			
				if (low < minimum) {
					low = minimum;
				}
				if (low > maximum) {
					low = maximum;
				}
			
				if (low > highValue) {
					low = highValue;
				}
				setLowValue(low);
				break;

			case PICK_RIGHT_OR_BOTTOM:
				int high = toLocal(value-pickOffsetHigh);
				
				if (high < minimum) {
					high = minimum;
				}
				if (high > maximum) {
					high = maximum;
				}

				if (high < lowValue) {
					high = lowValue;
				}
				setHighValue(high);
				break;

			case PICK_THUMB:
				int dxOrDy = toLocal(value - pickOffsetLow) - lowValue;
				if ((dxOrDy < 0) && ((lowValue + dxOrDy) < minimum)) {
					dxOrDy = minimum - lowValue;
				}
				if ((dxOrDy > 0) && ((highValue + dxOrDy) > maximum)) {
					dxOrDy = maximum - highValue;
				}
				if (dxOrDy != 0) {
					offset(dxOrDy);
				}
				break;
		}
	}

	public void mouseReleased(MouseEvent e) {
		pick = PICK_NONE;
		repaint();
	}

	public void mouseMoved(MouseEvent e) {
		if (orientation == VERTICAL) {
			switch (pickHandle(e.getY())) {
				case PICK_LEFT_OR_TOP:
					setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
					break;
				case PICK_RIGHT_OR_BOTTOM:
					setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
					break;
				case PICK_THUMB:
					setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
					break;
				case PICK_NONE :
					setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
					break;
			}
		}
		else {
			switch (pickHandle(e.getX())) {
				case PICK_LEFT_OR_TOP:
					setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
					break;
				case PICK_RIGHT_OR_BOTTOM:
					setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
					break;
				case PICK_THUMB:
					setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
					break;
				case PICK_NONE :
					setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
					break;
			}			
		}
	}

	public void mouseClicked(MouseEvent e) {
	}
	public void mouseEntered(MouseEvent e) {
	}
	public void mouseExited(MouseEvent e) {
	}

	private void grow(int increment) {
        model.setRangeProperties(model.getValue()-increment,
            model.getExtent()+2*increment, 
            model.getMinimum(), model.getMaximum(), false);
	}
	
	public void keyPressed(KeyEvent e) {
        int kc = e.getKeyCode();
        boolean v = (orientation == VERTICAL);
        boolean d = (kc == KeyEvent.VK_DOWN);
        boolean u = (kc == KeyEvent.VK_UP);
        boolean l = (kc == KeyEvent.VK_LEFT);
        boolean r = (kc == KeyEvent.VK_RIGHT);
        
        int minimum = getMinimum();
        int maximum = getMaximum();
        int lowValue = getLowValue();
        int highValue = getHighValue();
        
        if ( v&&r || !v&&u ) {
	        if ( lowValue-increment >= minimum &&
	             highValue+increment <= maximum ) {
	            grow(increment);
	        }
        } else if ( v&&l || !v&&d ) { 
            if ( highValue-lowValue >= 2*increment ) {
                grow(-1*increment);
            }
        } else if ( v&&d || !v&&l ) {
	        if ( lowValue-increment >= minimum ) {
	            offset(-increment);
	        }
        } else if ( v&&u || !v&&r ) {
	        if ( highValue+increment <= maximum ) {
	            offset(increment);
	        }
        }
    }
	
    public void keyReleased(KeyEvent e) {
    }
    public void keyTyped(KeyEvent e) {
    }
	
	//////////////////////////////////
	// TEST FUNCTION
	//////////////////////////////////
	public static void main(String args[]) {
		JFrame f = new JFrame("Custom Range Slider");
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		Panel panel = new Panel() {
			public void update(Graphics g) {
				paint(g);
			}
		};
		panel.setLayout(new BorderLayout());
		
		JPanel aPanel = new JPanel();
		aPanel.setBackground(Color.white);
		aPanel.setPreferredSize(new Dimension(500,500));		
		
		JPanel hPanel = new JPanel();
		JPanel cornerPanel = new JPanel();
		cornerPanel.setPreferredSize(new Dimension(PREFERRED_BREADTH,PREFERRED_BREADTH));
		cornerPanel.setMaximumSize(new Dimension(PREFERRED_BREADTH,PREFERRED_BREADTH));
		cornerPanel.setOpaque(false);
		JRangeSlider rscH = new JRangeSlider(0, 100, 20, 50, HORIZONTAL,LEFTRIGHT_TOPBOTTOM);//RIGHTLEFT_BOTTOMTOP);
		rscH.addChangeListener(new ChangeListener() {
			public void stateChanged(ChangeEvent e) {
			    JRangeSlider s = (JRangeSlider)e.getSource();
				System.out.println("H "+s.getLowValue()+" "+s.getHighValue());
			}
		});
		hPanel.setLayout(new BoxLayout(hPanel,BoxLayout.X_AXIS));
		hPanel.add(rscH);
		hPanel.add(cornerPanel);
		

		JRangeSlider rscV = new JRangeSlider(0, 100, 20, 50, VERTICAL,LEFTRIGHT_TOPBOTTOM);//RIGHTLEFT_BOTTOMTOP); 
		rscV.addChangeListener(new ChangeListener() {
            public void stateChanged(ChangeEvent e) {
                JRangeSlider s = (JRangeSlider)e.getSource();
                System.out.println("V "+s.getLowValue()+" "+s.getHighValue());
            }
        });

		panel.add(aPanel);
		panel.add(rscV,"East");
		panel.add(hPanel,"South");

		f.getContentPane().setLayout(new BorderLayout());
		f.getContentPane().add(panel,"Center");

		f.pack();
		f.setVisible(true);
	}
}@


1.1.2.2
log
@Table method refactoring. Added PredicateChain, included in ColorFunction, SizeFunction, and RendererFactory. Added ItemBoundsListener, included in GraphView demo. Updated ColorMap to use int representation, moved palette creators to ColorLib. Added minExtent to JRangeSlider. Fixed round-off rendering glitches int optimized rendering, added RenderingAccuracy test class. Updated PrefuseConfig to support logging output to file system. Added DelmitedTextTableWriter. Added CompositeTupleSet. Added directionality to edges, increased support to EdgeRenderer, including reversed directionality.
@
text
@d33 6
a66 1
	protected int minExtent = 0; // min extent, in pixels
a204 10
	 * Sets the minimum extent (difference between low and high values).
	 * This method <strong>does not</strong> change the current state of the
	 * model, but can affect all subsequent interaction.
	 * @@param minExtent
	 */
	public void setMinExtent(int minExtent) {
		this.minExtent = minExtent;
	}
	
	/**
d619 3
a621 2
				if (low > highValue-minExtent) {
					low = highValue-minExtent;
d635 3
a637 2
				if (high < lowValue+minExtent) {
					high = lowValue+minExtent;
@


1.1.2.3
log
@Replaced all tab characters with 4 spaces.
Ensured UNIX style line endings.
@
text
@d43 12
a54 12
    implements MouseListener, MouseMotionListener, KeyListener
{   
    final public static int VERTICAL = 0;
    final public static int HORIZONTAL = 1;
    final public static int LEFTRIGHT_TOPBOTTOM = 0;
    final public static int RIGHTLEFT_BOTTOMTOP = 1;
    
    final public static int PREFERRED_BREADTH = 16;
    final public static int PREFERRED_LENGTH = 300;
    final protected static int ARROW_SZ = 16;
    final protected static int ARROW_WIDTH = 8;
    final protected static int ARROW_HEIGHT = 4;
d58 4
a61 4
    protected int direction;
    protected boolean empty;
    protected int increment = 1;
    protected int minExtent = 0; // min extent, in pixels
d63 1
a63 1
    protected ArrayList listeners = new ArrayList();
d67 2
a68 2
    protected Color thumbColor = new Color(150,180,220);
    
d70 15
a84 15
    //////////////////////////////////
    // PUBLIC API
    //////////////////////////////////

    /** 
     * Constructs a new range slider. 
     *
     * @@param minimum - the minimum value of the range.
     * @@param maximum - the maximum value of the range.
     * @@param lowValue - the current low value shown by the range slider's bar.
     * @@param highValue - the current high value shown by the range slider's bar.
     * @@param orientation - construct a horizontal or vertical slider?
     */
    public JRangeSlider(int minimum, int maximum, int lowValue, int highValue, int orientation) {
        this(new DefaultBoundedRangeModel(lowValue,highValue,minimum,maximum),
d86 1
a86 1
    }
d88 12
a99 12
    /** 
     * Constructs a new range slider. 
     *
     * @@param minimum - the minimum value of the range.
     * @@param maximum - the maximum value of the range.
     * @@param lowValue - the current low value shown by the range slider's bar.
     * @@param highValue - the current high value shown by the range slider's bar.
     * @@param orientation - construct a horizontal or vertical slider?
     * @@param direction - Is the slider left-to-right/top-to-bottom or right-to-left/bottom-to-top
     */
    public JRangeSlider(int minimum, int maximum, int lowValue, int highValue, int orientation, int direction) {
        this(new DefaultBoundedRangeModel(lowValue, highValue, minimum, maximum), 
d101 1
a101 1
    }
d129 13
a141 13
    /** 
     * Returns the current "low" value shown by the range slider's bar. The low
     * value meets the constraint minimum <= lowValue <= highValue <= maximum. 
     */
    public int getLowValue() {
        return model.getValue();
    }

    /** 
     * Sets the low value shown by this range slider. This causes the range slider to be
     * repainted and a RangeEvent to be fired.
     */
    public void setLowValue(int lowValue) {
d146 1
a146 1
    }
d148 13
a160 13
    /** 
     * Returns the current "high" value shown by the range slider's bar. The high
     * value meets the constraint minimum <= lowValue <= highValue <= maximum. 
     */
    public int getHighValue() {
        return model.getValue()+model.getExtent();
    }

    /** 
     * Sets the high value shown by this range slider. This causes the range slider to be
     * repainted and a RangeEvent to be fired.
     */
    public void setHighValue(int highValue) {
d162 3
a164 3
    }
    
    public void setRange(int lowValue, int highValue) {
d167 1
a167 1
    }
d169 12
a180 12
    /**
     * Returns the minimum possible value for either the low value or the high value.
     */
    public int getMinimum() {
        return model.getMinimum();
    }

    /**
     * Sets the minimum.
     * @@param minimum The minimum to set
     */
    public void setMinimum(int minimum) {
d182 1
a182 1
    }
d184 12
a195 12
    /**
     * Returns the maximum possible value for either the low value or the high value.
     */
    public int getMaximum() {
        return model.getMaximum();
    }

    /**
     * Sets the maximum.
     * @@param maximum The maximum to set
     */
    public void setMaximum(int maximum) {
d197 1
a197 1
    }
d199 18
a216 18
    /**
     * Sets the minimum extent (difference between low and high values).
     * This method <strong>does not</strong> change the current state of the
     * model, but can affect all subsequent interaction.
     * @@param minExtent
     */
    public void setMinExtent(int minExtent) {
        this.minExtent = minExtent;
    }
    
    /**
     * Set whether this slider is empty
     * @@param r
     */
    public void setEmpty(boolean empty) {
        this.empty = empty;
        repaint();
    }
d231 1
a231 1
    
d247 5
a251 5
    /** 
     * Registers a listener for ChangeEvents.
     */
    public void addChangeListener(ChangeListener cl) {
        if ( !listeners.contains(cl) )
d253 1
a253 1
    }
d255 6
a260 6
    /** 
     * Removes a listener for ChangeEvents.
     */
    public void removeChangeListener(ChangeListener cl) {
        listeners.remove(cl);
    }
d271 197
a467 197
    public Dimension getPreferredSize() {
        if (orientation == VERTICAL) {
            return new Dimension(PREFERRED_BREADTH, PREFERRED_LENGTH);
        }
        else {
            return new Dimension(PREFERRED_LENGTH, PREFERRED_BREADTH);
        }
    }

    //////////////////////////////////
    // PAINT METHOD
    //////////////////////////////////

    /**
     * Override this method to perform custom painting of the slider trough
     */
    protected void customPaint(Graphics2D g, int width, int height) {
        // does nothing in this class
        // subclasses can override to perform custom painting
    }
    
    public void paintComponent(Graphics g) {        
        Rectangle bounds = getBounds();
        int width = (int)bounds.getWidth() - 1;
        int height = (int)bounds.getHeight() - 1;

        int min = toScreen(getLowValue());
        int max = toScreen(getHighValue());

        // Paint the full slider if the slider is marked as empty
        if (empty) {
            if (direction == LEFTRIGHT_TOPBOTTOM) {
                min = ARROW_SZ;
                max = (orientation == VERTICAL) ? height-ARROW_SZ : width-ARROW_SZ;
            }
            else {
                min = (orientation == VERTICAL) ? height-ARROW_SZ : width-ARROW_SZ;
                max = ARROW_SZ;                 
            }
        }

        Graphics2D g2 = (Graphics2D)g;
        g2.setColor(getBackground());
        g2.fillRect(0, 0, width, height);
        g2.setColor(getForeground());
        g2.drawRect(0, 0, width, height);

        customPaint(g2, width, height);
        
        // Draw arrow and thumb backgrounds
        g2.setStroke(new BasicStroke(1));
        if (orientation == VERTICAL) {  
            if (direction == LEFTRIGHT_TOPBOTTOM) {
                g2.setColor(getForeground());
                g2.fillRect(0, min - ARROW_SZ, width, ARROW_SZ-1);
                paint3DRectLighting(g2,0,min-ARROW_SZ,width,ARROW_SZ-1);
            
                if ( thumbColor != null ) {
                    g2.setColor(thumbColor);
                    g2.fillRect(0, min, width, max - min-1);
                    paint3DRectLighting(g2,0,min,width,max-min-1);
                }
                
                g2.setColor(getForeground());
                g2.fillRect(0, max, width, ARROW_SZ-1);
                paint3DRectLighting(g2,0,max,width,ARROW_SZ-1);
            
                // Draw arrows          
                g2.setColor(Color.black);
                paintArrow(g2, (width-ARROW_WIDTH) / 2.0, min - ARROW_SZ + (ARROW_SZ-ARROW_HEIGHT) / 2.0, ARROW_WIDTH, ARROW_HEIGHT, true);
                paintArrow(g2, (width-ARROW_WIDTH) / 2.0, max + (ARROW_SZ-ARROW_HEIGHT) / 2.0, ARROW_WIDTH, ARROW_HEIGHT, false);
            }
            else {
                g2.setColor(getForeground());
                g2.fillRect(0, min, width, ARROW_SZ-1);
                paint3DRectLighting(g2,0,min,width,ARROW_SZ-1);
            
                if ( thumbColor != null ) {
                    g2.setColor(thumbColor);
                    g2.fillRect(0, max, width, min-max-1);
                    paint3DRectLighting(g2,0,max,width,min-max-1);
                }
            
                g2.setColor(getForeground());
                g2.fillRect(0, max-ARROW_SZ, width, ARROW_SZ-1);
                paint3DRectLighting(g2,0,max-ARROW_SZ,width,ARROW_SZ-1);
            
                // Draw arrows          
                g2.setColor(Color.black);
                paintArrow(g2, (width-ARROW_WIDTH) / 2.0, min + (ARROW_SZ-ARROW_HEIGHT) / 2.0, ARROW_WIDTH, ARROW_HEIGHT, false);
                paintArrow(g2, (width-ARROW_WIDTH) / 2.0, max - ARROW_SZ + (ARROW_SZ-ARROW_HEIGHT) / 2.0, ARROW_WIDTH, ARROW_HEIGHT, true);             
            }
        }
        else {
            if (direction == LEFTRIGHT_TOPBOTTOM) {
                g2.setColor(getForeground());
                g2.fillRect(min - ARROW_SZ, 0, ARROW_SZ-1, height);
                paint3DRectLighting(g2,min-ARROW_SZ,0,ARROW_SZ-1,height);
            
                if ( thumbColor != null ) {
                    g2.setColor(thumbColor);
                    g2.fillRect(min, 0, max - min - 1, height);
                    paint3DRectLighting(g2,min,0,max-min-1,height);
                }

                g2.setColor(getForeground());
                g2.fillRect(max, 0, ARROW_SZ-1, height);
                paint3DRectLighting(g2,max,0,ARROW_SZ-1,height);
            
                // Draw arrows          
                g2.setColor(Color.black);
                paintArrow(g2, min - ARROW_SZ + (ARROW_SZ-ARROW_HEIGHT) / 2.0, (height-ARROW_WIDTH) / 2.0, ARROW_HEIGHT, ARROW_WIDTH, true);
                paintArrow(g2, max + (ARROW_SZ-ARROW_HEIGHT) / 2.0, (height-ARROW_WIDTH) / 2.0, ARROW_HEIGHT, ARROW_WIDTH, false);
            }
            else {
                g2.setColor(getForeground());
                g2.fillRect(min, 0, ARROW_SZ - 1, height);
                paint3DRectLighting(g2,min,0,ARROW_SZ-1,height);
                
                if ( thumbColor != null ) {
                    g2.setColor(thumbColor);
                    g2.fillRect(max, 0, min - max - 1, height);
                    paint3DRectLighting(g2,max,0,min-max-1,height); 
                }
                
                g2.setColor(getForeground());
                g2.fillRect(max-ARROW_SZ, 0, ARROW_SZ-1, height);
                paint3DRectLighting(g2,max-ARROW_SZ,0,ARROW_SZ-1,height); 
            
                // Draw arrows          
                g2.setColor(Color.black);
                paintArrow(g2, min + (ARROW_SZ-ARROW_HEIGHT) / 2.0, (height-ARROW_WIDTH) / 2.0, ARROW_HEIGHT, ARROW_WIDTH, true);
                paintArrow(g2, max - ARROW_SZ + (ARROW_SZ-ARROW_HEIGHT) / 2.0, (height-ARROW_WIDTH) / 2.0, ARROW_HEIGHT, ARROW_WIDTH, false);                   
            }
        }               
    }

    /**
     * This draws an arrow as a series of lines within the specified box.  The last boolean
     * specifies whether the point should be at the right/bottom or left/top. 
     */
    public void paintArrow(Graphics2D g2, double x, double y, int w, int h, boolean topDown) {
        int intX = (int)(x+0.5);
        int intY = (int)(y+0.5);
        
        if (orientation == VERTICAL) {
            if (w % 2 == 0) {
                w = w - 1;
            }
            
            if (topDown) {
                for(int i=0; i<(w/2+1); i++) {
                    g2.drawLine(intX+i,intY+i,intX+w-i-1,intY+i);
                }
            }
            else {
                for(int i=0; i<(w/2+1); i++) {
                    g2.drawLine(intX+w/2-i,intY+i,intX+w-w/2+i-1,intY+i);
                }               
            }
        }
        else {
            if (h % 2 == 0) {
                h = h - 1;
            }
                        
            if (topDown) {
                for(int i=0; i<(h/2+1); i++) {
                    g2.drawLine(intX+i,intY+i,intX+i,intY+h-i-1);
                }
            }
            else {
                for(int i=0; i<(h/2+1); i++) {
                    g2.drawLine(intX+i,intY+h/2-i,intX+i,intY+h-h/2+i-1);
                }               
            }           
        }
    }
    
    /**
     * Adds Windows2K type 3D lighting effects
     */
    public void paint3DRectLighting(Graphics2D g2, int x, int y, int width, int height) {
        g2.setColor(Color.white);
        g2.drawLine(x+1,y+1,x+1,y+height-1);
        g2.drawLine(x+1,y+1,x+width-1,y+1);
        g2.setColor(Color.gray);
        g2.drawLine(x+1,y+height-1,x+width-1,y+height-1);
        g2.drawLine(x+width-1,y+1,x+width-1,y+height-1);
        g2.setColor(Color.darkGray);
        g2.drawLine(x,y+height,x+width,y+height);
        g2.drawLine(x+width,y,x+width,y+height);        
    }

    // Converts from screen coordinates to a range value.
    protected int toLocal(int xOrY) {
        Dimension sz = getSize();
d469 24
a492 24
        double scale;
        if (orientation == VERTICAL) {
            scale = (sz.height - (2 * ARROW_SZ)) / (double) (getMaximum() - min);           
        }
        else {
            scale = (sz.width - (2 * ARROW_SZ)) / (double) (getMaximum() - min);
        }

        if (direction == LEFTRIGHT_TOPBOTTOM) {
            return (int) (((xOrY - ARROW_SZ) / scale) + min + 0.5);         
        }
        else {
            if (orientation == VERTICAL) {
                return (int) ((sz.height - xOrY - ARROW_SZ) / scale + min + 0.5);
            }
            else {
                return (int) ((sz.width - xOrY - ARROW_SZ) / scale + min + 0.5);
            }
        }
    }

    // Converts from a range value to screen coordinates.
    protected int toScreen(int xOrY) {
        Dimension sz = getSize();
d494 26
a519 26
        double scale;
        if (orientation == VERTICAL) {
            scale = (sz.height - (2 * ARROW_SZ)) / (double) (getMaximum() - min);           
        }
        else {
            scale = (sz.width - (2 * ARROW_SZ)) / (double) (getMaximum() - min);
        }

        // If the direction is left/right_top/bottom then we subtract the min and multiply times scale
        // Otherwise, we have to invert the number by subtracting the value from the height
        if (direction == LEFTRIGHT_TOPBOTTOM) {
            return (int)(ARROW_SZ + ((xOrY - min) * scale) + 0.5);
        }
        else {
            if (orientation == VERTICAL) {
                return (int)(sz.height-(xOrY - min) * scale - ARROW_SZ + 0.5);
            }
            else {
                return (int)(sz.width-(xOrY - min) * scale - ARROW_SZ + 0.5);
            }
        }
    }

    // Converts from a range value to screen coordinates.
    protected double toScreenDouble(int xOrY) {
        Dimension sz = getSize();
d521 63
a583 63
        double scale;
        if (orientation == VERTICAL) {
            scale = (sz.height - (2 * ARROW_SZ)) / (double) (getMaximum()+1 - min);         
        }
        else {
            scale = (sz.width - (2 * ARROW_SZ)) / (double) (getMaximum()+1 - min);
        }

        // If the direction is left/right_top/bottom then we subtract the min and multiply times scale
        // Otherwise, we have to invert the number by subtracting the value from the height
        if (direction == LEFTRIGHT_TOPBOTTOM) {
            return ARROW_SZ + ((xOrY - min) * scale);
        }
        else {
            if (orientation == VERTICAL) {
                return sz.height-(xOrY - min) * scale - ARROW_SZ;
            }
            else {
                return sz.width-(xOrY - min) * scale - ARROW_SZ;
            }
        }
    }

    
    //////////////////////////////////
    // EVENT HANDLING
    //////////////////////////////////

    static final int PICK_NONE = 0;
    static final int PICK_LEFT_OR_TOP = 1;
    static final int PICK_THUMB = 2;
    static final int PICK_RIGHT_OR_BOTTOM = 3;
    int pick;
    int pickOffsetLow;
    int pickOffsetHigh;
    int mouse;

    private int pickHandle(int xOrY) {
        int min = toScreen(getLowValue());
        int max = toScreen(getHighValue());
        int pick = PICK_NONE;
        
        if (direction == LEFTRIGHT_TOPBOTTOM) {
            if ((xOrY > (min - ARROW_SZ)) && (xOrY < min)) {
                pick = PICK_LEFT_OR_TOP;
            } else if ((xOrY >= min) && (xOrY <= max)) {
                pick = PICK_THUMB;
            } else if ((xOrY > max) && (xOrY < (max + ARROW_SZ))) {
                pick = PICK_RIGHT_OR_BOTTOM;
            }
        }
        else {
            if ((xOrY > min) && (xOrY < (min + ARROW_SZ))) {
                pick = PICK_LEFT_OR_TOP;
            } else if ((xOrY <= min) && (xOrY >= max)) {
                pick = PICK_THUMB;
            } else if ((xOrY > (max - ARROW_SZ) && (xOrY < max))) {
                pick = PICK_RIGHT_OR_BOTTOM;
            }           
        }
        
        return pick;
    }
d585 1
a585 1
    private void offset(int dxOrDy) {
d587 1
a587 1
    }
d589 15
a603 15
    public void mousePressed(MouseEvent e) {        
        if (orientation == VERTICAL) {
            pick = pickHandle(e.getY());
            pickOffsetLow = e.getY() - toScreen(getLowValue());
            pickOffsetHigh = e.getY() - toScreen(getHighValue());
            mouse = e.getY();
        }
        else {
            pick = pickHandle(e.getX());
            pickOffsetLow = e.getX() - toScreen(getLowValue());
            pickOffsetHigh = e.getX() - toScreen(getHighValue());
            mouse = e.getX();           
        }
        repaint();
    }
d605 1
a605 1
    public void mouseDragged(MouseEvent e) {
d607 2
a608 2
        int value = (orientation == VERTICAL) ? e.getY() : e.getX();
        
d614 92
a705 92
        switch (pick) {
            case PICK_LEFT_OR_TOP:
                int low = toLocal(value-pickOffsetLow);
            
                if (low < minimum) {
                    low = minimum;
                }
                if (low > maximum) {
                    low = maximum;
                }
                if (low > highValue-minExtent) {
                    low = highValue-minExtent;
                }
                setLowValue(low);
                break;

            case PICK_RIGHT_OR_BOTTOM:
                int high = toLocal(value-pickOffsetHigh);
                
                if (high < minimum) {
                    high = minimum;
                }
                if (high > maximum) {
                    high = maximum;
                }
                if (high < lowValue+minExtent) {
                    high = lowValue+minExtent;
                }
                setHighValue(high);
                break;

            case PICK_THUMB:
                int dxOrDy = toLocal(value - pickOffsetLow) - lowValue;
                if ((dxOrDy < 0) && ((lowValue + dxOrDy) < minimum)) {
                    dxOrDy = minimum - lowValue;
                }
                if ((dxOrDy > 0) && ((highValue + dxOrDy) > maximum)) {
                    dxOrDy = maximum - highValue;
                }
                if (dxOrDy != 0) {
                    offset(dxOrDy);
                }
                break;
        }
    }

    public void mouseReleased(MouseEvent e) {
        pick = PICK_NONE;
        repaint();
    }

    public void mouseMoved(MouseEvent e) {
        if (orientation == VERTICAL) {
            switch (pickHandle(e.getY())) {
                case PICK_LEFT_OR_TOP:
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                    break;
                case PICK_RIGHT_OR_BOTTOM:
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                    break;
                case PICK_THUMB:
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                    break;
                case PICK_NONE :
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                    break;
            }
        }
        else {
            switch (pickHandle(e.getX())) {
                case PICK_LEFT_OR_TOP:
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                    break;
                case PICK_RIGHT_OR_BOTTOM:
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                    break;
                case PICK_THUMB:
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                    break;
                case PICK_NONE :
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                    break;
            }           
        }
    }

    public void mouseClicked(MouseEvent e) {
    }
    public void mouseEntered(MouseEvent e) {
    }
    public void mouseExited(MouseEvent e) {
    }
d707 1
a707 1
    private void grow(int increment) {
d711 3
a713 3
    }
    
    public void keyPressed(KeyEvent e) {
d727 4
a730 4
            if ( lowValue-increment >= minimum &&
                 highValue+increment <= maximum ) {
                grow(increment);
            }
d736 3
a738 3
            if ( lowValue-increment >= minimum ) {
                offset(-increment);
            }
d740 3
a742 3
            if ( highValue+increment <= maximum ) {
                offset(increment);
            }
d745 1
a745 1
    
d750 34
a783 34
    
    //////////////////////////////////
    // TEST FUNCTION
    //////////////////////////////////
    public static void main(String args[]) {
        JFrame f = new JFrame("Custom Range Slider");
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        Panel panel = new Panel() {
            public void update(Graphics g) {
                paint(g);
            }
        };
        panel.setLayout(new BorderLayout());
        
        JPanel aPanel = new JPanel();
        aPanel.setBackground(Color.white);
        aPanel.setPreferredSize(new Dimension(500,500));        
        
        JPanel hPanel = new JPanel();
        JPanel cornerPanel = new JPanel();
        cornerPanel.setPreferredSize(new Dimension(PREFERRED_BREADTH,PREFERRED_BREADTH));
        cornerPanel.setMaximumSize(new Dimension(PREFERRED_BREADTH,PREFERRED_BREADTH));
        cornerPanel.setOpaque(false);
        JRangeSlider rscH = new JRangeSlider(0, 100, 20, 50, HORIZONTAL,LEFTRIGHT_TOPBOTTOM);//RIGHTLEFT_BOTTOMTOP);
        rscH.addChangeListener(new ChangeListener() {
            public void stateChanged(ChangeEvent e) {
                JRangeSlider s = (JRangeSlider)e.getSource();
                System.out.println("H "+s.getLowValue()+" "+s.getHighValue());
            }
        });
        hPanel.setLayout(new BoxLayout(hPanel,BoxLayout.X_AXIS));
        hPanel.add(rscH);
        hPanel.add(cornerPanel);
        
d785 2
a786 2
        JRangeSlider rscV = new JRangeSlider(0, 100, 20, 50, VERTICAL,LEFTRIGHT_TOPBOTTOM);//RIGHTLEFT_BOTTOMTOP); 
        rscV.addChangeListener(new ChangeListener() {
d793 11
a803 11
        panel.add(aPanel);
        panel.add(rscV,"East");
        panel.add(hPanel,"South");

        f.getContentPane().setLayout(new BorderLayout());
        f.getContentPane().add(panel,"Center");

        f.pack();
        f.setVisible(true);
    }
}
@


1.1.2.4
log
@Much more javadoc
@
text
@d4 1
d10 1
d21 1
d24 2
d30 2
a31 2
 * <p>Implements a Swing-based Range slider, which allows the user to enter a 
 * range (minimum and maximum) value.</p>
d33 8
a40 5
 * @@author Ben Bederson
 * @@author Jesse Grosjean
 * @@author Jon Meyer
 * @@author Lance Good
 * @@author jeffrey heer
a44 16
    /*
     * NOTE: This is a modified version of the original class distributed by
     * Ben Bederson, Jesse Grosjean, and Jon Meyer as part of an HCIL Tech
     * Report.  It is modified to allow both vertical and horitonal modes.
     * It also fixes a bug with offset on the buttons. Also fixed a bug with
     * rendering using (x,y) instead of (0,0) as origin.  Also modified to
     * render arrows as a series of lines rather than as a GeneralPath.
     * Also modified to fix rounding errors on toLocal and toScreen.
     * 
     * With inclusion in prefuse, this class has been further modified to use a
     * bounded range model, support keyboard commands and more extensize
     * parameterization of rendering/appearance options. Furthermore, a stub
     * method has been introduced to allow subclasses to perform custom
     * rendering within the slider through.
     */
    
d69 4
a72 1
    // ------------------------------------------------------------------------
d75 1
a75 1
     * Create a new range slider. 
d89 1
a89 1
     * Create a new range slider. 
a102 7
    /** 
     * Create a new range slider. 
     *
     * @@param model - a BoundedRangeModel specifying the slider's range
     * @@param orientation - construct a horizontal or vertical slider?
     * @@param direction - Is the slider left-to-right/top-to-bottom or right-to-left/bottom-to-top
     */
a118 4
    /**
     * Create a listener to relay change events from the bounded range model.
     * @@return a ChangeListener to relay events from the range model
     */
a122 4
    /**
     * Listener that fires a change event when it receives  change event from
     * the slider list model.
     */
d139 1
a139 2
     * repainted and a ChangeEvent to be fired.
     * @@param lowValue the low value to use
d158 1
a158 2
     * repainted and a ChangeEvent to be fired.
     * @@param highValue the high value to use
a163 5
    /**
     * Set the slider range span.
     * @@param lowValue the low value of the slider range
     * @@param highValue the high value of the slider range
     */
d170 1
a170 2
     * Gets the minimum possible value for either the low value or the high value.
     * @@return the minimum possible range value
d177 2
a178 2
     * Sets the minimum possible value for either the low value or the high value.
     * @@param minimum the minimum possible range value
d185 1
a185 2
     * Gets the maximum possible value for either the low value or the high value.
     * @@return the maximum possible range value
d192 2
a193 2
     * Sets the maximum possible value for either the low value or the high value.
     * @@param maximum the maximum possible range value
d203 1
a203 1
     * @@param minExtent the minimum extent allowed in subsequent interaction
d210 2
a211 2
     * Sets whether this slider is empty.
     * @@param empty true if set to empty, false otherwise
d219 1
a219 3
     * Get the slider thumb color. This is the part of the slider between
     * the range resize buttons.
     * @@return the slider thumb color
d226 1
a226 3
     * Set the slider thumb color. This is the part of the slider between
     * the range resize buttons.
     * @@param thumbColor the slider thumb color
d233 2
a234 2
     * Get the BoundedRangeModel backing this slider.
     * @@return the slider's range model
a239 4
    /**
     * Set the BoundedRangeModel backing this slider.
     * @@param brm the slider range model to use
     */
a248 1
     * @@param cl the ChangeListener to add
a256 1
     * @@param cl the ChangeListener to remove
a261 3
    /**
     * Fire a change event to all listeners.
     */
a270 3
    /**
     * @@see java.awt.Component#getPreferredSize()
     */
d280 3
a282 2
    // ------------------------------------------------------------------------
    // Rendering
d285 1
a285 4
     * Override this method to perform custom painting of the slider trough.
     * @@param g a Graphics2D context for rendering
     * @@param width the width of the slider trough
     * @@param height the height of the slider trough
a291 3
    /**
     * @@see javax.swing.JComponent#paintComponent(java.awt.Graphics)
     */
d409 4
a412 7
     * This draws an arrow as a series of lines within the specified box.
     * The last boolean specifies whether the point should be at the 
     * right/bottom or left/top. 
     */
    protected void paintArrow(Graphics2D g2, double x, double y, int w, int h,
                              boolean topDown)
    {
d453 1
a453 3
    protected void paint3DRectLighting(Graphics2D g2, int x, int y,
                                       int width, int height)
    {
d465 1
a465 3
    /**
     * Converts from screen coordinates to a range value.
     */
d490 1
a490 3
    /**
     * Converts from a range value to screen coordinates.
     */
d517 1
a517 3
    /**
     * Converts from a range value to screen coordinates.
     */
d545 3
a547 2
    // ------------------------------------------------------------------------
    // Event Handling
a588 3
    /**
     * @@see java.awt.event.MouseListener#mousePressed(java.awt.event.MouseEvent)
     */
a604 3
    /**
     * @@see java.awt.event.MouseMotionListener#mouseDragged(java.awt.event.MouseEvent)
     */
a659 3
    /**
     * @@see java.awt.event.MouseListener#mouseReleased(java.awt.event.MouseEvent)
     */
a664 3
    /**
     * @@see java.awt.event.MouseMotionListener#mouseMoved(java.awt.event.MouseEvent)
     */
a699 3
    /**
     * @@see java.awt.event.MouseListener#mouseClicked(java.awt.event.MouseEvent)
     */
a701 3
    /**
     * @@see java.awt.event.MouseListener#mouseEntered(java.awt.event.MouseEvent)
     */
a703 3
    /**
     * @@see java.awt.event.MouseListener#mouseExited(java.awt.event.MouseEvent)
     */
a712 3
    /**
     * @@see java.awt.event.KeyListener#keyPressed(java.awt.event.KeyEvent)
     */
a745 3
    /**
     * @@see java.awt.event.KeyListener#keyReleased(java.awt.event.KeyEvent)
     */
a747 3
    /**
     * @@see java.awt.event.KeyListener#keyTyped(java.awt.event.KeyEvent)
     */
d751 53
a803 1
} // end of class JRangeSlider
@


