head	2.4;
access;
symbols
	java_1_5:2.4.0.4
	Root_java_1_5:2.4
	beta:2.4.0.2
	beta-20080113:2.4
	beta-20071021:2.4
	beta-20060220:2.0
	beta-20060209:2.0;
locks; strict;
comment	@# @;


2.4
date	2006.07.15.19.48.47;	author jheer;	state Exp;
branches
	2.4.4.1;
next	2.3;

2.3
date	2006.04.05.17.06.22;	author jheer;	state Exp;
branches;
next	2.2;

2.2
date	2006.03.24.17.38.01;	author jheer;	state Exp;
branches;
next	2.1;

2.1
date	2006.03.22.16.32.38;	author jheer;	state Exp;
branches;
next	2.0;

2.0
date	2006.02.12.18.23.43;	author jheer;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.27.09.05.18;	author jheer;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2006.01.27.09.05.18;	author jheer;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2006.02.01.19.22.02;	author jheer;	state Exp;
branches;
next	;

2.4.4.1
date	2008.01.23.23.55.38;	author jogiles;	state Exp;
branches;
next	2.4.4.2;

2.4.4.2
date	2008.03.03.06.17.47;	author amarsden;	state Exp;
branches;
next	;


desc
@@


2.4
log
@Added support for different orientations to AxisLabelLayout
@
text
@package prefuse.action.layout;

import java.awt.geom.Rectangle2D;
import java.text.NumberFormat;
import java.util.Iterator;
import java.util.logging.Logger;

import prefuse.Constants;
import prefuse.data.Schema;
import prefuse.data.query.ObjectRangeModel;
import prefuse.data.tuple.TupleSet;
import prefuse.data.util.Index;
import prefuse.util.MathLib;
import prefuse.util.PrefuseLib;
import prefuse.util.ui.ValuedRangeModel;
import prefuse.visual.VisualItem;
import prefuse.visual.VisualTable;

/**
 * Layout Action that positions axis grid lines and labels for a given
 * range model.
 * 
 * @@author <a href="http://jheer.org">jeffrey heer</a>
 */
public class AxisLabelLayout extends Layout {

    public static final String FRAC = "frac";
    public static final String LABEL = "_label";
    public static final String VALUE = "_value";
    
    private AxisLayout m_layout; // pointer to matching layout, if any
    private ValuedRangeModel m_model;
    private double m_lo, m_hi, m_prevlo, m_prevhi;
    
    private NumberFormat m_nf = NumberFormat.getInstance();
    private int m_axis;
    private boolean m_asc = true;
    private int m_scale = Constants.LINEAR_SCALE;
    
    private double m_spacing; // desired spacing between axis labels
    
    /**
     * Create a new AxisLabelLayout layout.
     * @@param group the data group of the axis lines and labels
     * @@param axis the axis type, either {@@link prefuse.Constants#X_AXIS}
     * or {@@link prefuse.Constants#Y_AXIS}.
     * @@param values the range model that defines the span of the axis
     */
    public AxisLabelLayout(String group, int axis, ValuedRangeModel values)
    {
        this(group, axis, values, null);
    }
    
    /**
     * Create a new AxisLabelLayout layout.
     * @@param group the data group of the axis lines and labels
     * @@param axis the axis type, either {@@link prefuse.Constants#X_AXIS}
     * or {@@link prefuse.Constants#Y_AXIS}.
     * @@param values the range model that defines the span of the axis
     * @@param bounds the layout bounds within which to place the axis marks
     */
    public AxisLabelLayout(String group, int axis, ValuedRangeModel values,
            Rectangle2D bounds)
    {
        super(group);
        if ( bounds != null )
            setLayoutBounds(bounds);
        m_model = values;
        m_axis = axis;
        m_spacing = 50;
    }
    
    /**
     * Create a new AxisLabelLayout layout.
     * @@param group the data group of the axis lines and labels
     * @@param layout an {@@link AxisLayout} instance to model this layout after.
     * The axis type and range model of the provided instance will be used.
     */
    public AxisLabelLayout(String group, AxisLayout layout) {
        this(group, layout, null, 50);
    }
    
    /**
     * Create a new AxisLabelLayout layout.
     * @@param group the data group of the axis lines and labels
     * @@param layout an {@@link AxisLayout} instance to model this layout after.
     * The axis type and range model of the provided instance will be used.
     * @@param bounds the layout bounds within which to place the axis marks
     */
    public AxisLabelLayout(String group, AxisLayout layout, Rectangle2D bounds) {
        this(group, layout, bounds, 50);
    }

    /**
     * Create a new AxisLabelLayout layout.
     * @@param group the data group of the axis lines and labels
     * @@param layout an {@@link AxisLayout} instance to model this layout after.
     * The axis type and range model of the provided instance will be used.
     * @@param bounds the layout bounds within which to place the axis marks
     * @@param spacing the minimum spacing between axis labels
     */
    public AxisLabelLayout(String group, AxisLayout layout, Rectangle2D bounds,
            double spacing)
    {
        super(group);
        if ( bounds != null )
            setLayoutBounds(bounds);
        m_layout = layout;
        m_model = layout.getRangeModel();
        m_axis = layout.getAxis();
        m_scale = layout.getScale();
        m_spacing = spacing;
    }
    
    // ------------------------------------------------------------------------
    
    /**
     * Get the formatter used to format labels for numerical values.
     * @@return the <code>NumberFormat</code> used to format numerical labels.
     */
    public NumberFormat getNumberFormat() {
        return m_nf;
    }

    /**
     * Set the formatter used to format labels for numerical values.
     * @@param nf the <code>NumberFormat</code> used to format numerical labels.
     */
    public void setNumberFormat(NumberFormat nf) {
        m_nf = nf;
    }
    
    /**
     * Get the required minimum spacing between axis labels.
     * @@return the axis label spacing
     */
    public double getSpacing() {
        return m_spacing;
    }

    /**
     * Set the required minimum spacing between axis labels.
     * @@param spacing the axis label spacing to use
     */
    public void setSpacing(double spacing) {
        m_spacing = spacing;
    }
    
    /**
     * Returns the scale type used for the axis. This setting only applies
     * for numerical data types (i.e., when axis values are from a
     * <code>NumberValuedRange</code>).
     * @@return the scale type. One of
     * {@@link prefuse.Constants#LINEAR_SCALE}, 
     * {@@link prefuse.Constants#SQRT_SCALE}, or
     * {@@link Constants#LOG_SCALE}.
     */
    public int getScale() {
        return m_scale;
    }
    
    /**
     * Sets the scale type used for the axis. This setting only applies
     * for numerical data types (i.e., when axis values are from a
     * <code>NumberValuedRange</code>).
     * @@param scale the scale type. One of
     * {@@link prefuse.Constants#LINEAR_SCALE}, 
     * {@@link prefuse.Constants#SQRT_SCALE}, or
     * {@@link Constants#LOG_SCALE}.
     */
    public void setScale(int scale) {
        if ( scale < 0 || scale >= Constants.SCALE_COUNT ) {
            throw new IllegalArgumentException(
                "Unrecognized scale type: "+scale);
        }
        m_scale = scale;
    }
    
    /**
     * Indicates if the axis values should be presented in ascending order
     * along the axis.
     * @@return true if data values increase as pixel coordinates increase,
     * false if data values decrease as pixel coordinates increase.
     */
    public boolean isAscending() {
        return m_asc;
    }
    
    /**
     * Sets if the axis values should be presented in ascending order
     * along the axis.
     * @@param asc true if data values should increase as pixel coordinates
     * increase, false if data values should decrease as pixel coordinates
     * increase.
     */
    public void setAscending(boolean asc) {
        m_asc = asc;
    }
    
    /**
     * Sets the range model used to layout this axis.
     * @@param model the range model
     */
    public void setRangeModel(ValuedRangeModel model) {
        m_model = model;
    }
    
    // ------------------------------------------------------------------------
    
    /**
     * @@see prefuse.action.GroupAction#run(double)
     */
    public void run(double frac) {
        if ( m_model == null && m_layout != null )
            m_model = m_layout.getRangeModel();
        
        if ( m_model == null ) {
            Logger.getLogger(this.getClass().getName())
                .warning("Axis labels missing a range model.");
            return;
        }
        
        VisualTable labels = getTable();
        
        // check the axis label group to see if we can get a
        // more precise reading of the previous scale
        Double dfrac = (Double)labels.getClientProperty(FRAC);
        double fr = dfrac==null ? 1.0 : dfrac.doubleValue();
        m_prevlo = m_prevlo + fr*(m_lo-m_prevlo);
        m_prevhi = m_prevhi + fr*(m_hi-m_prevhi);
        
        // now compute the layout
        if ( m_model instanceof ObjectRangeModel )
        {   // ordinal layout
            // get the current high and low values
            m_lo = m_model.getValue();
            m_hi = m_lo + m_model.getExtent();
            
            // compute the layout
            ordinalLayout(labels);
        }
        else
        {   // numerical layout   
            // get the current high and low values
            m_lo = ((Number)m_model.getLowValue()).doubleValue();
            m_hi = ((Number)m_model.getHighValue()).doubleValue();
            
            // compute the layout
            switch ( m_scale ) {
            case Constants.LOG_SCALE:
                logLayout(labels);
                break;
            case Constants.SQRT_SCALE:
                sqrtLayout(labels);
                break;
            case Constants.LINEAR_SCALE:
            default:
                linearLayout(labels);
            }
        }
        
        // get rid of any labels that are no longer being used
        garbageCollect(labels);
    }
    
    // ------------------------------------------------------------------------
    // Quantitative Axis Layout

    /**
     * Calculates a quantitative, linearly scaled layout.
     */
    protected void linearLayout(VisualTable labels) {
        Rectangle2D b = getLayoutBounds();
        double breadth = getBreadth(b);
        
        double span = m_hi-m_lo;
        double pspan = m_prevhi-m_prevlo;
        double vlo = 0;
        if ( m_lo >= 0 ) {
            vlo = Math.pow(10, Math.floor(MathLib.log10(m_lo)));
        } else {
            vlo = -Math.pow(10, 1+Math.floor(MathLib.log10(-m_lo)));
        }
        //if ( vlo == 10 || vlo == 1 || vlo == 0.1 ) vlo = 0;
        
        // mark previously visible labels
        Iterator iter = labels.tuples();
        while ( iter.hasNext() ) {
            VisualItem item = (VisualItem)iter.next();
            reset(item);
            double v = item.getDouble(VALUE);
            double x = span==0 ? 0 : ((v-m_lo)/span)*breadth;
            set(item, x, b);
        }

        Index index = labels.index(VALUE);
        double step = getLinearStep(span, span==0 ? 0 : breadth/span);
        if ( step == 0 ) step = 1;
        int r;

        for ( double x, v=vlo; v<=m_hi; v+=step ) {
            x = ((v-m_lo)/span)*breadth;
            if ( x < -0.5 ) {
                continue;
            } else if ( (r=index.get(v)) >= 0 ) {
                VisualItem item = labels.getItem(r);
                item.setVisible(true);
                item.setEndVisible(true);
            } else {
                VisualItem item = labels.addItem();
                item.set(LABEL, m_nf.format(v));
                item.setDouble(VALUE, v);
                double f = pspan==0 ? 0 : ((v-m_prevlo)/pspan);
                if ( f <= 0 || f >= 1.0 ) item.setStartVisible(true);
                set(item, f*breadth, b);
                set(item, x, b);
            }
        }
    }
    
    /**
     * Calculates a quantitative, square root scaled layout.
     */
    protected void sqrtLayout(VisualTable labels) {
        Rectangle2D b = getLayoutBounds();
        double breadth = getBreadth(b);
        
        double span = m_hi-m_lo;
        double splo = MathLib.safeSqrt(m_prevlo);
        double spspan = MathLib.safeSqrt(m_prevhi)-splo;
        double vlo = Math.pow(10, Math.floor(MathLib.safeLog10(m_lo)));
        double slo = MathLib.safeSqrt(m_lo);
        double sspan = MathLib.safeSqrt(m_hi)-slo;
        
        // mark previously visible labels
        Iterator iter = labels.tuples();
        while ( iter.hasNext() ) {
            VisualItem item = (VisualItem)iter.next();
            reset(item);
            double v = item.getDouble(VALUE);
            double x = span==0 ? 0 : ((MathLib.safeSqrt(v)-slo)/sspan)*breadth;
            set(item, x, b);
        }
        
        Index index = labels.index(VALUE);
        double step = getLinearStep(span, breadth/span);
        if ( step == 0 ) step = 1;
        int r;
        for ( double x, v=vlo; v<=m_hi; v+=step ) {
            x = ((MathLib.safeSqrt(v)-slo)/sspan)*breadth;
            if ( x < -0.5 ) {
                continue;
            } else if ( (r=index.get(v)) >= 0 ) {
                VisualItem item = labels.getItem(r);
                item.setVisible(true);
                item.setEndVisible(true);
            } else {
                VisualItem item = labels.addItem();
                item.set(LABEL, m_nf.format(v));
                item.setDouble(VALUE, v);
                double f = spspan==0 ? 0 : ((MathLib.safeSqrt(v)-splo)/spspan);
                if ( f <= 0 || f >= 1.0 ) {
                    item.setStartVisible(true);
                }
                set(item, f*breadth, b);
                set(item, x, b);
            }
        }
    }
    
    /**
     * Calculates a quantitative, logarithmically-scaled layout.
     * TODO: This method is currently not working correctly.
     */
    protected void logLayout(VisualTable labels) {
        Rectangle2D b = getLayoutBounds();
        double breadth = getBreadth(b);
        
        labels.clear();
        
        // get span in log space
        // get log of the difference
        // if [0.1,1) round to .1's 0.1-->0.1
        // if [1,10) round to 1's  1-->1
        // if [10,100) round to 10's 10-->10
        double llo = MathLib.safeLog10(m_lo);
        double lhi = MathLib.safeLog10(m_hi);
        double lspan = lhi - llo;
        
        double d = MathLib.log10(lhi-llo);
        int e = (int)Math.floor(d);
        int ilo = (int)Math.floor(llo);
        int ihi = (int)Math.ceil(lhi);
        
        double start = Math.pow(10,ilo);
        double end = Math.pow(10, ihi);
        double step = start * Math.pow(10, e);
        //System.out.println((hi-lo)+"\t"+e+"\t"+start+"\t"+end+"\t"+step);

        // TODO: catch infinity case if diff is zero
        // figure out label cases better
        for ( double val, v=start, i=0; v<=end; v+=step, ++i ) {
            val = MathLib.safeLog10(v);
            if ( i != 0 && Math.abs(val-Math.round(val)) < 0.0001 ) {
                i = 0;
                step = 10*step;
            }
            val = ((val-llo)/lspan)*breadth;
            if ( val < -0.5 ) continue;
            
            VisualItem item = labels.addItem();
            set(item, val, b);
            String label = i==0 ? m_nf.format(v) : null;
            item.set(LABEL, label);
            item.setDouble(VALUE, v);
        }
    }
    
    /**
     * Get the "breadth" of a rectangle, based on the axis type.
     */
    protected double getBreadth(Rectangle2D b) {
        switch ( m_axis ) {
        case Constants.X_AXIS:
            return b.getWidth();
        default:
            return b.getHeight();
        }
    }
    
    /**
     * Adjust a value according to the current scale type.
     */
    protected double adjust(double v) {
        switch ( m_scale ) {
        case Constants.LOG_SCALE:
            return Math.pow(10,v);
        case Constants.SQRT_SCALE:
            return v*v;
        case Constants.LINEAR_SCALE:
        default:
            return v;
        }
    }
    
    /**
     * Compute a linear step between axis marks.
     */
    protected double getLinearStep(double span, double scale) {
        double log10 = Math.log(span)/Math.log(10);
        double step = Math.pow(10, Math.floor(log10));
        
        double delta = step * scale / m_spacing;
        if (delta > 20) {
            step /= 20;
        } else if (delta > 10) {
            step /= 10;
        } else if (delta > 5) {
            step /= 5;
        } else if (delta > 4) {
            step /= 4;
        } else if (delta > 2) {
            step /= 2;
        } else if (delta < 1) {
            step *= 2;
        }
        return step;
    }
    
    // ------------------------------------------------------------------------
    // Ordinal Axis Layout
    
    /**
     * Compute an ordinal layout of axis marks.
     */
    protected void ordinalLayout(VisualTable labels) {
        ObjectRangeModel model = (ObjectRangeModel)m_model;
        double span = m_hi-m_lo;
        double pspan = m_prevhi-m_prevlo;
        
        Rectangle2D b = getLayoutBounds();
        double breadth = getBreadth(b);
        double scale = breadth/span;
        int step = getOrdinalStep(span, scale);
        if ( step <= 0 ) step = 1;
        
        // mark previously visible labels
        Iterator iter = labels.tuples();
        while ( iter.hasNext() ) {
            VisualItem item = (VisualItem)iter.next();
            reset(item);
            double v = item.getDouble(VALUE);
            double x = span==0 ? 0 : ((v-m_lo)/span)*breadth;
            set(item, x, b);
        }

        Index index = labels.index(VALUE);
        
        // handle remaining labels
        for ( int r, v=(int)m_lo; v<=m_hi; v+=step ) {
            if ( (r=index.get((double)v)) >= 0 ) {
                VisualItem item = labels.getItem(r);
                item.set(VisualItem.LABEL, model.getObject(v).toString());
                item.setVisible(true);
                item.setEndVisible(true);
            } else {
                VisualItem item = labels.addItem();
                item.set(VisualItem.LABEL, model.getObject(v).toString());
                item.setDouble(VisualItem.VALUE, v);
                double f = pspan==0 ? 0 : ((v-m_prevlo)/pspan);
                if ( f <= 0 || f >= 1.0 ) item.setStartVisible(true);
                set(item, f*breadth, b);
                set(item, (v-m_lo)*breadth/span, b);
            }
        }
    }
    
    /**
     * Compute an ordinal step between axis marks.
     */
    protected int getOrdinalStep(double span, double scale) {
        return (scale >= m_spacing ? 1 : (int)Math.ceil(m_spacing/scale));
    }
    
    // ------------------------------------------------------------------------
    // Auxiliary methods
    
    /**
     * Set the layout values for an axis label item.
     */
    protected void set(VisualItem item, double xOrY, Rectangle2D b) {
        switch ( m_axis ) {
        case Constants.X_AXIS:
            xOrY = m_asc ? xOrY + b.getMinX() : b.getMaxX() - xOrY;
            PrefuseLib.updateDouble(item, VisualItem.X,  xOrY);
            PrefuseLib.updateDouble(item, VisualItem.Y,  b.getMinY());
            PrefuseLib.updateDouble(item, VisualItem.X2, xOrY);
            PrefuseLib.updateDouble(item, VisualItem.Y2, b.getMaxY());
            break;
        case Constants.Y_AXIS:
            xOrY = m_asc ? b.getMaxY() - xOrY - 1 : xOrY + b.getMinY();
            PrefuseLib.updateDouble(item, VisualItem.X,  b.getMinX());
            PrefuseLib.updateDouble(item, VisualItem.Y,  xOrY);
            PrefuseLib.updateDouble(item, VisualItem.X2, b.getMaxX());
            PrefuseLib.updateDouble(item, VisualItem.Y2, xOrY);
        }
    }
    
    /**
     * Reset an axis label VisualItem
     */
    protected void reset(VisualItem item) {
        item.setVisible(false);
        item.setEndVisible(false);
        item.setStartStrokeColor(item.getStrokeColor());
        item.revertToDefault(VisualItem.STROKECOLOR);
        item.revertToDefault(VisualItem.ENDSTROKECOLOR);
        item.setStartTextColor(item.getTextColor());
        item.revertToDefault(VisualItem.TEXTCOLOR);
        item.revertToDefault(VisualItem.ENDTEXTCOLOR);
        item.setStartFillColor(item.getFillColor());
        item.revertToDefault(VisualItem.FILLCOLOR);
        item.revertToDefault(VisualItem.ENDFILLCOLOR);
    }
    
    /**
     * Remove axis labels no longer being used.
     */
    protected void garbageCollect(VisualTable labels) {
        Iterator iter = labels.tuples();
        while ( iter.hasNext() ) {
            VisualItem item = (VisualItem)iter.next();
            if ( !item.isStartVisible() && !item.isEndVisible() ) {
                labels.removeTuple(item);
            }
        }
    }
    
    /**
     * Create a new table for representing axis labels.
     */
    protected VisualTable getTable() {
        TupleSet ts = m_vis.getGroup(m_group);
        if ( ts == null ) {
            Schema s = PrefuseLib.getAxisLabelSchema();
            VisualTable vt = m_vis.addTable(m_group, s);
            vt.index(VALUE);
            return vt;
        } else if ( ts instanceof VisualTable ) {
            return (VisualTable)ts;
        } else {
            throw new IllegalStateException(
                "Group already exists, not being used for labels");
        }
    }
    
} // end of class AxisLabels
@


2.4.4.1
log
@First import of a Java 1.5-targetted version of prefuse.
@
text
@d5 1
d8 1
a14 1
import prefuse.util.Scale;
d22 1
a22 1
 *
d30 1
a30 1

d34 1
a34 1

d36 1
a36 1
    private final Axis m_axis;
d38 2
a39 2
    private Scale m_scale = Scale.LINEAR;

d41 1
a41 1

d45 2
a46 1
     * @@param axis the axis type
d49 1
a49 1
    public AxisLabelLayout(String group, Axis axis, ValuedRangeModel values)
d53 1
a53 1

d57 2
a58 1
     * @@param axis the axis type
d62 1
a62 1
    public AxisLabelLayout(String group, Axis axis, ValuedRangeModel values,
d66 2
a67 3
        if ( bounds != null ) {
			setLayoutBounds(bounds);
		}
d72 1
a72 1

d82 1
a82 1

d106 2
a107 3
        if ( bounds != null ) {
			setLayoutBounds(bounds);
		}
d114 1
a114 1

d116 1
a116 1

d132 1
a132 1

d148 1
a148 1

d154 3
a156 3
     * {@@link Scale#LINEAR},
     * {@@link Scale#SQRT}, or
     * {@@link Scale#LOG}.
d158 1
a158 1
    public Scale getScale() {
d161 1
a161 1

d167 9
a175 5
     * {@@link Scale#LINEAR},
     * {@@link Scale#SQRT}, or
     * {@@link Scale#LOG}.
     */
    public void setScale(Scale scale) {
d178 1
a178 1

d188 1
a188 1

d199 1
a199 1

d207 1
a207 1

d209 1
a209 1

d213 4
a216 6
    @@Override
	public void run(double frac) {
        if ( m_model == null && m_layout != null ) {
			m_model = m_layout.getRangeModel();
		}

d222 3
a224 3

        VisualTable<?,? extends VisualItem<?>> labels = getTable();

d231 1
a231 1

d238 1
a238 1

d243 1
a243 1
        {   // numerical layout
d247 1
a247 1

d250 1
a250 1
            case LOG:
d253 1
a253 1
            case SQRT:
d256 1
a256 1
            case LINEAR:
d261 1
a261 1

d265 1
a265 1

d272 1
a272 1
    protected void linearLayout(VisualTable<?,? extends VisualItem<?>> labels) {
d275 1
a275 1

d285 1
a285 1

d287 3
a289 1
        for(VisualItem<?> item : labels.tuples()) {
d292 1
a292 1
            double x = span==0 ? 0 : (v-m_lo)/span*breadth;
d298 1
a298 3
        if ( step == 0 ) {
			step = 1;
		}
d302 1
a302 1
            x = (v-m_lo)/span*breadth;
d306 1
a306 1
                VisualItem<?> item = labels.getItem(r);
d310 1
a310 1
                VisualItem<?> item = labels.addItem();
d313 2
a314 4
                double f = pspan==0 ? 0 : (v-m_prevlo)/pspan;
                if ( f <= 0 || f >= 1.0 ) {
					item.setStartVisible(true);
				}
d320 1
a320 1

d324 1
a324 1
    protected void sqrtLayout(VisualTable<?,? extends VisualItem<?>> labels) {
d327 1
a327 1

d334 1
a334 1

d336 3
a338 1
        for(VisualItem<?> item : labels.tuples()) {
d341 1
a341 1
            double x = span==0 ? 0 : (MathLib.safeSqrt(v)-slo)/sspan*breadth;
d344 1
a344 1

d347 1
a347 3
        if ( step == 0 ) {
			step = 1;
		}
d350 1
a350 1
            x = (MathLib.safeSqrt(v)-slo)/sspan*breadth;
d354 1
a354 1
                VisualItem<?> item = labels.getItem(r);
d358 1
a358 1
                VisualItem<?> item = labels.addItem();
d361 1
a361 1
                double f = spspan==0 ? 0 : (MathLib.safeSqrt(v)-splo)/spspan;
d370 1
a370 1

d375 1
a375 1
    protected void logLayout(VisualTable<?,? extends VisualItem<?>> labels) {
d378 1
a378 1

d380 1
a380 1

d389 1
a389 1

d394 1
a394 1

d408 4
a411 6
            val = (val-llo)/lspan*breadth;
            if ( val < -0.5 ) {
				continue;
			}

            VisualItem<?> item = labels.addItem();
d418 1
a418 1

d424 1
a424 1
        case X:
d426 1
a426 2
        case Y:
       	default:
d430 1
a430 1

d436 1
a436 1
        case LOG:
d438 1
a438 1
        case SQRT:
d440 1
a440 1
        case LINEAR:
d445 1
a445 1

d452 1
a452 1

d469 1
a469 1

d472 1
a472 1

d476 1
a476 1
    protected void ordinalLayout(VisualTable<?,? extends VisualItem<?>> labels) {
d480 1
a480 1

d485 2
a486 4
        if ( step <= 0 ) {
			step = 1;
		}

d488 3
a490 1
        for(VisualItem<?> item : labels.tuples()) {
d493 1
a493 1
            double x = span==0 ? 0 : (v-m_lo)/span*breadth;
d498 1
a498 1

d502 1
a502 1
                VisualItem<?> item = labels.getItem(r);
d507 1
a507 1
                VisualItem<?> item = labels.addItem();
d510 2
a511 4
                double f = pspan==0 ? 0 : (v-m_prevlo)/pspan;
                if ( f <= 0 || f >= 1.0 ) {
					item.setStartVisible(true);
				}
d517 1
a517 1

d522 1
a522 1
        return scale >= m_spacing ? 1 : (int)Math.ceil(m_spacing/scale);
d524 1
a524 1

d527 1
a527 1

d531 1
a531 1
    protected void set(VisualItem<?> item, double xOrY, Rectangle2D b) {
d533 1
a533 1
        case X:
d540 1
a540 1
        case Y:
d548 1
a548 1

d552 1
a552 1
    protected void reset(VisualItem<?> item) {
d565 1
a565 1

d569 4
a572 2
    protected void garbageCollect(VisualTable<?,? extends VisualItem<?>> labels) {
        for(VisualItem<?> item : labels.tuples()) {
d578 1
a578 1

d582 2
a583 2
    protected VisualTable<?,? extends VisualItem<?>> getTable() {
        TupleSet<? extends VisualItem<?>> ts = m_vis.getGroup(m_group);
d586 1
a586 1
            VisualTable<?,? extends VisualItem<?>> vt = m_vis.addTable(m_group, s);
d590 1
a590 1
            return (VisualTable<?,? extends VisualItem<?>>)ts;
d596 1
a596 1

@


2.4.4.2
log
@Removed MathLib.log10()
@
text
@d277 1
a277 1
            vlo = Math.pow(10, Math.floor(Math.log10(m_lo)));
d279 1
a279 1
            vlo = -Math.pow(10, 1+Math.floor(Math.log10(-m_lo)));
d389 1
a389 1
        double d = Math.log10(lhi-llo);
@


2.3
log
@Can now update the axis range model
@
text
@d37 1
d180 21
d297 1
a297 1
        double step = getLinearStep(span, breadth/span);
d300 1
d534 1
a534 1
            xOrY += b.getMinX();
d541 1
a541 1
            xOrY = b.getMaxY() - xOrY - 1;
@


2.2
log
@Made axis label layout more responsive to spacing parameter
@
text
@d178 8
d256 7
a262 2
        double vlo = Math.pow(10, Math.floor(MathLib.safeLog10(m_lo)));
        if ( vlo == 1 || vlo == 0.1 ) vlo = 0;
@


2.1
log
@Added new constructor, fixed bounds handling
@
text
@d69 1
a69 1
        m_spacing = 25;
d79 1
a79 1
        this(group, layout, null, 25);
d90 1
a90 1
        this(group, layout, bounds, 25);
d249 1
d417 2
a418 2
        double delta = step * scale;
        if (delta > 1000) {
d420 1
a420 1
        } else if (delta > 500) {
d422 1
a422 1
        } else if (delta > 250) {
d424 1
a424 1
        } else if (delta > 200) {
d426 1
a426 1
        } else if (delta > 100) {
d428 2
@


2.0
log
@Merge beta branch back onto main trunk
@
text
@d66 1
a66 1
            super.setLayoutBounds(bounds);
d77 10
d105 2
a106 1
        super.setLayoutBounds(bounds);
@


1.1
log
@file AxisLabelLayout.java was initially added on branch beta.
@
text
@d1 547
@


1.1.2.1
log
@Lots of javadoc
@
text
@a0 547
package prefuse.action.layout;

import java.awt.geom.Rectangle2D;
import java.text.NumberFormat;
import java.util.Iterator;
import java.util.logging.Logger;

import prefuse.Constants;
import prefuse.data.Schema;
import prefuse.data.index.Index;
import prefuse.data.query.ObjectRangeModel;
import prefuse.data.tuple.TupleSet;
import prefuse.util.MathLib;
import prefuse.util.PrefuseLib;
import prefuse.util.ui.ValuedRangeModel;
import prefuse.visual.VisualItem;
import prefuse.visual.VisualTable;

/**
 * Layout Action that positions axis grid lines and labels for a given
 * range model.
 * 
 * @@author <a href="http://jheer.org">jeffrey heer</a>
 */
public class AxisLabelLayout extends Layout {

    public static final String FRAC = "frac";
    public static final String LABEL = "_label";
    public static final String VALUE = "_value";
    
    private AxisLayout m_layout; // pointer to matching layout, if any
    private ValuedRangeModel m_model;
    private double m_lo, m_hi, m_prevlo, m_prevhi;
    
    private NumberFormat m_nf = NumberFormat.getInstance();
    private int m_axis;
    private int m_scale = Constants.LINEAR_SCALE;
    
    private double m_spacing; // desired spacing between axis labels
    
    /**
     * Create a new AxisLabelLayout layout.
     * @@param group the data group of the axis lines and labels
     * @@param axis the axis type, either {@@link prefuse.Constants#X_AXIS}
     * or {@@link prefuse.Constants#Y_AXIS}.
     * @@param values the range model that defines the span of the axis
     */
    public AxisLabelLayout(String group, int axis, ValuedRangeModel values)
    {
        this(group, axis, values, null);
    }
    
    /**
     * Create a new AxisLabelLayout layout.
     * @@param group the data group of the axis lines and labels
     * @@param axis the axis type, either {@@link prefuse.Constants#X_AXIS}
     * or {@@link prefuse.Constants#Y_AXIS}.
     * @@param values the range model that defines the span of the axis
     * @@params the layout bounds within which to place the axis marks
     */
    public AxisLabelLayout(String group, int axis, ValuedRangeModel values,
            Rectangle2D bounds)
    {
        super(group);
        if ( bounds != null )
            super.setLayoutBounds(bounds);
        m_model = values;
        m_axis = axis;
        m_spacing = 25;
    }
    
    /**
     * Create a new AxisLabelLayout layout.
     * @@param group the data group of the axis lines and labels
     * @@param layout an {@@link AxisLayout} instance to model this layout after.
     * The axis type and range model of the provided instance will be used.
     * @@params the layout bounds within which to place the axis marks
     */
    public AxisLabelLayout(String group, AxisLayout layout, Rectangle2D bounds) {
        this(group, layout, bounds, 25);
    }

    /**
     * Create a new AxisLabelLayout layout.
     * @@param group the data group of the axis lines and labels
     * @@param layout an {@@link AxisLayout} instance to model this layout after.
     * The axis type and range model of the provided instance will be used.
     * @@params the layout bounds within which to place the axis marks
     * @@params spacing the minimum spacing between axis labels
     */
    public AxisLabelLayout(String group, AxisLayout layout, Rectangle2D bounds,
            double spacing)
    {
        super(group);
        super.setLayoutBounds(bounds);
        m_layout = layout;
        m_model = layout.getRangeModel();
        m_axis = layout.getAxis();
        m_scale = layout.getScale();
        m_spacing = spacing;
    }
    
    // ------------------------------------------------------------------------
    
    /**
     * Get the formatter used to format labels for numerical values.
     * @@return the <code>NumberFormat</code> used to format numerical labels.
     */
    public NumberFormat getNumberFormat() {
        return m_nf;
    }

    /**
     * Set the formatter used to format labels for numerical values.
     * @@param nf the <code>NumberFormat</code> used to format numerical labels.
     */
    public void setNumberFormat(NumberFormat nf) {
        m_nf = nf;
    }
    
    /**
     * Get the required minimum spacing between axis labels.
     * @@return the axis label spacing
     */
    public double getSpacing() {
        return m_spacing;
    }

    /**
     * Set the required minimum spacing between axis labels.
     * @@param spacing the axis label spacing to use
     */
    public void setSpacing(double spacing) {
        m_spacing = spacing;
    }
    
    /**
     * Returns the scale type used for the axis. This setting only applies
     * for numerical data types (i.e., when axis values are from a
     * <code>NumberValuedRange</code>).
     * @@return the scale type. One of
     * {@@link prefuse.Constants.LINEAR_SCALE}, 
     * {@@link prefuse.Constants.SQRT_SCALE}, or
     * {@@link Constants.LOG_SCALE}.
     */
    public int getScale() {
        return m_scale;
    }
    
    /**
     * Sets the scale type used for the axis. This setting only applies
     * for numerical data types (i.e., when axis values are from a
     * <code>NumberValuedRange</code>).
     * @@param scale the scale type. One of
     * {@@link prefuse.Constants.LINEAR_SCALE}, 
     * {@@link prefuse.Constants.SQRT_SCALE}, or
     * {@@link Constants.LOG_SCALE}.
     */
    public void setScale(int scale) {
        if ( scale < 0 || scale >= Constants.SCALE_COUNT ) {
            throw new IllegalArgumentException(
                "Unrecognized scale type: "+scale);
        }
        m_scale = scale;
    }
    
    // ------------------------------------------------------------------------
    
    /**
     * @@see prefuse.action.GroupAction#run(double)
     */
    public void run(double frac) {
        if ( m_model == null && m_layout != null )
            m_model = m_layout.getRangeModel();
        
        if ( m_model == null ) {
            Logger.getLogger(this.getClass().getName())
                .warning("Axis labels missing a range model.");
            return;
        }
        
        VisualTable labels = getTable();
        
        // check the axis label group to see if we can get a
        // more precise reading of the previous scale
        Double dfrac = (Double)labels.getClientProperty(FRAC);
        double fr = dfrac==null ? 1.0 : dfrac.doubleValue();
        m_prevlo = m_prevlo + fr*(m_lo-m_prevlo);
        m_prevhi = m_prevhi + fr*(m_hi-m_prevhi);
        
        // now compute the layout
        if ( m_model instanceof ObjectRangeModel )
        {   // ordinal layout
            // get the current high and low values
            m_lo = m_model.getValue();
            m_hi = m_lo + m_model.getExtent();
            
            // compute the layout
            ordinalLayout(labels);
        }
        else
        {   // numerical layout   
            // get the current high and low values
            m_lo = ((Number)m_model.getLowValue()).doubleValue();
            m_hi = ((Number)m_model.getHighValue()).doubleValue();
            
            // compute the layout
            switch ( m_scale ) {
            case Constants.LOG_SCALE:
                logLayout(labels);
                break;
            case Constants.SQRT_SCALE:
                sqrtLayout(labels);
                break;
            case Constants.LINEAR_SCALE:
            default:
                linearLayout(labels);
            }
        }
        
        // get rid of any labels that are no longer being used
        garbageCollect(labels);
    }
    
    // ------------------------------------------------------------------------
    // Quantitative Axis Layout

    /**
     * Calculates a quantitative, linearly scaled layout.
     */
    protected void linearLayout(VisualTable labels) {
        Rectangle2D b = getLayoutBounds();
        double breadth = getBreadth(b);
        
        double span = m_hi-m_lo;
        double pspan = m_prevhi-m_prevlo;
        double vlo = Math.pow(10, Math.floor(MathLib.safeLog10(m_lo)));
        
        // mark previously visible labels
        Iterator iter = labels.tuples();
        while ( iter.hasNext() ) {
            VisualItem item = (VisualItem)iter.next();
            reset(item);
            double v = item.getDouble(VALUE);
            double x = span==0 ? 0 : ((v-m_lo)/span)*breadth;
            set(item, x, b);
        }

        Index index = labels.index(VALUE);
        double step = getLinearStep(span, breadth/span);
        if ( step == 0 ) step = 1;
        int r;
        for ( double x, v=vlo; v<=m_hi; v+=step ) {
            x = ((v-m_lo)/span)*breadth;
            if ( x < -0.5 ) {
                continue;
            } else if ( (r=index.get(v)) >= 0 ) {
                VisualItem item = labels.getItem(r);
                item.setVisible(true);
                item.setEndVisible(true);
            } else {
                VisualItem item = labels.addItem();
                item.set(LABEL, m_nf.format(v));
                item.setDouble(VALUE, v);
                double f = pspan==0 ? 0 : ((v-m_prevlo)/pspan);
                if ( f <= 0 || f >= 1.0 ) item.setStartVisible(true);
                set(item, f*breadth, b);
                set(item, x, b);
            }
        }
    }
    
    /**
     * Calculates a quantitative, square root scaled layout.
     */
    protected void sqrtLayout(VisualTable labels) {
        Rectangle2D b = getLayoutBounds();
        double breadth = getBreadth(b);
        
        double span = m_hi-m_lo;
        double splo = MathLib.safeSqrt(m_prevlo);
        double spspan = MathLib.safeSqrt(m_prevhi)-splo;
        double vlo = Math.pow(10, Math.floor(MathLib.safeLog10(m_lo)));
        double slo = MathLib.safeSqrt(m_lo);
        double sspan = MathLib.safeSqrt(m_hi)-slo;
        
        // mark previously visible labels
        Iterator iter = labels.tuples();
        while ( iter.hasNext() ) {
            VisualItem item = (VisualItem)iter.next();
            reset(item);
            double v = item.getDouble(VALUE);
            double x = span==0 ? 0 : ((MathLib.safeSqrt(v)-slo)/sspan)*breadth;
            set(item, x, b);
        }
        
        Index index = labels.index(VALUE);
        double step = getLinearStep(span, breadth/span);
        if ( step == 0 ) step = 1;
        int r;
        for ( double x, v=vlo; v<=m_hi; v+=step ) {
            x = ((MathLib.safeSqrt(v)-slo)/sspan)*breadth;
            if ( x < -0.5 ) {
                continue;
            } else if ( (r=index.get(v)) >= 0 ) {
                VisualItem item = labels.getItem(r);
                item.setVisible(true);
                item.setEndVisible(true);
            } else {
                VisualItem item = labels.addItem();
                item.set(LABEL, m_nf.format(v));
                item.setDouble(VALUE, v);
                double f = spspan==0 ? 0 : ((MathLib.safeSqrt(v)-splo)/spspan);
                if ( f <= 0 || f >= 1.0 ) {
                    item.setStartVisible(true);
                }
                set(item, f*breadth, b);
                set(item, x, b);
            }
        }
    }
    
    /**
     * Calculates a quantitative, logarithmically-scaled layout.
     * TODO: This method is currently not working correctly.
     */
    protected void logLayout(VisualTable labels) {
        Rectangle2D b = getLayoutBounds();
        double breadth = getBreadth(b);
        
        labels.clear();
        
        // get span in log space
        // get log of the difference
        // if [0.1,1) round to .1's 0.1-->0.1
        // if [1,10) round to 1's  1-->1
        // if [10,100) round to 10's 10-->10
        double llo = MathLib.safeLog10(m_lo);
        double lhi = MathLib.safeLog10(m_hi);
        double lspan = lhi - llo;
        
        double d = MathLib.log10(lhi-llo);
        int e = (int)Math.floor(d);
        int ilo = (int)Math.floor(llo);
        int ihi = (int)Math.ceil(lhi);
        
        double start = Math.pow(10,ilo);
        double end = Math.pow(10, ihi);
        double step = start * Math.pow(10, e);
        //System.out.println((hi-lo)+"\t"+e+"\t"+start+"\t"+end+"\t"+step);

        // TODO: catch infinity case if diff is zero
        // figure out label cases better
        for ( double val, v=start, i=0; v<=end; v+=step, ++i ) {
            val = MathLib.safeLog10(v);
            if ( i != 0 && Math.abs(val-Math.round(val)) < 0.0001 ) {
                i = 0;
                step = 10*step;
            }
            val = ((val-llo)/lspan)*breadth;
            if ( val < -0.5 ) continue;
            
            VisualItem item = labels.addItem();
            set(item, val, b);
            String label = i==0 ? m_nf.format(v) : null;
            item.set(LABEL, label);
            item.setDouble(VALUE, v);
        }
    }
    
    /**
     * Get the "breadth" of a rectangle, based on the axis type.
     */
    protected double getBreadth(Rectangle2D b) {
        switch ( m_axis ) {
        case Constants.X_AXIS:
            return b.getWidth();
        default:
            return b.getHeight();
        }
    }
    
    /**
     * Adjust a value according to the current scale type.
     */
    protected double adjust(double v) {
        switch ( m_scale ) {
        case Constants.LOG_SCALE:
            return Math.pow(10,v);
        case Constants.SQRT_SCALE:
            return v*v;
        case Constants.LINEAR_SCALE:
        default:
            return v;
        }
    }
    
    /**
     * Compute a linear step between axis marks.
     */
    protected double getLinearStep(double span, double scale) {
        double log10 = Math.log(span)/Math.log(10);
        double step = Math.pow(10, Math.floor(log10));
        
        double delta = step * scale;
        if (delta > 1000) {
            step /= 20;
        } else if (delta > 500) {
            step /= 10;
        } else if (delta > 250) {
            step /= 5;
        } else if (delta > 200) {
            step /= 4;
        } else if (delta > 100) {
            step /= 2;
        }
        return step;
    }
    
    // ------------------------------------------------------------------------
    // Ordinal Axis Layout
    
    /**
     * Compute an ordinal layout of axis marks.
     */
    protected void ordinalLayout(VisualTable labels) {
        ObjectRangeModel model = (ObjectRangeModel)m_model;
        double span = m_hi-m_lo;
        double pspan = m_prevhi-m_prevlo;
        
        Rectangle2D b = getLayoutBounds();
        double breadth = getBreadth(b);
        double scale = breadth/span;
        int step = getOrdinalStep(span, scale);
        if ( step <= 0 ) step = 1;
        
        // mark previously visible labels
        Iterator iter = labels.tuples();
        while ( iter.hasNext() ) {
            VisualItem item = (VisualItem)iter.next();
            reset(item);
            double v = item.getDouble(VALUE);
            double x = span==0 ? 0 : ((v-m_lo)/span)*breadth;
            set(item, x, b);
        }

        Index index = labels.index(VALUE);
        
        // handle remaining labels
        for ( int r, v=(int)m_lo; v<=m_hi; v+=step ) {
            if ( (r=index.get((double)v)) >= 0 ) {
                VisualItem item = labels.getItem(r);
                item.set(VisualItem.LABEL, model.getObject(v).toString());
                item.setVisible(true);
                item.setEndVisible(true);
            } else {
                VisualItem item = labels.addItem();
                item.set(VisualItem.LABEL, model.getObject(v).toString());
                item.setDouble(VisualItem.VALUE, v);
                double f = pspan==0 ? 0 : ((v-m_prevlo)/pspan);
                if ( f <= 0 || f >= 1.0 ) item.setStartVisible(true);
                set(item, f*breadth, b);
                set(item, (v-m_lo)*breadth/span, b);
            }
        }
    }
    
    /**
     * Compute an ordinal step between axis marks.
     */
    protected int getOrdinalStep(double span, double scale) {
        return (scale >= m_spacing ? 1 : (int)Math.ceil(m_spacing/scale));
    }
    
    // ------------------------------------------------------------------------
    // Auxiliary methods
    
    /**
     * Set the layout values for an axis label item.
     */
    protected void set(VisualItem item, double xOrY, Rectangle2D b) {
        switch ( m_axis ) {
        case Constants.X_AXIS:
            xOrY += b.getMinX();
            PrefuseLib.updateDouble(item, VisualItem.X,  xOrY);
            PrefuseLib.updateDouble(item, VisualItem.Y,  b.getMinY());
            PrefuseLib.updateDouble(item, VisualItem.X2, xOrY);
            PrefuseLib.updateDouble(item, VisualItem.Y2, b.getMaxY());
            break;
        case Constants.Y_AXIS:
            xOrY = b.getMaxY() - xOrY - 1;
            PrefuseLib.updateDouble(item, VisualItem.X,  b.getMinX());
            PrefuseLib.updateDouble(item, VisualItem.Y,  xOrY);
            PrefuseLib.updateDouble(item, VisualItem.X2, b.getMaxX());
            PrefuseLib.updateDouble(item, VisualItem.Y2, xOrY);
        }
    }
    
    /**
     * Reset an axis label VisualItem
     */
    protected void reset(VisualItem item) {
        item.setVisible(false);
        item.setEndVisible(false);
        item.setStartStrokeColor(item.getStrokeColor());
        item.revertToDefault(VisualItem.STROKECOLOR);
        item.revertToDefault(VisualItem.ENDSTROKECOLOR);
        item.setStartTextColor(item.getTextColor());
        item.revertToDefault(VisualItem.TEXTCOLOR);
        item.revertToDefault(VisualItem.ENDTEXTCOLOR);
        item.setStartFillColor(item.getFillColor());
        item.revertToDefault(VisualItem.FILLCOLOR);
        item.revertToDefault(VisualItem.ENDFILLCOLOR);
    }
    
    /**
     * Remove axis labels no longer being used.
     */
    protected void garbageCollect(VisualTable labels) {
        Iterator iter = labels.tuples();
        while ( iter.hasNext() ) {
            VisualItem item = (VisualItem)iter.next();
            if ( !item.isStartVisible() && !item.isEndVisible() ) {
                labels.removeTuple(item);
            }
        }
    }
    
    /**
     * Create a new table for representing axis labels.
     */
    protected VisualTable getTable() {
        TupleSet ts = m_vis.getGroup(m_group);
        if ( ts == null ) {
            Schema s = PrefuseLib.getAxisLabelSchema();
            VisualTable vt = m_vis.addTable(m_group, s);
            vt.index(VALUE);
            return vt;
        } else if ( ts instanceof VisualTable ) {
            return (VisualTable)ts;
        } else {
            throw new IllegalStateException(
                "Group already exists, not being used for labels");
        }
    }
    
} // end of class AxisLabels
@


1.1.2.2
log
@Javadoc'd.
@
text
@d10 1
a12 1
import prefuse.data.util.Index;
d59 1
a59 1
     * @@param bounds the layout bounds within which to place the axis marks
d77 1
a77 1
     * @@param bounds the layout bounds within which to place the axis marks
d88 2
a89 2
     * @@param bounds the layout bounds within which to place the axis marks
     * @@param spacing the minimum spacing between axis labels
d142 3
a144 3
     * {@@link prefuse.Constants#LINEAR_SCALE}, 
     * {@@link prefuse.Constants#SQRT_SCALE}, or
     * {@@link Constants#LOG_SCALE}.
d155 3
a157 3
     * {@@link prefuse.Constants#LINEAR_SCALE}, 
     * {@@link prefuse.Constants#SQRT_SCALE}, or
     * {@@link Constants#LOG_SCALE}.
@


