head	2.10;
access;
symbols
	java_1_5:2.10.0.4
	Root_java_1_5:2.10
	beta:2.10.0.2
	beta-20080113:2.10
	beta-20071021:2.9
	beta-20060220:2.1
	beta-20060209:2.0;
locks; strict;
comment	@# @;


2.10
date	2008.01.13.22.39.15;	author jheer;	state Exp;
branches
	2.10.4.1;
next	2.9;

2.9
date	2007.10.21.21.36.05;	author jheer;	state Exp;
branches;
next	2.8;

2.8
date	2007.10.21.00.57.59;	author jheer;	state Exp;
branches;
next	2.7;

2.7
date	2006.11.03.20.44.52;	author jheer;	state Exp;
branches;
next	2.6;

2.6
date	2006.04.12.02.27.29;	author jheer;	state Exp;
branches;
next	2.5;

2.5
date	2006.03.24.17.38.21;	author jheer;	state Exp;
branches;
next	2.4;

2.4
date	2006.03.15.04.41.20;	author jheer;	state Exp;
branches;
next	2.3;

2.3
date	2006.03.13.05.47.48;	author jheer;	state Exp;
branches;
next	2.2;

2.2
date	2006.02.22.21.09.54;	author jheer;	state Exp;
branches;
next	2.1;

2.1
date	2006.02.17.18.02.25;	author jheer;	state Exp;
branches;
next	2.0;

2.0
date	2006.02.12.18.23.42;	author jheer;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.30.09.16.20;	author jheer;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2005.12.30.09.16.20;	author jheer;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2006.01.09.23.10.12;	author jheer;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2006.01.16.20.07.42;	author jheer;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2006.01.16.20.14.17;	author jheer;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2006.01.23.23.07.20;	author jheer;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2006.01.27.09.05.20;	author jheer;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2006.02.01.19.22.44;	author jheer;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2006.02.02.19.01.53;	author jheer;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2006.02.07.00.42.53;	author jheer;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2006.02.09.10.33.59;	author jheer;	state Exp;
branches;
next	;

2.10.4.1
date	2008.01.23.23.55.42;	author jogiles;	state Exp;
branches;
next	2.10.4.2;

2.10.4.2
date	2008.02.24.21.17.41;	author amarsden;	state Exp;
branches;
next	2.10.4.3;

2.10.4.3
date	2008.02.28.00.40.29;	author amarsden;	state Exp;
branches;
next	2.10.4.4;

2.10.4.4
date	2008.02.28.01.09.32;	author amarsden;	state Exp;
branches;
next	2.10.4.5;

2.10.4.5
date	2008.04.24.09.41.48;	author amarsden;	state Exp;
branches;
next	2.10.4.6;

2.10.4.6
date	2008.04.24.23.13.57;	author amarsden;	state Exp;
branches;
next	2.10.4.7;

2.10.4.7
date	2008.05.28.06.39.34;	author jogiles;	state Exp;
branches;
next	2.10.4.8;

2.10.4.8
date	2008.07.17.01.03.28;	author jogiles;	state Exp;
branches;
next	;


desc
@@


2.10
log
@Fixed javadoc comments
@
text
@package prefuse;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsEnvironment;
import java.awt.Image;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.io.OutputStream;
import java.util.Iterator;
import java.util.logging.Logger;

import javax.imageio.ImageIO;
import javax.swing.JComponent;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.JToolTip;
import javax.swing.KeyStroke;
import javax.swing.text.JTextComponent;

import prefuse.activity.Activity;
import prefuse.activity.SlowInSlowOutPacer;
import prefuse.controls.Control;
import prefuse.data.expression.AndPredicate;
import prefuse.data.expression.BooleanLiteral;
import prefuse.data.expression.Predicate;
import prefuse.data.expression.parser.ExpressionParser;
import prefuse.render.Renderer;
import prefuse.util.ColorLib;
import prefuse.util.StringLib;
import prefuse.util.UpdateListener;
import prefuse.util.collections.CopyOnWriteArrayList;
import prefuse.util.display.BackgroundPainter;
import prefuse.util.display.Clip;
import prefuse.util.display.DebugStatsPainter;
import prefuse.util.display.ExportDisplayAction;
import prefuse.util.display.ItemBoundsListener;
import prefuse.util.display.PaintListener;
import prefuse.util.display.RenderingQueue;
import prefuse.visual.VisualItem;
import prefuse.visual.expression.VisiblePredicate;
import prefuse.visual.sort.ItemSorter;


/**
 * <p>User interface component that provides an interactive view onto
 * a visualization. The Display is responsible for drawing items to the
 * screen and providing callbacks for user interface actions such as
 * mouse and keyboard events. A Display must be associated with an
 * {@@link prefuse.Visualization} from which it pulls the items to visualize.
 * </p>
 * 
 * <p>To control which {@@link prefuse.visual.VisualItem} instances are
 * drawn, the Display also maintains an optional 
 * {@@link prefuse.data.expression.Predicate} for filtering items. The
 * drawing order of items is
 * controlled by an {@@link prefuse.visual.sort.ItemSorter} instance,
 * which calculates a score for each item. Items with higher scores
 * are drawn later, and hence on top of lower scoring items.
 * </p>
 * 
 * <p>The {@@link prefuse.controls.Control Control}
 * interface provides the user interface callbacks for supporting
 * interaction. The {@@link prefuse.controls} package contains a number
 * of pre-built <code>Control</code> implementations for common
 * interactions.</p>
 * 
 * <p>The Display class also supports arbitrary graphics transforms through
 * the <code>java.awt.geom.AffineTransform</code> class. The 
 * {@@link #setTransform(java.awt.geom.AffineTransform) setTransform} method
 * allows arbitrary transforms to be applied, while the 
 * {@@link #pan(double,double) pan} and 
 * {@@link #zoom(java.awt.geom.Point2D,double) zoom}
 * methods provide convenience methods that appropriately update the current
 * transform to achieve panning and zooming of the presentation space.</p>
 * 
 * <p>Additionally, each Display instance also supports use of a text editor
 * to facilitate direct editing of text. See the various
 * {@@link #editText(prefuse.visual.VisualItem, String)} methods.</p>
 * 
 * @@version 1.0
 * @@author <a href="http://jheer.org">jeffrey heer</a>
 * @@see Visualization
 * @@see prefuse.controls.Control
 * @@see prefuse.controls
 */
public class Display extends JComponent {

    private static final Logger s_logger 
        = Logger.getLogger(Display.class.getName());
    
    // visual item source
    protected Visualization m_vis;
    protected AndPredicate  m_predicate = new AndPredicate();
    
    // listeners
    protected CopyOnWriteArrayList m_controls = new CopyOnWriteArrayList();
    protected CopyOnWriteArrayList m_painters;
    protected CopyOnWriteArrayList m_bounders;
    
    // display
    protected BufferedImage m_offscreen;
    protected Clip          m_clip = new Clip();
    protected Clip          m_screen = new Clip();
    protected Clip          m_bounds = new Clip();
    protected Rectangle2D   m_rclip = new Rectangle2D.Double();
    protected boolean       m_damageRedraw = true;
    protected boolean       m_highQuality = false;
    
    // optional background image
    protected BackgroundPainter m_bgpainter = null;
    
    // rendering queue
    protected RenderingQueue m_queue = new RenderingQueue();
    protected int            m_visibleCount = 0;
    
    // transform variables
    protected AffineTransform   m_transform  = new AffineTransform();
    protected AffineTransform   m_itransform = new AffineTransform();
    protected TransformActivity m_transact = new TransformActivity();
    protected Point2D m_tmpPoint = new Point2D.Double();
    
    // frame count and debugging output
    protected double frameRate;
    protected int nframes = 0;
    private int sampleInterval = 10;
    private long mark = -1L;
    
    /* Custom tooltip, null to use regular tooltip mechanisms */
    protected JToolTip m_customToolTip = null;
    
    // text editing variables
    private JTextComponent m_editor;
    private boolean        m_editing;
    private VisualItem     m_editItem;
    private String         m_editAttribute;
    
    /**
     * Creates a new Display instance. You will need to associate this
     * Display with a {@@link Visualization} for it to display anything.
     */
    public Display() {
        this(null);
    }
    
    /**
     * Creates a new Display associated with the given Visualization.
     * By default, all {@@link prefuse.visual.VisualItem} instances in the
     * {@@link Visualization} will be drawn by the Display.
     * @@param visualization the {@@link Visualization} backing this Display
     */
    public Display(Visualization visualization) {
        this(visualization, (Predicate)null);
    }
    
    /**
     * Creates a new Display associated with the given Visualization that
     * draws all VisualItems in the visualization that pass the given
     * Predicate. The predicate string will be parsed by the
     * {@@link prefuse.data.expression.parser.ExpressionParser} to get a
     * {@@link prefuse.data.expression.Predicate} instance.
     * @@param visualization the {@@link Visualization} backing this Display
     * @@param predicate a predicate expression in the prefuse expression
     * language. This expression will be parsed; if the parsing fails or does
     * not result in a Predicate instance, an exception will result.
     */
    public Display(Visualization visualization, String predicate) {
        this(visualization,
                (Predicate)ExpressionParser.parse(predicate, true));
    }
    
    /**
     * Creates a new Display associated with the given Visualization that
     * draws all VisualItems in the visualization that pass the given
     * Predicate.
     * @@param visualization the {@@link Visualization} backing this Display
     * @@param predicate the filtering {@@link prefuse.data.expression.Predicate}
     */
    public Display(Visualization visualization, Predicate predicate) {
        setDoubleBuffered(false);
        setBackground(Color.WHITE);
        
        // initialize text editor
        m_editing = false;
        m_editor = new JTextField();
        m_editor.setBorder(null);
        m_editor.setVisible(false);
        this.add(m_editor);
        
        // register input event capturer
        InputEventCapturer iec = new InputEventCapturer();
        addMouseListener(iec);
        addMouseMotionListener(iec);
        addMouseWheelListener(iec);
        addKeyListener(iec);
        
        registerDefaultCommands();
        
        // invalidate the display when the filter changes
        m_predicate.addExpressionListener(new UpdateListener() {
            public void update(Object src) { damageReport(); }
        });
        
        setVisualization(visualization);
        setPredicate(predicate);
        setSize(400,400); // set a default size
    }
    
    /**
     * Resets the display by clearing the offscreen buffer and flushing the
     * internal rendering queue. This method can help reclaim memory when a
     * Display is not visible.
     */
    public void reset() {
    	m_offscreen = null;
    	m_queue.clean();
    }
    
    /**
     * Registers default keystroke commands on the Display. The default
     * commands are
     * <ul><li><b>ctrl D</b> - Toggle debug info display</li>
     *     <li><b>ctrl H</b> - Toggle high quality rendering</li>
     *     <li><b>ctrl E</b> - Export display view to an image file</li></ul>
     * Subclasses can override this method to prevent these commands from
     * being set. Additional commands can be registered using the
     * <code>registerKeyboardAction</code> method.
     */
    protected void registerDefaultCommands() {
        // add debugging output control
        registerKeyboardAction(new ActionListener() {
            private PaintListener m_debug = null;

            public void actionPerformed(ActionEvent e) {
                if (m_debug == null) {
                    m_debug = new DebugStatsPainter();
                    addPaintListener(m_debug);
                } else {
                    removePaintListener(m_debug);
                    m_debug = null;
                }
                repaint();
            }
        }, "debug info", KeyStroke.getKeyStroke("ctrl D"), WHEN_FOCUSED);
        
        // add quality toggle
        registerKeyboardAction(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                setHighQuality(!isHighQuality());
                repaint();
            }
        }, "toggle high-quality drawing", KeyStroke.getKeyStroke("ctrl H"),
                WHEN_FOCUSED);
        
        // add image output control, if this is not an applet
        try {
            registerKeyboardAction(new ExportDisplayAction(this),
             "export display", KeyStroke.getKeyStroke("ctrl E"), WHEN_FOCUSED);
        } catch (SecurityException se) {
        }
    }
    
    /**
     * Set the size of the Display.
     * @@param width the width of the Display in pixels
     * @@param height the height of the Display in pixels
     * @@see java.awt.Component#setSize(int, int)
     */
    public void setSize(int width, int height) {
        m_offscreen = null;
        setPreferredSize(new Dimension(width, height));
        super.setSize(width, height);
    }
    
    /**
     * Set the size of the Display.
     * @@param d the dimensions of the Display in pixels
     * @@see java.awt.Component#setSize(java.awt.Dimension)
     */
    public void setSize(Dimension d) {
        m_offscreen = null;
        setPreferredSize(d);
        super.setSize(d);
    }

    /**
     * Invalidates this component. Overridden to ensure that an
     * internal damage report is generated.
     * @@see java.awt.Component#invalidate()
     */
    public void invalidate() {
        damageReport();
        super.invalidate();
    }
    
    /**
     * @@see java.awt.Component#setBounds(int, int, int, int)
     */
    public void setBounds(int x, int y, int w, int h) {
        m_offscreen = null;
        super.setBounds(x,y,w,h);
    }
    
    /**
     * Sets the font used by this Display. This determines the font used
     * by this Display's text editor and in any debugging text.
     * @@param f the Font to use
     */
    public void setFont(Font f) {
        super.setFont(f);
        m_editor.setFont(f);
    }
    
    /**
     * Returns the running average frame rate for this Display.
     * @@return the frame rate
     */
    public double getFrameRate() {
        return frameRate;
    }
    
    /**
     * Determines if the Display uses a higher quality rendering, using
     * anti-aliasing. This causes drawing to be much slower, however, and
     * so is disabled by default.
     * @@param on true to enable anti-aliased rendering, false to disable it
     */
    public void setHighQuality(boolean on) {
        if ( m_highQuality != on )
            damageReport();
        m_highQuality = on;
    }
    
    /**
     * Indicates if the Display is using high quality (return value true) or
     * regular quality (return value false) rendering.
     * @@return true if high quality rendering is enabled, false otherwise
     */
    public boolean isHighQuality() {
        return m_highQuality;
    }
    
    /**
     * Returns the Visualization backing this Display.
     * @@return this Display's {@@link Visualization}
     */
    public Visualization getVisualization() {
        return m_vis;
    }
    
    /**
     * Set the Visualiztion associated with this Display. This Display
     * will render the items contained in the provided visualization. If this
     * Display is already associated with a different Visualization, the
     * Display unregisters itself with the previous one.
     * @@param vis the backing {@@link Visualization} to use.
     */
    public void setVisualization(Visualization vis) {
        // TODO: synchronization?
        if ( m_vis == vis ) {
            // nothing need be done
            return;
        } else if ( m_vis != null ) {
            // remove this display from it's previous registry
            m_vis.removeDisplay(this);
        }
        m_vis = vis;
        if ( m_vis != null )
            m_vis.addDisplay(this);
    }
    
    /**
     * Returns the filtering Predicate used to control what items are drawn
     * by this display.
     * @@return the filtering {@@link prefuse.data.expression.Predicate}
     */
    public Predicate getPredicate() {
        if ( m_predicate.size() == 1 ) {
            return BooleanLiteral.TRUE;
        } else {
            return m_predicate.get(0);
        }
    }

    /**
     * Sets the filtering Predicate used to control what items are drawn by
     * this Display.
     * @@param expr the filtering predicate to use. The predicate string will be
     * parsed by the {@@link prefuse.data.expression.parser.ExpressionParser}.
     * If the parse fails or does not result in a
     * {@@link prefuse.data.expression.Predicate} instance, an exception will
     * be thrown.
     */
    public void setPredicate(String expr) {
        Predicate p = (Predicate)ExpressionParser.parse(expr, true);
        setPredicate(p);
    }
    
    /**
     * Sets the filtering Predicate used to control what items are drawn by
     * this Display.
     * @@param p the filtering {@@link prefuse.data.expression.Predicate} to use
     */
    public synchronized void setPredicate(Predicate p) {
        if ( p == null ) {
            m_predicate.set(VisiblePredicate.TRUE);
        } else {
            m_predicate.set(new Predicate[] {p, VisiblePredicate.TRUE});
        }
    }
    
    /**
     * Returns the number of visible items processed by this Display. This
     * includes items not currently visible on screen due to the current
     * panning or zooming state.
     * @@return the count of visible items
     */
    public int getVisibleItemCount() {
        return m_visibleCount;
    }
    
    /**
     * Get the ItemSorter that determines the rendering order of the
     * VisualItems. Items are drawn in ascending order of the scores provided
     * by the ItemSorter.
     * @@return this Display's {@@link prefuse.visual.sort.ItemSorter}
     */
    public ItemSorter getItemSorter() {
        return m_queue.sort;
    }

    /**
     * Set the ItemSorter that determines the rendering order of the
     * VisualItems. Items are drawn in ascending order of the scores provided
     * by the ItemSorter.
     * @@param cmp the {@@link prefuse.visual.sort.ItemSorter} to use
     */
    public synchronized void setItemSorter(ItemSorter cmp) {
        damageReport();
        m_queue.sort = cmp;
    }
    

    /**
     * Set a background image for this display.
     * @@param image the background Image. If a null value is provided, 
     * than no background image will be shown.
     * @@param fixed true if the background image should stay in a fixed
     * position, invariant to panning, zooming, or rotation; false if
     * the image should be subject to view transforms
     * @@param tileImage true to tile the image across the visible background,
     * false to only include the image once
     */
    public synchronized void setBackgroundImage(Image image,
                                      boolean fixed, boolean tileImage)
    {
        BackgroundPainter bg = null;
        if ( image != null )
            bg = new BackgroundPainter(image, fixed, tileImage);
        setBackgroundPainter(bg);
    }

    /**
     * Set a background image for this display.
     * @@param location a location String of where to retrieve the
     * image file from. Uses
     * {@@link prefuse.util.io.IOLib#urlFromString(String)} to resolve
     * the String. If a null value is provided, than no background
     * image will be shown.
     * @@param fixed true if the background image should stay in a fixed
     * position, invariant to panning, zooming, or rotation; false if
     * the image should be subject to view transforms
     * @@param tileImage true to tile the image across the visible background,
     * false to only include the image once
     */
    public synchronized void setBackgroundImage(String location,
                                      boolean fixed, boolean tileImage)
    {
        BackgroundPainter bg = null;
        if ( location != null )
            bg = new BackgroundPainter(location, fixed, tileImage);
        setBackgroundPainter(bg);        
    }
    
    private void setBackgroundPainter(BackgroundPainter bg) {
        if ( m_bgpainter != null )
            removePaintListener(m_bgpainter);
        m_bgpainter = bg;
        if ( bg != null )
            addPaintListener(bg);
    }
    
    // ------------------------------------------------------------------------
    // ToolTips

    /**
     * Returns the tooltip instance to use for this Display. By default, uses
     * the normal Swing tooltips, returning the result of this same method
     * invoked on the JComponent super-class. If a custom tooltip has been
     * set, that is returned instead.
     * @@see #setCustomToolTip(JToolTip)
     * @@see javax.swing.JComponent#createToolTip()
     */
    public JToolTip createToolTip() {
        if ( m_customToolTip == null ) {
            return super.createToolTip();
        } else {
            return m_customToolTip;
        }
    }
    
    /**
     * Set a custom tooltip to use for this Display. To trigger tooltip
     * display, you must still use the <code>setToolTipText</code> method
     * as usual. The actual text will no longer have any effect, other
     * than that a null text value will result in no tooltip display
     * while a non-null text value will result in a tooltip being
     * shown. Clients are responsible for setting the tool tip
     * text to enable/disable tooltips as well as updating the content
     * of their own custom tooltip instance.
     * @@param tooltip the tooltip component to use
     * @@see prefuse.util.ui.JCustomTooltip
     */
    public void setCustomToolTip(JToolTip tooltip) {
        m_customToolTip = tooltip;
    }
    
    /**
     * Get the custom tooltip used by this Display. Returns null if normal
     * tooltips are being used.
     * @@return the custom tooltip used by this Display, or null if none
     */
    public JToolTip getCustomToolTip() {
        return m_customToolTip;
    }
    
    // ------------------------------------------------------------------------
    // Clip / Bounds Management
    
    /**
     * Indicates if damage/redraw rendering is enabled. If enabled, the display
     * will only redraw within the bounding box of all areas that have changed
     * since the last rendering operation. For small changes, such as a single
     * item being dragged, this can result in a significant performance
     * increase. By default, the damage/redraw optimization is enabled. It can
     * be disabled, however, if rendering artifacts are appearing in your
     * visualization. Be careful though, as this may not be the best solution.
     * Rendering artifacts may result because the item bounds returned by
     * {@@link prefuse.visual.VisualItem#getBounds()} are not accurate and the
     * item's {@@link prefuse.render.Renderer} is drawing outside of the
     * reported bounds. In this case, there is usually a bug in the Renderer.
     * One reported problem arises from Java itself, however, which
     * inaccurately redraws images outside of their reported bounds. If you
     * have a visulization with a number of images and are seeing rendering
     * artifacts, try disabling damage/redraw.
     * @@return true if damage/redraw optimizations are enabled, false
     * otherwise (in which case the entire Display is redrawn upon a repaint)
     */
    public synchronized boolean isDamageRedraw() {
        return m_damageRedraw;
    }
    
    /**
     * Sets if damage/redraw rendering is enabled. If enabled, the display
     * will only redraw within the bounding box of all areas that have changed
     * since the last rendering operation. For small changes, such as a single
     * item being dragged, this can result in a significant performance
     * increase. By default, the damage/redraw optimization is enabled. It can
     * be disabled, however, if rendering artifacts are appearing in your
     * visualization. Be careful though, as this may not be the best solution.
     * Rendering artifacts may result because the item bounds returned by
     * {@@link prefuse.visual.VisualItem#getBounds()} are not accurate and the
     * item's {@@link prefuse.render.Renderer} is drawing outside of the
     * reported bounds. In this case, there is usually a bug in the Renderer.
     * One reported problem arises from Java itself, however, which
     * inaccurately redraws images outside of their reported bounds. If you
     * have a visulization with a number of images and are seeing rendering
     * artifacts, try disabling damage/redraw.
     * @@param b true to enable damage/redraw optimizations, false otherwise
     * (in which case the entire Display will be redrawn upon a repaint)
     */
    public synchronized void setDamageRedraw(boolean b) {
        m_damageRedraw = b;
        m_clip.invalidate();
    }
    
    /**
     * Reports damage to the Display within in the specified region.
     * @@param region the damaged region, in absolute coordinates
     */
    public synchronized void damageReport(Rectangle2D region) {
        if ( m_damageRedraw )
            m_clip.union(region);
    }
    
    /**
     * Reports damage to the entire Display.
     */
    public synchronized void damageReport() {
        m_clip.invalidate();
    }
   
    /**
     * Clears any reports of damaged regions, causing the Display to believe
     * that the display contents are up-to-date. If used incorrectly this
     * can cause inaccurate rendering. <strong>Call this method only
     * if you know what you are doing.</strong>
     */
    public synchronized void clearDamage() {
        if ( m_damageRedraw )
            m_clip.reset();
    }
    
    /**
     * Returns the bounds, in absolute (item-space) coordinates, of the total
     * bounds occupied by all currently visible VisualItems. This method
     * allocates a new Rectangle2D instance for the result.
     * @@return the bounding box of all visibile VisualItems
     * @@see #getItemBounds(Rectangle2D)
     */
    public synchronized Rectangle2D getItemBounds() {
        return getItemBounds(new Rectangle2D.Double());
    }

    /**
     * Returns the bounds, in absolute (item-space) coordinates, of the total
     * bounds occupied by all currently visible VisualItems.
     * @@param b the Rectangle2D to use to store the return value
     * @@return the bounding box of all visibile VisualItems
     */
    public synchronized Rectangle2D getItemBounds(Rectangle2D b) {
        b.setFrameFromDiagonal(m_bounds.getMinX(), m_bounds.getMinY(),
                               m_bounds.getMaxX(), m_bounds.getMaxY());
        return b;
    }
    
    // ------------------------------------------------------------------------
    // Rendering
    
    /**
     * Returns the offscreen buffer used for double buffering.
     * @@return the offscreen buffer
     */
    public BufferedImage getOffscreenBuffer() {
        return m_offscreen;
    }
    
    /**
     * Creates a new buffered image to use as an offscreen buffer.
     */
    protected BufferedImage getNewOffscreenBuffer(int width, int height) {
        BufferedImage img = null;
        if ( !GraphicsEnvironment.isHeadless() ) {
            try {
                img = (BufferedImage)createImage(width, height);
            } catch ( Exception e ) {
                img = null;
            }
        }
        if ( img == null ) {
            return new BufferedImage(width, height,
                                     BufferedImage.TYPE_INT_RGB);
        }
        return img;
    }
    
    /**
     * Saves a copy of this display as an image to the specified output stream.
     * @@param output the output stream to write to.
     * @@param format the image format (e.g., "JPG", "PNG"). The number and kind
     * of available formats varies by platform. See
     * {@@link javax.imageio.ImageIO} and related classes for more.
     * @@param scale how much to scale the image by. For example, a value of 2.0
     * will result in an image with twice the pixel width and height of this
     * Display.
     * @@return true if image was successfully saved, false if an error occurred.
     */
    public boolean saveImage(OutputStream output, String format, double scale)
    {
        try {
            // get an image to draw into
            Dimension d = new Dimension((int)(scale*getWidth()),
                                        (int)(scale*getHeight()));
            BufferedImage img = getNewOffscreenBuffer(d.width, d.height);
            Graphics2D g = (Graphics2D)img.getGraphics();
            
            // set up the display, render, then revert to normal settings
            Point2D p = new Point2D.Double(0,0);
            zoom(p, scale); // also takes care of damage report
            boolean q = isHighQuality();
            setHighQuality(true);
            paintDisplay(g, d);
            setHighQuality(q);
            zoom(p, 1/scale); // also takes care of damage report
            
            // save the image and return
            ImageIO.write(img, format, output);
            return true;
        } catch ( Exception e ) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * @@see java.awt.Component#update(java.awt.Graphics)
     */
    public void update(Graphics g) {
        paint(g);
    }
    
    /**
     * Paints the offscreen buffer to the provided graphics context.
     * @@param g the Graphics context to paint to
     */
    protected void paintBufferToScreen(Graphics g) {
        synchronized ( this ) {
            g.drawImage(m_offscreen, 0, 0, null);
        }
    }

    /**
     * Immediately repaints the contents of the offscreen buffer
     * to the screen. This bypasses the usual rendering loop.
     */
    public void repaintImmediate() {
        Graphics g = this.getGraphics();
        if (g != null && m_offscreen != null) {
            paintBufferToScreen(g);
        }
    }

    /**
     * Sets the transform of the provided Graphics context to be the
     * transform of this Display and sets the desired rendering hints.
     * @@param g the Graphics context to prepare.
     */
    protected void prepareGraphics(Graphics2D g) {
        if ( m_transform != null )
            g.transform(m_transform);
        setRenderingHints(g);
    }
    
    /**
     * Sets the rendering hints that should be used while drawing
     * the visualization to the screen. Subclasses can override
     * this method to set hints as desired. Such subclasses should
     * consider honoring the high quality flag in one form or another.
     * @@param g the Graphics context on which to set the rendering hints
     */
    protected void setRenderingHints(Graphics2D g) {
        if ( m_highQuality ) {
            g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                    RenderingHints.VALUE_ANTIALIAS_ON);
        } else {
            g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                    RenderingHints.VALUE_ANTIALIAS_OFF);
        }
        g.setRenderingHint(
            RenderingHints.KEY_RENDERING,
            RenderingHints.VALUE_RENDER_QUALITY);
        g.setRenderingHint(
            RenderingHints.KEY_INTERPOLATION,
            RenderingHints.VALUE_INTERPOLATION_BICUBIC);
    }


    /**
     * @@see javax.swing.JComponent#paintComponent(java.awt.Graphics)
     */
    public void paintComponent(Graphics g) {
        if (m_offscreen == null) {
            m_offscreen = getNewOffscreenBuffer(getWidth(), getHeight());
            damageReport();
        }
        Graphics2D g2D = (Graphics2D)g;
        Graphics2D buf_g2D = (Graphics2D) m_offscreen.getGraphics();
        
        // Why not fire a pre-paint event here?
        // Pre-paint events are fired by the clearRegion method
        
        // paint the visualization
        paintDisplay(buf_g2D, getSize());
        paintBufferToScreen(g2D);       
        
        // fire post-paint events to any painters
        firePostPaint(g2D);
        
        buf_g2D.dispose();
        
        // compute frame rate
        nframes++;
        if ( mark < 0 ) {
            mark = System.currentTimeMillis();
            nframes = 0;
        } else if ( nframes == sampleInterval ){
            long t = System.currentTimeMillis();
            frameRate = (1000.0*nframes)/(t-mark);
            mark = t;
            nframes = 0;
        }
    }
    
    /**
     * Renders the display within the given graphics context and size bounds.
     * @@param g2D the <code>Graphics2D</code> context to use for rendering
     * @@param d the rendering width and height of the Display
     */
    public void paintDisplay(Graphics2D g2D, Dimension d) {
        // if double-locking *ALWAYS* lock on the visualization first
        synchronized ( m_vis ) {
        synchronized ( this ) {
            
            if ( m_clip.isEmpty() )
                return; // no damage, no render
            
            // map the screen bounds to absolute coords
            m_screen.setClip(0, 0, d.width+1, d.height+1);
            m_screen.transform(m_itransform);
            
            // compute the approximate size of an "absolute pixel"
            // values too large are OK (though cause unnecessary rendering)
            // values too small will cause incorrect rendering
            double pixel = 1.0 + 1.0/getScale();
            
            if ( m_damageRedraw ) {  
                if ( m_clip.isInvalid() ) {
                    // if clip is invalid, we clip to the entire screen
                    m_clip.setClip(m_screen);
                } else {
                    // otherwise intersect damaged region with display bounds
                    m_clip.intersection(m_screen);
                }
  
                // expand the clip by the extra pixel margin
                m_clip.expand(pixel);
                
                // set the transform, rendering keys, etc
                prepareGraphics(g2D);
                
                // now set the actual rendering clip
                m_rclip.setFrameFromDiagonal(
                        m_clip.getMinX(), m_clip.getMinY(), 
                        m_clip.getMaxX(), m_clip.getMaxY());
                g2D.setClip(m_rclip);
                
                // finally, we want to clear the region we'll redraw. we clear
                // a slightly larger area than the clip. if we don't do this,
                // we sometimes get rendering artifacts, possibly due to
                // scaling mismatches in the Java2D implementation
                m_rclip.setFrameFromDiagonal(
                        m_clip.getMinX()-pixel, m_clip.getMinY()-pixel,
                        m_clip.getMaxX()+pixel, m_clip.getMaxY()+pixel);

            } else {
                // set the background region to clear
                m_rclip.setFrame(m_screen.getMinX(),  m_screen.getMinY(),
                                 m_screen.getWidth(), m_screen.getHeight());
                
                // set the item clip to the current screen
                m_clip.setClip(m_screen);
                
                // set the transform, rendering keys, etc
                prepareGraphics(g2D);
            }

            // now clear the region
            clearRegion(g2D, m_rclip);            
            
            // -- render ----------------------------
            // the actual rendering  loop
            
            // copy current item bounds into m_rclip, reset item bounds
            getItemBounds(m_rclip);
            m_bounds.reset();
            
            // fill the rendering and picking queues
            m_queue.clear();   // clear the queue
            Iterator items = m_vis.items(m_predicate);
            for ( m_visibleCount=0; items.hasNext(); ++m_visibleCount ) {
                VisualItem item = (VisualItem)items.next();
                Rectangle2D bounds = item.getBounds();
                m_bounds.union(bounds); // add to item bounds
                
                if ( m_clip.intersects(bounds, pixel) )
                    m_queue.addToRenderQueue(item);
                if ( item.isInteractive() )
                    m_queue.addToPickingQueue(item);
            }
            
            // sort the rendering queue
            m_queue.sortRenderQueue();
            
            // render each visual item
            for ( int i=0; i<m_queue.rsize; ++i ) {
                m_queue.ritems[i].render(g2D);
            }
            
            // no more damage so reset the clip
            if ( m_damageRedraw )
                m_clip.reset();
            
            // fire bounds change, if appropriate
            checkItemBoundsChanged(m_rclip);
            
        }} // end synchronized block
    }
    
    /**
     * Immediately render the given VisualItem to the screen. This method
     * bypasses the Display's offscreen buffer.
     * @@param item the VisualItem to render immediately
     */
    public void renderImmediate(VisualItem item) {
        Graphics2D g2D = (Graphics2D)this.getGraphics();
        prepareGraphics(g2D);
        item.render(g2D);
    }
    
    /**
     * Paints the graph to the provided graphics context, for output to a
     * printer.  This method does not double buffer the painting, in order to
     * provide the maximum print quality.
     * 
     * <b>This method may not be working correctly,
     * and will be repaired at a later date.</b>
     * 
     * @@param g the printer graphics context.
     */
    protected void printComponent(Graphics g) {
        boolean wasHighQuality = m_highQuality;
        try {
            // Set the quality to high for the duration of the printing.
            m_highQuality = true;
            // Paint directly to the print graphics context.
            paintDisplay((Graphics2D) g, getSize());
        } finally {
            // Reset the quality to the state it was in before printing.
            m_highQuality = wasHighQuality;
        }
    }
    
    /**
     * Clears the specified region of the display
     * in the display's offscreen buffer.
     */    
    protected void clearRegion(Graphics2D g, Rectangle2D r) {
        g.setColor(getBackground());
        g.fill(r);
        // fire pre-paint events to any painters
        firePrePaint(g);
    }

    // ------------------------------------------------------------------------
    // Transformations
    
    /**
     * Set the 2D AffineTransform (e.g., scale, shear, pan, rotate) used by
     * this display before rendering visual items. The provided transform
     * must be invertible, otherwise an expection will be thrown. For simple
     * panning and zooming transforms, you can instead use the provided
     * pan() and zoom() methods.
     */
    public synchronized void setTransform(AffineTransform transform) 
        throws NoninvertibleTransformException
    {
        damageReport();
        m_transform = transform;
        m_itransform = m_transform.createInverse();
    }
    
    /**
     * Returns a reference to the AffineTransformation used by this Display.
     * Changes made to this reference WILL corrupt the state of 
     * this display. Use setTransform() to safely update the transform state.
     * @@return the AffineTransform
     */
    public AffineTransform getTransform() {
        return m_transform;
    }
    
    /**
     * Returns a reference to the inverse of the AffineTransformation used by
     * this display. Direct changes made to this reference WILL corrupt the
     * state of this display.
     * @@return the inverse AffineTransform
     */
    public AffineTransform getInverseTransform() {
        return m_itransform;
    }
    
    /**
     * Gets the absolute co-ordinate corresponding to the given screen
     * co-ordinate.
     * @@param screen the screen co-ordinate to transform
     * @@param abs a reference to put the result in. If this is the same
     *  object as the screen co-ordinate, it will be overridden safely. If
     *  this value is null, a new Point2D instance will be created and 
     *  returned.
     * @@return the point in absolute co-ordinates
     */
    public Point2D getAbsoluteCoordinate(Point2D screen, Point2D abs) {
        return m_itransform.transform(screen, abs);
    }
    
    /**
     * Returns the current scale (zoom) value.
     * @@return the current scale. This is the
     *  scaling factor along the x-dimension, so be careful when
     *  using this value in rare non-uniform scaling cases.
     */
    public double getScale() {
        return m_transform.getScaleX();
    }
    
    /**
     * Returns the x-coordinate of the top-left of the display, 
     * in absolute (item-space) co-ordinates.
     * @@return the x co-ord of the top-left corner, in absolute coordinates
     */
    public double getDisplayX() {
        return -m_transform.getTranslateX();
    }
    
    /**
     * Returns the y-coordinate of the top-left of the display, 
     * in absolute (item-space) co-ordinates.
     * @@return the y co-ord of the top-left corner, in absolute coordinates
     */
    public double getDisplayY() {
        return -m_transform.getTranslateY();
    }
    
    /**
     * Pans the view provided by this display in screen coordinates.
     * @@param dx the amount to pan along the x-dimension, in pixel units
     * @@param dy the amount to pan along the y-dimension, in pixel units
     */
    public synchronized void pan(double dx, double dy) {
        m_tmpPoint.setLocation(dx, dy);
        m_itransform.transform(m_tmpPoint, m_tmpPoint);
        double panx = m_tmpPoint.getX();
        double pany = m_tmpPoint.getY();
        m_tmpPoint.setLocation(0, 0);
        m_itransform.transform(m_tmpPoint, m_tmpPoint);
        panx -= m_tmpPoint.getX();
        pany -= m_tmpPoint.getY();
        panAbs(panx, pany);

    }
    
    /**
     * Pans the view provided by this display in absolute (i.e. item-space)
     * coordinates.
     * @@param dx the amount to pan along the x-dimension, in absolute co-ords
     * @@param dy the amount to pan along the y-dimension, in absolute co-ords
     */
    public synchronized void panAbs(double dx, double dy) {
        damageReport();
        m_transform.translate(dx, dy);
        try {
            m_itransform = m_transform.createInverse();
        } catch ( Exception e ) { /*will never happen here*/ }
    }
    
    /**
     * Pans the display view to center on the provided point in 
     * screen (pixel) coordinates.
     * @@param p the point to center on, in screen co-ords
     */
    public synchronized void panTo(Point2D p) {
        m_itransform.transform(p, m_tmpPoint);
        panToAbs(m_tmpPoint);
    }
    
    /**
     * Pans the display view to center on the provided point in 
     * absolute (i.e. item-space) coordinates.
     * @@param p the point to center on, in absolute co-ords
     */
    public synchronized void panToAbs(Point2D p) {
        double sx = m_transform.getScaleX();
        double sy = m_transform.getScaleY();
        double x = p.getX(); x = (Double.isNaN(x) ? 0 : x);
        double y = p.getY(); y = (Double.isNaN(y) ? 0 : y);
        x = getWidth() /(2*sx) - x;
        y = getHeight()/(2*sy) - y;
        
        double dx = x-(m_transform.getTranslateX()/sx);
        double dy = y-(m_transform.getTranslateY()/sy);

        damageReport();
        m_transform.translate(dx, dy);
        try {
            m_itransform = m_transform.createInverse();
        } catch ( Exception e ) { /*will never happen here*/ }
    }

    /**
     * Zooms the view provided by this display by the given scale,
     * anchoring the zoom at the specified point in screen coordinates.
     * @@param p the anchor point for the zoom, in screen coordinates
     * @@param scale the amount to zoom by
     */
    public synchronized void zoom(final Point2D p, double scale) {
        m_itransform.transform(p, m_tmpPoint);
        zoomAbs(m_tmpPoint, scale);
    }    
    
    /**
     * Zooms the view provided by this display by the given scale,
     * anchoring the zoom at the specified point in absolute coordinates.
     * @@param p the anchor point for the zoom, in absolute
     *  (i.e. item-space) co-ordinates
     * @@param scale the amount to zoom by
     */
    public synchronized void zoomAbs(final Point2D p, double scale) {;
        double zx = p.getX(), zy = p.getY();
        damageReport();
        m_transform.translate(zx, zy);
        m_transform.scale(scale,scale);
        m_transform.translate(-zx, -zy);
        try {
            m_itransform = m_transform.createInverse();
        } catch ( Exception e ) { /*will never happen here*/ }
    }
    
    /**
     * Rotates the view provided by this display by the given angle in radians,
     * anchoring the rotation at the specified point in screen coordinates.
     * @@param p the anchor point for the rotation, in screen coordinates
     * @@param theta the angle to rotate by, in radians
     */
    public synchronized void rotate(final Point2D p, double theta) {
        m_itransform.transform(p, m_tmpPoint);
        rotateAbs(m_tmpPoint, theta);
    }    
    
    /**
     * Rotates the view provided by this display by the given angle in radians,
     * anchoring the rotation at the specified point in absolute coordinates.
     * @@param p the anchor point for the rotation, in absolute
     *  (i.e. item-space) co-ordinates
     * @@param theta the angle to rotation by, in radians
     */
    public synchronized void rotateAbs(final Point2D p, double theta) {
        double zx = p.getX(), zy = p.getY();
        damageReport();
        m_transform.translate(zx, zy);
        m_transform.rotate(theta);
        m_transform.translate(-zx, -zy);
        try {
            m_itransform = m_transform.createInverse();
        } catch ( Exception e ) { /*will never happen here*/ }
    }

    /**
     * Animate a pan along the specified distance in screen (pixel) 
     * co-ordinates using the provided duration.
     * @@param dx the amount to pan along the x-dimension, in pixel units
     * @@param dy the amount to pan along the y-dimension, in pixel units
     * @@param duration the duration of the animation, in milliseconds
     */
    public synchronized void animatePan(double dx, double dy, long duration) {
        double panx = dx / m_transform.getScaleX();
        double pany = dy / m_transform.getScaleY();
        animatePanAbs(panx,pany,duration);
    }
    
    /**
     * Animate a pan along the specified distance in absolute (item-space)
     * co-ordinates using the provided duration.
     * @@param dx the amount to pan along the x-dimension, in absolute co-ords
     * @@param dy the amount to pan along the y-dimension, in absolute co-ords
     * @@param duration the duration of the animation, in milliseconds
     */
    public synchronized void animatePanAbs(double dx, double dy, long duration) {
        m_transact.pan(dx,dy,duration);
    }
    
    /**
     * Animate a pan to the specified location in screen (pixel) 
     * co-ordinates using the provided duration.
     * @@param p the point to pan to in screen (pixel) units
     * @@param duration the duration of the animation, in milliseconds
     */
    public synchronized void animatePanTo(Point2D p, long duration) {
        Point2D pp = new Point2D.Double();
        m_itransform.transform(p,pp);
        animatePanToAbs(pp,duration);
    }
    
    /**
     * Animate a pan to the specified location in absolute (item-space) 
     * co-ordinates using the provided duration.
     * @@param p the point to pan to in absolute (item-space) units
     * @@param duration the duration of the animation, in milliseconds
     */
    public synchronized void animatePanToAbs(Point2D p, long duration) {
        m_tmpPoint.setLocation(0,0);
        m_itransform.transform(m_tmpPoint,m_tmpPoint);
        double x = p.getX(); x = (Double.isNaN(x) ? 0 : x);
        double y = p.getY(); y = (Double.isNaN(y) ? 0 : y);
        double w = getWidth() /(2*m_transform.getScaleX());
        double h = getHeight()/(2*m_transform.getScaleY());
        double dx = w-x+m_tmpPoint.getX();
        double dy = h-y+m_tmpPoint.getY();
        animatePanAbs(dx,dy,duration);
    }
    
    /**
     * Animate a zoom centered on a given location in screen (pixel) 
     * co-ordinates by the given scale using the provided duration.
     * @@param p the point to center on in screen (pixel) units
     * @@param scale the scale factor to zoom by
     * @@param duration the duration of the animation, in milliseconds
     */
    public synchronized void animateZoom(final Point2D p, double scale, long duration) {
        Point2D pp = new Point2D.Double();
        m_itransform.transform(p,pp);
        animateZoomAbs(pp,scale,duration);
    }
    
    /**
     * Animate a zoom centered on a given location in absolute (item-space) 
     * co-ordinates by the given scale using the provided duration.
     * @@param p the point to center on in absolute (item-space) units
     * @@param scale the scale factor to zoom by
     * @@param duration the duration of the animation, in milliseconds
     */
    public synchronized void animateZoomAbs(final Point2D p, double scale, long duration) {
        m_transact.zoom(p,scale,duration);
    }
    
    /**
     * Animate a pan to the specified location in screen (pixel) 
     * co-ordinates and zoom to the given scale using the provided duration.
     * @@param p the point to center on in screen (pixel) units
     * @@param scale the scale factor to zoom by
     * @@param duration the duration of the animation, in milliseconds
     */
    public synchronized void animatePanAndZoomTo(final Point2D p, double scale, long duration) {
        Point2D pp = new Point2D.Double();
        m_itransform.transform(p,pp);
        animatePanAndZoomToAbs(pp,scale,duration);
    }
    
    /**
     * Animate a pan to the specified location in absolute (item-space) 
     * co-ordinates and zoom to the given scale using the provided duration.
     * @@param p the point to center on in absolute (item-space) units
     * @@param scale the scale factor to zoom by
     * @@param duration the duration of the animation, in milliseconds
     */
    public synchronized void animatePanAndZoomToAbs(final Point2D p, double scale, long duration) {
        m_transact.panAndZoom(p,scale,duration);
    }
    
    /**
     * Indicates if a view transformation is currently underway.
     * @@return true if a transform is in progress, false otherwise
     */
    public boolean isTranformInProgress() {
        return m_transact.isRunning();
    }
    
    /**
     * Activity for conducting animated view transformations.
     */
    private class TransformActivity extends Activity {
        // TODO: clean this up to be more general...
        // TODO: change mechanism so that multiple transform
        //        activities can be running at once?
         
        private double[] src, dst;
        private AffineTransform m_at;
        public TransformActivity() {
            super(2000,20,0);
            src = new double[6];
            dst = new double[6];
            m_at = new AffineTransform();
            setPacingFunction(new SlowInSlowOutPacer());
        }
        private AffineTransform getTransform() {
            if ( this.isScheduled() )
                m_at.setTransform(dst[0],dst[1],dst[2],dst[3],dst[4],dst[5]);
            else
                m_at.setTransform(m_transform);
            return m_at;
        }
        public void panAndZoom(final Point2D p, double scale, long duration) {
            AffineTransform at = getTransform();
            this.cancel();
            setDuration(duration);
            
            m_tmpPoint.setLocation(0,0);
            m_itransform.transform(m_tmpPoint,m_tmpPoint);
            double x = p.getX(); x = (Double.isNaN(x) ? 0 : x);
            double y = p.getY(); y = (Double.isNaN(y) ? 0 : y);
            double w = getWidth() /(2*m_transform.getScaleX());
            double h = getHeight()/(2*m_transform.getScaleY());
            double dx = w-x+m_tmpPoint.getX();
            double dy = h-y+m_tmpPoint.getY();
            at.translate(dx,dy);

            at.translate(p.getX(), p.getY());
            at.scale(scale,scale);
            at.translate(-p.getX(), -p.getY());
            
            at.getMatrix(dst);
            m_transform.getMatrix(src);
            this.run();
        }
        public void pan(double dx, double dy, long duration) {
            AffineTransform at = getTransform();
            this.cancel();
            setDuration(duration);
            at.translate(dx,dy);
            at.getMatrix(dst);
            m_transform.getMatrix(src);
            this.run();
        }
        public void zoom(final Point2D p, double scale, long duration) {
            AffineTransform at = getTransform();
            this.cancel();
            setDuration(duration);
            double zx = p.getX(), zy = p.getY();
            at.translate(zx, zy);
            at.scale(scale,scale);
            at.translate(-zx, -zy);
            at.getMatrix(dst);
            m_transform.getMatrix(src);
            this.run();
        }
        protected void run(long elapsedTime) {
            double f = getPace(elapsedTime);
            damageReport();
            m_transform.setTransform(
                src[0] + f*(dst[0]-src[0]),
                src[1] + f*(dst[1]-src[1]),
                src[2] + f*(dst[2]-src[2]),
                src[3] + f*(dst[3]-src[3]),
                src[4] + f*(dst[4]-src[4]),
                src[5] + f*(dst[5]-src[5])
            );
            try {
                m_itransform = m_transform.createInverse();
            } catch ( Exception e ) { /* won't happen */ }
            repaint();
        }
    } // end of inner class TransformActivity
    
    // ------------------------------------------------------------------------
    // Paint Listeners
    
    /**
     * Add a PaintListener to this Display to receive notifications
     * about paint events.
     * @@param pl the {@@link prefuse.util.display.PaintListener} to add
     */
    public void addPaintListener(PaintListener pl) {
        if ( m_painters == null )
            m_painters = new CopyOnWriteArrayList();
        m_painters.add(pl);
    }
    
    /**
     * Remove a PaintListener from this Display.
     * @@param pl the {@@link prefuse.util.display.PaintListener} to remove
     */
    public void removePaintListener(PaintListener pl) {
        m_painters.remove(pl);
    }
    
    /**
     * Fires a pre-paint notification to PaintListeners.
     * @@param g the current graphics context
     */
    protected void firePrePaint(Graphics2D g) {
        if ( m_painters != null && m_painters.size() > 0 ) {
            Object[] lstnrs = m_painters.getArray();
            for ( int i=0; i<lstnrs.length; ++i ) {
                try {
                    ((PaintListener)lstnrs[i]).prePaint(this, g);
                } catch ( Exception e ) {
                    s_logger.warning(
                        "Exception thrown by PaintListener: " + e + "\n" +
                        StringLib.getStackTrace(e));
                }
            }
        }
    }
    
    /**
     * Fires a post-paint notification to PaintListeners.
     * @@param g the current graphics context
     */
    protected void firePostPaint(Graphics2D g) {
        if ( m_painters != null && m_painters.size() > 0 ) {
            Object[] lstnrs = m_painters.getArray();
            for ( int i=0; i<lstnrs.length; ++i ) {
                try {
                    ((PaintListener)lstnrs[i]).postPaint(this, g);
                } catch ( Exception e ) {
                    s_logger.warning(
                        "Exception thrown by PaintListener: " + e + "\n" +
                        StringLib.getStackTrace(e));
                }
            }
        }
    }
    
    
    // ------------------------------------------------------------------------
    // Item Bounds Listeners
    
    /**
     * Add an ItemBoundsListener to receive notifications when the bounds
     * occupied by the VisualItems in this Display change.
     * @@param ibl the {@@link prefuse.util.display.ItemBoundsListener} to add
     */
    public void addItemBoundsListener(ItemBoundsListener ibl) {
        if ( m_bounders == null )
            m_bounders = new CopyOnWriteArrayList();
        m_bounders.add(ibl);
    }
    
    /**
     * Remove an ItemBoundsListener to receive notifications when the bounds
     * occupied by the VisualItems in this Display change.
     * @@param ibl the {@@link prefuse.util.display.ItemBoundsListener} to remove
     */
    public void removeItemBoundsListener(ItemBoundsListener ibl) {
        m_bounders.remove(ibl);
    }
    
    /**
     * Check if the item bounds has changed, and if so, fire a notification.
     * @@param prev the previous item bounds of the Display
     */
    protected void checkItemBoundsChanged(Rectangle2D prev) {
        if ( m_bounds.equals(prev) )
            return; // nothing to do
        
        if ( m_bounders != null && m_bounders.size() > 0 ) {
            Object[] lstnrs = m_bounders.getArray();
            for ( int i=0; i<lstnrs.length; ++i ) {
                try {
                    ((ItemBoundsListener)lstnrs[i]).itemBoundsChanged(this);
                } catch ( Exception e ) {
                    s_logger.warning(
                        "Exception thrown by ItemBoundsListener: " + e + "\n" +
                        StringLib.getStackTrace(e));
                }
            }
        }
    }
    
    
    // ------------------------------------------------------------------------
    // Control Listeners
    
    /**
     * Adds a ControlListener to receive all input events on VisualItems.
     * @@param cl the listener to add.
     */
    public void addControlListener(Control cl) {
        m_controls.add(cl);
    }

    /**
     * Removes a registered ControlListener.
     * @@param cl the listener to remove.
     */
    public void removeControlListener(Control cl) {
        m_controls.remove(cl);
    }
    
    /**
     * Returns the VisualItem located at the given point.
     * @@param p the Point at which to look
     * @@return the VisualItem located at the given point, if any
     */
    public synchronized VisualItem findItem(Point p) {
        // transform mouse point from screen space to item space
        Point2D p2 = (m_itransform==null ? p : 
                      m_itransform.transform(p, m_tmpPoint));
        // ensure that the picking queue has been z-sorted
        if ( !m_queue.psorted )
            m_queue.sortPickingQueue();
        // walk queue from front to back looking for hits
        for ( int i = m_queue.psize; --i >= 0; ) {
            VisualItem vi = m_queue.pitems[i];
            if ( !vi.isValid() ) continue; // in case tuple went invalid
            Renderer r = vi.getRenderer();
            if (r!=null && vi.isInteractive() && r.locatePoint(p2, vi)) {
                return vi;
            }
        }
        return null;
    }
    
    /**
     * Captures all mouse and key events on the display, detects relevant 
     * VisualItems, and informs ControlListeners.
     */
    public class InputEventCapturer implements MouseMotionListener, 
        MouseWheelListener, MouseListener, KeyListener
    {
        private VisualItem activeItem = null;
        private boolean mouseDown = false;

        private boolean validityCheck() {
            if ( activeItem.isValid() )
                return true;
            activeItem = null;
            return false;
        }
        
        public void mouseDragged(MouseEvent e) {
            synchronized ( m_vis ) {
                if ( activeItem != null ) {
                    if ( validityCheck() )
                        fireItemDragged(activeItem, e);
                } else {
                    fireMouseDragged(e);
                }
            }
        }

        public void mouseMoved(MouseEvent e) {
            synchronized ( m_vis ) {
                boolean earlyReturn = false;
                //check if we've gone over any item
                VisualItem vi = findItem(e.getPoint());
                if ( activeItem != null && activeItem != vi ) {
                    if ( validityCheck() )
                        fireItemExited(activeItem, e);
                    earlyReturn = true;
                }
                if ( vi != null && vi != activeItem ) {
                    fireItemEntered(vi, e);
                    earlyReturn = true;
                }
                activeItem = vi;
                if ( earlyReturn ) return;
                
                if ( vi != null && vi == activeItem ) {
                    fireItemMoved(vi, e);
                }
                if ( vi == null ) {
                    fireMouseMoved(e);
                }
            }
        }

        public void mouseWheelMoved(MouseWheelEvent e) {
            synchronized ( m_vis ) {
                if ( activeItem != null ) {
                    if ( validityCheck() )
                        fireItemWheelMoved(activeItem, e);
                } else {
                    fireMouseWheelMoved(e);
                }
            }
        }

        public void mouseClicked(MouseEvent e) {
            synchronized ( m_vis ) {
                if ( activeItem != null ) {
                    if ( validityCheck() )
                        fireItemClicked(activeItem, e);
                } else {
                    fireMouseClicked(e);
                }
            }
        }
        

        public void mousePressed(MouseEvent e) {
            synchronized ( m_vis ) {
                mouseDown = true;
                if ( activeItem != null ) {
                    if ( validityCheck() )
                        fireItemPressed(activeItem, e);
                } else {
                    fireMousePressed(e);
                }
            }
        }

        public void mouseReleased(MouseEvent e) {
            synchronized ( m_vis ) {
                if ( activeItem != null ) {
                    if ( validityCheck() )
                        fireItemReleased(activeItem, e);
                } else {
                    fireMouseReleased(e);
                }
                if ( activeItem != null && mouseDown && isOffComponent(e) ) {
                    // mouse was dragged off of the component, 
                    // then released, so register an exit
                    fireItemExited(activeItem, e);
                    activeItem = null;
                }
                mouseDown = false;
            }
        }

        public void mouseEntered(MouseEvent e) {
            synchronized ( m_vis ) {
                fireMouseEntered(e);
            }
        }

        public void mouseExited(MouseEvent e) {
            synchronized ( m_vis ) {      
                if ( !mouseDown && activeItem != null ) {
                    // we've left the component and an item 
                    // is active but not being dragged, deactivate it
                    fireItemExited(activeItem, e);
                    activeItem = null;
                }
                fireMouseExited(e);
            }
        }

        public void keyPressed(KeyEvent e) {
            synchronized ( m_vis ) {
                if ( activeItem != null ) {
                    if ( validityCheck() )
                        fireItemKeyPressed(activeItem, e);
                } else {
                    fireKeyPressed(e);
                }
            }
        }

        public void keyReleased(KeyEvent e) {
            synchronized ( m_vis ) {
                if ( activeItem != null ) {
                    if ( validityCheck() )
                        fireItemKeyReleased(activeItem, e);
                } else {
                    fireKeyReleased(e);
                }
            }
        }

        public void keyTyped(KeyEvent e) {
            synchronized ( m_vis ) {
                if ( activeItem != null ) {
                    if ( validityCheck() )
                        fireItemKeyTyped(activeItem, e);
                } else {
                    fireKeyTyped(e);
                }
            }
        }
        
        private boolean isOffComponent(MouseEvent e) {
            int x = e.getX(), y = e.getY();
            return ( x<0 || x>getWidth() || y<0 || y>getHeight() );
        }
        
        // --------------------------------------------------------------------
        // Fire Event Notifications
        
        private void fireItemDragged(VisualItem item, MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemDragged(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemMoved(VisualItem item, MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemMoved(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemWheelMoved(VisualItem item, MouseWheelEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemWheelMoved(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemClicked(VisualItem item, MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemClicked(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemPressed(VisualItem item, MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemPressed(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemReleased(VisualItem item, MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemReleased(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemEntered(VisualItem item, MouseEvent e) {
            item.setHover(true);
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemEntered(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemExited(VisualItem item, MouseEvent e) {
            if ( item.isValid() ) item.setHover(false);
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemExited(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemKeyPressed(VisualItem item, KeyEvent e) {
            Object[] lstnrs = m_controls.getArray();
            if (lstnrs.length == 0)
                return;
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemKeyPressed(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemKeyReleased(VisualItem item, KeyEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemKeyReleased(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemKeyTyped(VisualItem item, KeyEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemKeyTyped(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireMouseEntered(MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.mouseEntered(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireMouseExited(MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.mouseExited(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireMousePressed(MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.mousePressed(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireMouseReleased(MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.mouseReleased(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireMouseClicked(MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.mouseClicked(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireMouseDragged(MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.mouseDragged(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireMouseMoved(MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.mouseMoved(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireMouseWheelMoved(MouseWheelEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.mouseWheelMoved(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireKeyPressed(KeyEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.keyPressed(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireKeyReleased(KeyEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.keyReleased(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireKeyTyped(KeyEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.keyTyped(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }
        
    } // end of inner class MouseEventCapturer
    
    
    // ------------------------------------------------------------------------
    // Text Editing
    
    /**
     * Returns the TextComponent used for on-screen text editing.
     * @@return the TextComponent used for text editing
     */
    public JTextComponent getTextEditor() {
        return m_editor;
    }
    
    /**
     * Sets the TextComponent used for on-screen text editing.
     * @@param tc the TextComponent to use for text editing
     */
    public void setTextEditor(JTextComponent tc) {
        this.remove(m_editor);
        m_editor = tc;
        this.add(m_editor, 1);
    }
    
    /**
     * Edit text for the given VisualItem and attribute. Presents a text
     * editing widget spaning the item's bounding box. Use stopEditing()
     * to hide the text widget. When stopEditing() is called, the data field
     * will automatically be updated with the VisualItem.
     * @@param item the VisualItem to edit
     * @@param attribute the attribute to edit
     */
    public void editText(VisualItem item, String attribute) {
        if ( m_editing ) { stopEditing(); }
        Rectangle2D b = item.getBounds();
        Rectangle r = m_transform.createTransformedShape(b).getBounds();
        
        // hacky placement code that attempts to keep text in same place
        // configured under Windows XP and Java 1.4.2b
        if ( m_editor instanceof JTextArea ) {
            r.y -= 2; r.width += 22; r.height += 2;
        } else {
            r.x += 3; r.y += 1; r.width -= 5; r.height -= 2;
        }
        
        Font f = getFont();
        int size = (int)Math.round(f.getSize()*m_transform.getScaleX());
        Font nf = new Font(f.getFontName(), f.getStyle(), size);
        m_editor.setFont(nf);
        
        editText(item, attribute, r);
    }
    
    /**
     * Edit text for the given VisualItem and field. Presents a text
     * editing widget spaning the given bounding box. Use stopEditing()
     * to hide the text widget. When stopEditing() is called, the field
     * will automatically be updated with the VisualItem.
     * @@param item the VisualItem to edit
     * @@param attribute the attribute to edit
     * @@param r Rectangle representing the desired bounding box of the text
     *  editing widget
     */
    public void editText(VisualItem item, String attribute, Rectangle r) {
        if ( m_editing ) { stopEditing(); }
        String txt = item.getString(attribute);
        m_editItem = item;
        m_editAttribute = attribute;
        Color tc = ColorLib.getColor(item.getTextColor());
        Color fc = ColorLib.getColor(item.getFillColor());
        m_editor.setForeground(tc);
        m_editor.setBackground(fc);
        editText(txt, r);
    }
    
    /**
     * Show a text editing widget containing the given text and spanning the
     * specified bounding box. Use stopEditing() to hide the text widget. Use
     * the method calls getTextEditor().getText() to get the resulting edited
     * text.
     * @@param txt the text string to display in the text widget
     * @@param r Rectangle representing the desired bounding box of the text
     *  editing widget
     */
    public void editText(String txt, Rectangle r) {
        if ( m_editing ) { stopEditing(); }
        m_editing = true;
        m_editor.setBounds(r.x,r.y,r.width,r.height);
        m_editor.setText(txt);
        m_editor.setVisible(true);
        m_editor.setCaretPosition(txt.length());
        m_editor.requestFocus();
    }
    
    /**
     * Stops text editing on the display, hiding the text editing widget. If
     * the text editor was associated with a specific VisualItem (ie one of the
     * editText() methods which include a VisualItem as an argument was called),
     * the item is updated with the edited text.
     */
    public void stopEditing() {
        m_editor.setVisible(false);
        if ( m_editItem != null ) {
            String txt = m_editor.getText();
            m_editItem.set(m_editAttribute, txt);
            m_editItem = null;
            m_editAttribute = null;
            m_editor.setBackground(null);
            m_editor.setForeground(null);
        }
        m_editing = false;
    }
    
} // end of class Display
@


2.10.4.1
log
@First import of a Java 1.5-targetted version of prefuse.
@
text
@d28 1
a28 1
import java.util.concurrent.CopyOnWriteArrayList;
d50 1
d70 1
a70 1
 *
d72 1
a72 1
 * drawn, the Display also maintains an optional
d79 1
a79 1
 *
d85 1
a85 1
 *
d87 1
a87 1
 * the <code>java.awt.geom.AffineTransform</code> class. The
d89 2
a90 2
 * allows arbitrary transforms to be applied, while the
 * {@@link #pan(double,double) pan} and
d94 1
a94 1
 *
d98 1
a98 1
 *
d107 1
a107 1
    private static final Logger s_logger
d109 1
a109 1

d113 1
a113 1

d115 4
a118 4
    protected CopyOnWriteArrayList<Control> m_controls = new CopyOnWriteArrayList<Control>();
    protected CopyOnWriteArrayList<PaintListener> m_painters;
    protected CopyOnWriteArrayList<ItemBoundsListener> m_bounders;

d127 1
a127 1

d130 1
a130 1

d134 1
a134 1

d140 1
a140 1

d144 1
a144 1
    private final int sampleInterval = 10;
d146 1
a146 1

d149 1
a149 1

d153 1
a153 1
    private VisualItem<?>     m_editItem;
d155 1
a155 1

d163 1
a163 1

d173 1
a173 1

d189 1
a189 1

d200 1
a200 1

d207 1
a207 1

d214 1
a214 1

d216 1
a216 1

d219 1
a219 2
            @@Override
			public void update(Object src) { damageReport(); }
d221 1
a221 1

d226 11
a236 1

d263 1
a263 1

d272 1
a272 1

d280 1
a280 1

d287 1
a287 2
    @@Override
	public void setSize(int width, int height) {
d292 1
a292 1

d298 1
a298 2
    @@Override
	public void setSize(Dimension d) {
d309 1
a309 2
    @@Override
	public void invalidate() {
d313 1
a313 1

d317 1
a317 2
    @@Override
	public void setBounds(int x, int y, int w, int h) {
d321 1
a321 1

d327 1
a327 2
    @@Override
	public void setFont(Font f) {
d331 1
a331 1

d339 1
a339 1

d347 2
a348 3
        if ( m_highQuality != on ) {
			damageReport();
		}
d351 1
a351 1

d360 1
a360 1

d368 1
a368 1

d370 1
a370 1
     * Set the Visualization associated with this Display. This Display
d386 2
a387 3
        if ( m_vis != null ) {
			m_vis.addDisplay(this);
		}
d389 1
a389 1

d416 1
a416 1

d429 1
a429 1

d439 1
a439 1

d454 1
d460 1
a460 1

d464 1
a464 1
     * @@param image the background Image. If a null value is provided,
d476 2
a477 3
        if ( image != null ) {
			bg = new BackgroundPainter(image, fixed, tileImage);
		}
d498 3
a500 4
        if ( location != null ) {
			bg = new BackgroundPainter(location, fixed, tileImage);
		}
        setBackgroundPainter(bg);
d502 1
a502 1

d504 2
a505 3
        if ( m_bgpainter != null ) {
			removePaintListener(m_bgpainter);
		}
d507 2
a508 3
        if ( bg != null ) {
			addPaintListener(bg);
		}
d510 1
a510 1

d522 1
a522 2
    @@Override
	public JToolTip createToolTip() {
d529 1
a529 1

d545 1
a545 1

d554 1
a554 1

d557 1
a557 1

d580 1
a580 1

d604 1
a604 1

d610 2
a611 3
        if ( m_damageRedraw ) {
			m_clip.union(region);
		}
d613 1
a613 1

d620 1
a620 1

d628 2
a629 3
        if ( m_damageRedraw ) {
			m_clip.reset();
		}
d631 1
a631 1

d647 1
a647 1
     * @@return the bounding box of all visible VisualItems
d654 1
a654 1

d657 1
a657 1

d665 1
a665 1

d684 1
a684 1

d704 1
a704 1

d713 1
a713 1

d726 1
a726 2
    @@Override
	public void update(Graphics g) {
d729 1
a729 1

d757 2
a758 3
        if ( m_transform != null ) {
			g.transform(m_transform);
		}
d761 1
a761 1

d789 1
a789 2
    @@Override
	public void paintComponent(Graphics g) {
d796 1
a796 1

d799 1
a799 1

d802 2
a803 2
        paintBufferToScreen(g2D);

d806 1
a806 1

d808 1
a808 1

d816 1
a816 1
            frameRate = 1000.0*nframes/(t-mark);
d821 1
a821 1

d831 4
a834 5

            if ( m_clip.isEmpty() ) {
				return; // no damage, no render
			}

d838 1
a838 1

d843 2
a844 2

            if ( m_damageRedraw ) {
d852 1
a852 1

d855 1
a855 1

d858 1
a858 1

d861 1
a861 1
                        m_clip.getMinX(), m_clip.getMinY(),
d864 1
a864 1

d877 1
a877 1

d880 1
a880 1

d886 2
a887 2
            clearRegion(g2D, m_rclip);

d890 1
a890 1

d894 1
a894 1

d897 3
a899 2
            m_visibleCount = 0;
            for(VisualItem<?> item : m_vis.items(m_predicate)) {
d902 5
a906 8

                if ( m_clip.intersects(bounds, pixel) ) {
					m_queue.addToRenderQueue(item);
				}
                if ( item.isInteractive() ) {
					m_queue.addToPickingQueue(item);
				}
                m_visibleCount++;
d908 1
a908 1

d911 1
a911 1

d916 1
a916 1

d918 3
a920 4
            if ( m_damageRedraw ) {
				m_clip.reset();
			}

d923 1
a923 1

d926 1
a926 1

d932 1
a932 1
    public void renderImmediate(VisualItem<?> item) {
d937 1
a937 1

d942 1
a942 1
     *
d945 1
a945 1
     *
d948 1
a948 2
    @@Override
	protected void printComponent(Graphics g) {
d960 1
a960 1

d964 1
a964 1
     */
d974 1
a974 1

d982 1
a982 1
    public synchronized void setTransform(AffineTransform transform)
d989 1
a989 1

d992 1
a992 1
     * Changes made to this reference WILL corrupt the state of
d999 1
a999 1

d1009 1
a1009 1

d1016 1
a1016 1
     *  this value is null, a new Point2D instance will be created and
d1023 1
a1023 1

d1033 1
a1033 1

d1035 1
a1035 1
     * Returns the x-coordinate of the top-left of the display,
d1042 1
a1042 1

d1044 1
a1044 1
     * Returns the y-coordinate of the top-left of the display,
d1051 1
a1051 1

d1058 10
a1067 3
        double panx = dx / m_transform.getScaleX();
        double pany = dy / m_transform.getScaleY();
        panAbs(panx,pany);
d1069 1
a1069 1

d1083 1
a1083 1

d1085 1
a1085 1
     * Pans the display view to center on the provided point in
d1093 1
a1093 1

d1095 1
a1095 1
     * Pans the display view to center on the provided point in
d1102 2
a1103 2
        double x = p.getX(); x = Double.isNaN(x) ? 0 : x;
        double y = p.getY(); y = Double.isNaN(y) ? 0 : y;
d1106 3
a1108 3

        double dx = x-m_transform.getTranslateX()/sx;
        double dy = y-m_transform.getTranslateY()/sy;
d1126 2
a1127 2
    }

d1145 1
a1145 1

d1155 2
a1156 2
    }

d1176 1
a1176 1
     * Animate a pan along the specified distance in screen (pixel)
d1187 1
a1187 1

d1198 1
a1198 1

d1200 1
a1200 1
     * Animate a pan to the specified location in screen (pixel)
d1210 1
a1210 1

d1212 1
a1212 1
     * Animate a pan to the specified location in absolute (item-space)
d1220 2
a1221 2
        double x = p.getX(); x = Double.isNaN(x) ? 0 : x;
        double y = p.getY(); y = Double.isNaN(y) ? 0 : y;
d1228 1
a1228 1

d1230 1
a1230 1
     * Animate a zoom centered on a given location in screen (pixel)
d1241 1
a1241 1

d1243 1
a1243 1
     * Animate a zoom centered on a given location in absolute (item-space)
d1252 1
a1252 1

d1254 1
a1254 1
     * Animate a pan to the specified location in screen (pixel)
d1265 1
a1265 1

d1267 1
a1267 1
     * Animate a pan to the specified location in absolute (item-space)
d1276 1
a1276 1

d1284 1
a1284 1

d1292 3
a1294 3

        private final double[] src, dst;
        private final AffineTransform m_at;
d1303 4
a1306 5
            if ( this.isScheduled() ) {
				m_at.setTransform(dst[0],dst[1],dst[2],dst[3],dst[4],dst[5]);
			} else {
				m_at.setTransform(m_transform);
			}
d1313 1
a1313 1

d1316 2
a1317 2
            double x = p.getX(); x = Double.isNaN(x) ? 0 : x;
            double y = p.getY(); y = Double.isNaN(y) ? 0 : y;
d1327 1
a1327 1

d1353 1
a1353 2
        @@Override
		protected void run(long elapsedTime) {
d1370 1
a1370 1

d1373 1
a1373 1

d1380 2
a1381 3
        if ( m_painters == null ) {
			m_painters = new CopyOnWriteArrayList<PaintListener>();
		}
d1384 1
a1384 1

d1392 1
a1392 1

d1398 3
a1400 2
        if ( m_painters != null) {
        	for(PaintListener l : m_painters) {
d1402 1
a1402 1
                    l.prePaint(this, g);
d1411 1
a1411 1

d1417 3
a1419 2
        if ( m_painters != null ) {
        	for(PaintListener l : m_painters) {
d1421 1
a1421 1
                    l.postPaint(this, g);
d1430 2
a1431 2


d1434 1
a1434 1

d1441 2
a1442 3
        if ( m_bounders == null ) {
			m_bounders = new CopyOnWriteArrayList<ItemBoundsListener>();
		}
d1445 1
a1445 1

d1454 1
a1454 1

d1460 6
a1465 6
        if ( m_bounds.equals(prev) ) {
			return; // nothing to do
		}

        if ( m_bounders != null ) {
        	for(ItemBoundsListener l : m_bounders) {
d1467 1
a1467 1
                    l.itemBoundsChanged(this);
d1476 2
a1477 2


d1480 1
a1480 1

d1496 1
a1496 1

d1502 1
a1502 1
    public synchronized VisualItem<?> findItem(Point p) {
d1504 2
a1505 2
        Point2D p2 = m_itransform==null ? p :
                      m_itransform.transform(p, m_tmpPoint);
d1507 2
a1508 3
        if ( !m_queue.psorted ) {
			m_queue.sortPickingQueue();
		}
d1511 2
a1512 4
            VisualItem<?> vi = m_queue.pitems[i];
            if ( !vi.isValid() ) {
				continue; // in case tuple went invalid
			}
d1520 1
a1520 1

d1522 1
a1522 1
     * Captures all mouse and key events on the display, detects relevant
d1525 1
a1525 1
    public class InputEventCapturer implements MouseMotionListener,
d1528 1
a1528 1
        private VisualItem<?> activeItem = null;
d1532 2
a1533 3
            if ( activeItem.isValid() ) {
				return true;
			}
d1537 1
a1537 1

d1541 2
a1542 3
                    if ( validityCheck() ) {
						fireItemDragged(activeItem, e);
					}
d1553 1
a1553 1
                VisualItem<?> vi = findItem(e.getPoint());
d1555 2
a1556 3
                    if ( validityCheck() ) {
						fireItemExited(activeItem, e);
					}
d1564 2
a1565 4
                if ( earlyReturn ) {
					return;
				}

d1578 2
a1579 3
                    if ( validityCheck() ) {
						fireItemWheelMoved(activeItem, e);
					}
d1589 2
a1590 3
                    if ( validityCheck() ) {
						fireItemClicked(activeItem, e);
					}
d1596 1
a1596 1

d1602 2
a1603 3
                    if ( validityCheck() ) {
						fireItemPressed(activeItem, e);
					}
d1613 2
a1614 3
                    if ( validityCheck() ) {
						fireItemReleased(activeItem, e);
					}
d1619 1
a1619 1
                    // mouse was dragged off of the component,
d1635 1
a1635 1
            synchronized ( m_vis ) {
d1637 1
a1637 1
                    // we've left the component and an item
d1649 2
a1650 3
                    if ( validityCheck() ) {
						fireItemKeyPressed(activeItem, e);
					}
d1660 2
a1661 3
                    if ( validityCheck() ) {
						fireItemKeyReleased(activeItem, e);
					}
d1671 2
a1672 3
                    if ( validityCheck() ) {
						fireItemKeyTyped(activeItem, e);
					}
d1678 1
a1678 1

d1681 1
a1681 1
            return x<0 || x>getWidth() || y<0 || y>getHeight();
d1683 1
a1683 1

d1686 7
a1692 5

        private void fireItemDragged(VisualItem<?> item, MouseEvent e) {
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1698 1
				}
d1702 6
a1707 4
        private void fireItemMoved(VisualItem<?> item, MouseEvent e) {
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1713 1
				}
d1717 6
a1722 4
        private void fireItemWheelMoved(VisualItem<?> item, MouseWheelEvent e) {
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1728 1
				}
d1732 6
a1737 4
        private void fireItemClicked(VisualItem<?> item, MouseEvent e) {
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1743 1
				}
d1747 6
a1752 4
        private void fireItemPressed(VisualItem<?> item, MouseEvent e) {
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1758 1
				}
d1762 6
a1767 4
        private void fireItemReleased(VisualItem<?> item, MouseEvent e) {
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1773 1
				}
d1777 1
a1777 1
        private void fireItemEntered(VisualItem<?> item, MouseEvent e) {
d1779 5
a1783 3
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1789 1
				}
d1793 7
a1799 7
        private void fireItemExited(VisualItem<?> item, MouseEvent e) {
            if ( item.isValid() ) {
				item.setHover(false);
			}
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1805 1
				}
d1809 8
a1816 4
        private void fireItemKeyPressed(VisualItem<?> item, KeyEvent e) {
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1822 1
				}
d1826 6
a1831 4
        private void fireItemKeyReleased(VisualItem<?> item, KeyEvent e) {
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1837 1
				}
d1841 6
a1846 4
        private void fireItemKeyTyped(VisualItem<?> item, KeyEvent e) {
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1852 1
				}
d1857 5
a1861 3
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1867 1
				}
d1872 5
a1876 3
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1882 1
				}
d1887 5
a1891 3
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1897 1
				}
d1902 5
a1906 3
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1912 1
				}
d1917 5
a1921 3
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1927 1
				}
d1932 5
a1936 3
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1942 1
				}
d1947 5
a1951 3
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1957 1
				}
d1962 5
a1966 3
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1972 1
				}
d1977 5
a1981 3
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a1987 1
				}
d1992 5
a1996 3
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a2002 1
				}
d2007 5
a2011 3
            for(Control ctrl : m_controls) {
                if (ctrl.isEnabled()) {
					try {
a2017 1
				}
d2020 1
a2020 1

d2022 2
a2023 2


d2026 1
a2026 1

d2034 1
a2034 1

d2044 1
a2044 1

d2053 1
a2053 1
    public void editText(VisualItem<?> item, String attribute) {
d2057 1
a2057 1

d2065 1
a2065 1

d2070 1
a2070 1

d2073 1
a2073 1

d2084 1
a2084 1
    public void editText(VisualItem<?> item, String attribute, Rectangle r) {
d2095 1
a2095 1

d2114 1
a2114 1

d2133 1
a2133 1

@


2.10.4.2
log
@fixed a typo
@
text
@d639 1
a639 1
     * @@return the bounding box of all visible VisualItems
@


2.10.4.3
log
@Allow the display to be zoomed in x/y dimensions separately (animation support too)
@
text
@d694 2
a695 5
     * @@param scaleX how much to scale the image by in the x-dimension. For example,
     * a value of 2.0 will result in an image with twice the pixel width of this
     * Display.
     * @@param scaleY how much to scale the image by in the y-dimension. For example,
     * a value of 2.0 will result in an image with twice the pixel height of this
d699 1
a699 1
    public boolean saveImage(OutputStream output, String format, double scaleX, double scaleY)
d703 2
a704 2
            Dimension d = new Dimension((int)(scaleX*getWidth()),
                                        (int)(scaleY*getHeight()));
d710 1
a710 1
            zoom(p, scaleX, scaleY); // also takes care of damage report
d715 1
a715 1
            zoom(p, 1/scaleX, 1/scaleY); // also takes care of damage report
d849 1
a849 2

            double pixel = 1.0 + 1.0 / Math.min(getScaleX(), getScaleY());
d1036 4
a1039 3
     * Returns the current scale (zoom) value along the x-dimension. This will usually
     * have the same value as getScaleY().
     * @@return the scaling factor along the x-dimension.
d1041 1
a1041 1
    public double getScaleX() {
a1045 9
     * Returns the current scale (zoom) value along the y-dimension. This will usually
     * have the same value as getScaleX().
     * @@return the scaling factor along the y-dimension.
     */
    public double getScaleY() {
        return m_transform.getScaleY();
    }

    /**
d1127 1
a1127 1
    public synchronized void zoom(final Point2D p, double scaleX, double scaleY) {
d1129 1
a1129 1
        zoomAbs(m_tmpPoint, scaleX, scaleY);
d1139 1
a1139 1
    public synchronized void zoomAbs(final Point2D p, double scaleX, double scaleY) {
d1143 1
a1143 1
        m_transform.scale(scaleX, scaleY);
d1237 1
a1237 2
     * @@param scaleX the scale factor (X) to zoom by
     * @@param scaleY the scale factor (Y) to zoom by
d1240 1
a1240 1
    public synchronized void animateZoom(final Point2D p, double scaleX, double scaleY, long duration) {
d1243 1
a1243 1
        animateZoomAbs(pp, scaleX, scaleY, duration);
d1250 1
a1250 2
     * @@param scaleX the scale factor (X) to zoom by
     * @@param scaleY the scale factor (Y) to zoom by
d1253 2
a1254 2
    public synchronized void animateZoomAbs(final Point2D p, double scaleX, double scaleY, long duration) {
        m_transact.zoom(p, scaleX, scaleY, duration);
d1261 1
a1261 2
     * @@param scaleX the scale factor (X) to zoom by
     * @@param scaleY the scale factor (Y) to zoom by
d1264 1
a1264 1
    public synchronized void animatePanAndZoomTo(final Point2D p, double scaleX, double scaleY, long duration) {
d1267 1
a1267 1
        animatePanAndZoomToAbs(pp, scaleX, scaleY, duration);
d1274 1
a1274 2
     * @@param scaleX the scale factor (X) to zoom by
     * @@param scaleY the scale factor (Y) to zoom by
d1277 2
a1278 2
    public synchronized void animatePanAndZoomToAbs(final Point2D p, double scaleX, double scaleY, long duration) {
        m_transact.panAndZoom(p, scaleX, scaleY, duration);
d1293 2
a1294 2

    	// TODO: change mechanism so that multiple transform
d1306 1
a1306 2

        private void prepareChange(long duration) {
d1312 4
a1317 7
        }

        private void startChange() {
            m_at.getMatrix(dst);
            m_transform.getMatrix(src);
            this.run();
        }
d1319 1
a1319 3
        public void panAndZoom(final Point2D p, double scaleX, double scaleY, long duration) {
        	prepareChange(duration);
        	m_tmpPoint.setLocation(0,0);
d1327 9
a1335 5
            m_at.translate(dx,dy);
            m_at.translate(p.getX(), p.getY());
            m_at.scale(scaleX, scaleY);
            m_at.translate(-p.getX(), -p.getY());
            startChange();
d1338 7
a1344 3
        	prepareChange(duration);
            m_at.translate(dx,dy);
            startChange();
d1346 4
a1349 2
        public void zoom(final Point2D p, double scaleX, double scaleY, long duration) {
        	prepareChange(duration);
d1351 6
a1356 4
            m_at.translate(zx, zy);
            m_at.scale(scaleX, scaleY);
            m_at.translate(-zx, -zy);
            startChange();
@


2.10.4.4
log
@Documentation improvements
@
text
@d90 1
a90 1
 * {@@link #zoom(java.awt.geom.Point2D,double,double) zoom}
d1137 1
a1137 2
     * @@param scaleX the amount to zoom by in the x-dimension
     * @@param scaleY the amount to zoom by in the y-dimension
d1149 1
a1149 2
     * @@param scaleX the amount to zoom by in the x-dimension
     * @@param scaleY the amount to zoom by in the y-dimension
@


2.10.4.5
log
@Added a destroy() method to assist with garbage collection
@
text
@a226 33

    /**
     * Clears out lots of references from the Display. This should be called when you are finished with the Display.
     */
    public synchronized void destroy() {
    	setVisualization(null);
    	if(m_predicate != null) {
    		m_predicate.clear();
    		m_predicate = null;
    	}
    	if(m_controls != null) {
    		m_controls.clear();
    		m_controls = null;
    	}
    	if(m_painters != null) {
    		m_painters.clear();
    		m_painters = null;
    	}
    	if(m_bounders != null) {
    		m_bounders.clear();
    		m_bounders = null;
    	}
    	m_offscreen = null;
    	m_bgpainter = null;
    	if(m_queue != null) {
    		m_queue.clear();
    		m_queue = null;
    	}
    	m_customToolTip = null;
    	m_editor = null;
    	m_editItem = null;
    }

@


2.10.4.6
log
@The beginnings of some printing functionality
@
text
@a55 1
import prefuse.util.display.PrintDisplayAction;
a265 1
     *     <li><b>ctrl P</b> - Print the display</li></ul>
a301 6

        try {
            registerKeyboardAction(new PrintDisplayAction(this),
             "print display", KeyStroke.getKeyStroke("ctrl P"), WHEN_FOCUSED);
        } catch (SecurityException se) {
        }
a996 1
    	boolean wasDoubleBuffered = isDoubleBuffered();
a998 1
    		setDoubleBuffered(false);
a1005 1
            setDoubleBuffered(wasDoubleBuffered);
@


2.10.4.7
log
@Testing volatile images instead of buffered images - this leads to greater hardware acceleration at the cost of increased image volatility. No code has been added to test if the image still exists in video memory. If anyone encounters any issues, please let me know (Jonathan Giles)
@
text
@d26 1
a26 1
import java.awt.image.VolatileImage;
d62 1
d64 4
a67 4
 * <p>
 * User interface component that provides an interactive view onto a visualization. The Display is
 * responsible for drawing items to the screen and providing callbacks for user interface actions
 * such as mouse and keyboard events. A Display must be associated with an
d70 8
a77 23
 * 
 * <p>
 * To control which {@@link prefuse.visual.VisualItem} instances are drawn, the Display also
 * maintains an optional {@@link prefuse.data.expression.Predicate} for filtering items. The drawing
 * order of items is controlled by an {@@link prefuse.visual.sort.ItemSorter} instance, which
 * calculates a score for each item. Items with higher scores are drawn later, and hence on top of
 * lower scoring items.
 * </p>
 * 
 * <p>
 * The {@@link prefuse.controls.Control Control} interface provides the user interface callbacks for
 * supporting interaction. The {@@link prefuse.controls} package contains a number of pre-built
 * <code>Control</code> implementations for common interactions.
 * </p>
 * 
 * <p>
 * The Display class also supports arbitrary graphics transforms through the
 * <code>java.awt.geom.AffineTransform</code> class. The
 * {@@link #setTransform(java.awt.geom.AffineTransform) setTransform} method allows arbitrary
 * transforms to be applied, while the {@@link #pan(double,double) pan} and
 * {@@link #zoom(java.awt.geom.Point2D,double,double) zoom} methods provide convenience methods that
 * appropriately update the current transform to achieve panning and zooming of the presentation
 * space.
d79 20
a98 6
 * 
 * <p>
 * Additionally, each Display instance also supports use of a text editor to facilitate direct
 * editing of text. See the various {@@link #editText(prefuse.visual.VisualItem, String)} methods.
 * </p>
 * 
d107 2
a108 209
	private static final Logger s_logger = Logger.getLogger(Display.class.getName());

	// visual item source
	protected Visualization m_vis;
	protected AndPredicate m_predicate = new AndPredicate();

	// listeners
	protected CopyOnWriteArrayList<Control> m_controls = new CopyOnWriteArrayList<Control>();
	protected CopyOnWriteArrayList<PaintListener> m_painters;
	protected CopyOnWriteArrayList<ItemBoundsListener> m_bounders;

	// display
	protected VolatileImage m_offscreen;
	protected Clip m_clip = new Clip();
	protected Clip m_screen = new Clip();
	protected Clip m_bounds = new Clip();
	protected Rectangle2D m_rclip = new Rectangle2D.Double();
	protected boolean m_damageRedraw = true;
	protected boolean m_highQuality = false;

	// optional background image
	protected BackgroundPainter m_bgpainter = null;

	// rendering queue
	protected RenderingQueue m_queue = new RenderingQueue();
	protected int m_visibleCount = 0;

	// transform variables
	protected AffineTransform m_transform = new AffineTransform();
	protected AffineTransform m_itransform = new AffineTransform();
	protected TransformActivity m_transact = new TransformActivity();
	protected Point2D m_tmpPoint = new Point2D.Double();

	// frame count and debugging output
	protected double frameRate;
	protected int nframes = 0;
	private final int sampleInterval = 10;
	private long mark = -1L;

	/* Custom tooltip, null to use regular tooltip mechanisms */
	protected JToolTip m_customToolTip = null;

	// text editing variables
	private JTextComponent m_editor;
	private boolean m_editing;
	private VisualItem<?> m_editItem;
	private String m_editAttribute;

	/**
	 * Creates a new Display instance. You will need to associate this Display with a
	 * {@@link Visualization} for it to display anything.
	 */
	public Display() {
		this(null);
	}

	/**
	 * Creates a new Display associated with the given Visualization. By default, all
	 * {@@link prefuse.visual.VisualItem} instances in the {@@link Visualization} will be drawn by the
	 * Display.
	 * 
	 * @@param visualization
	 *            the {@@link Visualization} backing this Display
	 */
	public Display(final Visualization visualization) {
		this(visualization, (Predicate) null);
	}

	/**
	 * Creates a new Display associated with the given Visualization that draws all VisualItems in
	 * the visualization that pass the given Predicate. The predicate string will be parsed by the
	 * {@@link prefuse.data.expression.parser.ExpressionParser} to get a
	 * {@@link prefuse.data.expression.Predicate} instance.
	 * 
	 * @@param visualization
	 *            the {@@link Visualization} backing this Display
	 * @@param predicate
	 *            a predicate expression in the prefuse expression language. This expression will be
	 *            parsed; if the parsing fails or does not result in a Predicate instance, an
	 *            exception will result.
	 */
	public Display(final Visualization visualization, final String predicate) {
		this(visualization, (Predicate) ExpressionParser.parse(predicate, true));
	}

	/**
	 * Creates a new Display associated with the given Visualization that draws all VisualItems in
	 * the visualization that pass the given Predicate.
	 * 
	 * @@param visualization
	 *            the {@@link Visualization} backing this Display
	 * @@param predicate
	 *            the filtering {@@link prefuse.data.expression.Predicate}
	 */
	public Display(final Visualization visualization, final Predicate predicate) {
		setDoubleBuffered(false);
		setBackground(Color.WHITE);

		// initialize text editor
		m_editing = false;
		m_editor = new JTextField();
		m_editor.setBorder(null);
		m_editor.setVisible(false);
		this.add(m_editor);

		// register input event capturer
		final InputEventCapturer iec = new InputEventCapturer();
		addMouseListener(iec);
		addMouseMotionListener(iec);
		addMouseWheelListener(iec);
		addKeyListener(iec);

		registerDefaultCommands();

		// invalidate the display when the filter changes
		m_predicate.addExpressionListener(new UpdateListener() {
			@@Override
			public void update(final Object src) {
				damageReport();
			}
		});

		setVisualization(visualization);
		setPredicate(predicate);
		setSize(400, 400); // set a default size
	}

	/**
	 * Clears out lots of references from the Display. This should be called when you are finished
	 * with the Display.
	 */
	public synchronized void destroy() {
		setVisualization(null);
		if (m_predicate != null) {
			m_predicate.clear();
			m_predicate = null;
		}
		if (m_controls != null) {
			m_controls.clear();
			m_controls = null;
		}
		if (m_painters != null) {
			m_painters.clear();
			m_painters = null;
		}
		if (m_bounders != null) {
			m_bounders.clear();
			m_bounders = null;
		}
		m_offscreen = null;
		m_bgpainter = null;
		if (m_queue != null) {
			m_queue.clear();
			m_queue = null;
		}
		m_customToolTip = null;
		m_editor = null;
		m_editItem = null;
	}

	/**
	 * Registers default keystroke commands on the Display. The default commands are
	 * <ul>
	 * <li><b>ctrl D</b> - Toggle debug info display</li>
	 * <li><b>ctrl H</b> - Toggle high quality rendering</li>
	 * <li><b>ctrl E</b> - Export display view to an image file</li>
	 * </ul>
	 * <li><b>ctrl P</b> - Print the display</li>
	 * </ul>
	 * Subclasses can override this method to prevent these commands from being set. Additional
	 * commands can be registered using the <code>registerKeyboardAction</code> method.
	 */
	protected void registerDefaultCommands() {
		// add debugging output control
		registerKeyboardAction(new ActionListener() {
			private PaintListener m_debug = null;

			public void actionPerformed(final ActionEvent e) {
				if (m_debug == null) {
					m_debug = new DebugStatsPainter();
					addPaintListener(m_debug);
				} else {
					removePaintListener(m_debug);
					m_debug = null;
				}
				repaint();
			}
		}, "debug info", KeyStroke.getKeyStroke("ctrl D"), WHEN_FOCUSED);

		// add quality toggle
		registerKeyboardAction(new ActionListener() {
			public void actionPerformed(final ActionEvent e) {
				setHighQuality(!isHighQuality());
				repaint();
			}
		}, "toggle high-quality drawing", KeyStroke.getKeyStroke("ctrl H"), WHEN_FOCUSED);

		// add image output control, if this is not an applet
		try {
			registerKeyboardAction(new ExportDisplayAction(this), "export display", KeyStroke.getKeyStroke("ctrl E"),
					WHEN_FOCUSED);
		} catch (final SecurityException se) {
		}

		try {
			registerKeyboardAction(new PrintDisplayAction(this), "print display", KeyStroke.getKeyStroke("ctrl P"), WHEN_FOCUSED);
		} catch (final SecurityException se) {
		}
	}
d110 233
a342 36
	/**
	 * Set the size of the Display.
	 * 
	 * @@param width
	 *            the width of the Display in pixels
	 * @@param height
	 *            the height of the Display in pixels
	 * @@see java.awt.Component#setSize(int, int)
	 */
	@@Override
	public void setSize(final int width, final int height) {
		m_offscreen = null;
		setPreferredSize(new Dimension(width, height));
		super.setSize(width, height);
	}

	/**
	 * Set the size of the Display.
	 * 
	 * @@param d
	 *            the dimensions of the Display in pixels
	 * @@see java.awt.Component#setSize(java.awt.Dimension)
	 */
	@@Override
	public void setSize(final Dimension d) {
		m_offscreen = null;
		setPreferredSize(d);
		super.setSize(d);
	}

	/**
	 * Invalidates this component. Overridden to ensure that an internal damage report is generated.
	 * 
	 * @@see java.awt.Component#invalidate()
	 */
	@@Override
d344 40
a383 44
		damageReport();
		super.invalidate();
	}

	/**
	 * @@see java.awt.Component#setBounds(int, int, int, int)
	 */
	@@Override
	public void setBounds(final int x, final int y, final int w, final int h) {
		m_offscreen = null;
		super.setBounds(x, y, w, h);
	}

	/**
	 * Sets the font used by this Display. This determines the font used by this Display's text
	 * editor and in any debugging text.
	 * 
	 * @@param f
	 *            the Font to use
	 */
	@@Override
	public void setFont(final Font f) {
		super.setFont(f);
		m_editor.setFont(f);
	}

	/**
	 * Returns the running average frame rate for this Display.
	 * 
	 * @@return the frame rate
	 */
	public double getFrameRate() {
		return frameRate;
	}

	/**
	 * Determines if the Display uses a higher quality rendering, using anti-aliasing. This causes
	 * drawing to be much slower, however, and so is disabled by default.
	 * 
	 * @@param on
	 *            true to enable anti-aliased rendering, false to disable it
	 */
	public void setHighQuality(final boolean on) {
		if (m_highQuality != on) {
d386 2
a387 2
		m_highQuality = on;
	}
d389 35
a423 38
	/**
	 * Indicates if the Display is using high quality (return value true) or regular quality (return
	 * value false) rendering.
	 * 
	 * @@return true if high quality rendering is enabled, false otherwise
	 */
	public boolean isHighQuality() {
		return m_highQuality;
	}

	/**
	 * Returns the Visualization backing this Display.
	 * 
	 * @@return this Display's {@@link Visualization}
	 */
	public Visualization getVisualization() {
		return m_vis;
	}

	/**
	 * Set the Visualization associated with this Display. This Display will render the items
	 * contained in the provided visualization. If this Display is already associated with a
	 * different Visualization, the Display unregisters itself with the previous one.
	 * 
	 * @@param vis
	 *            the backing {@@link Visualization} to use.
	 */
	public void setVisualization(final Visualization vis) {
		// TODO: synchronization?
		if (m_vis == vis) {
			// nothing need be done
			return;
		} else if (m_vis != null) {
			// remove this display from it's previous registry
			m_vis.removeDisplay(this);
		}
		m_vis = vis;
		if (m_vis != null) {
d426 1
a426 14
	}

	/**
	 * Returns the filtering Predicate used to control what items are drawn by this display.
	 * 
	 * @@return the filtering {@@link prefuse.data.expression.Predicate}
	 */
	public Predicate getPredicate() {
		if (m_predicate.size() == 1) {
			return BooleanLiteral.TRUE;
		} else {
			return m_predicate.get(0);
		}
	}
d428 86
a513 74
	/**
	 * Sets the filtering Predicate used to control what items are drawn by this Display.
	 * 
	 * @@param expr
	 *            the filtering predicate to use. The predicate string will be parsed by the
	 *            {@@link prefuse.data.expression.parser.ExpressionParser}. If the parse fails or
	 *            does not result in a {@@link prefuse.data.expression.Predicate} instance, an
	 *            exception will be thrown.
	 */
	public void setPredicate(final String expr) {
		final Predicate p = (Predicate) ExpressionParser.parse(expr, true);
		setPredicate(p);
	}

	/**
	 * Sets the filtering Predicate used to control what items are drawn by this Display.
	 * 
	 * @@param p
	 *            the filtering {@@link prefuse.data.expression.Predicate} to use
	 */
	public synchronized void setPredicate(final Predicate p) {
		if (p == null) {
			m_predicate.set(VisiblePredicate.TRUE);
		} else {
			m_predicate.set(new Predicate[] { p, VisiblePredicate.TRUE });
		}
	}

	/**
	 * Returns the number of visible items processed by this Display. This includes items not
	 * currently visible on screen due to the current panning or zooming state.
	 * 
	 * @@return the count of visible items
	 */
	public int getVisibleItemCount() {
		return m_visibleCount;
	}

	/**
	 * Get the ItemSorter that determines the rendering order of the VisualItems. Items are drawn in
	 * ascending order of the scores provided by the ItemSorter.
	 * 
	 * @@return this Display's {@@link prefuse.visual.sort.ItemSorter}
	 */
	public ItemSorter getItemSorter() {
		return m_queue.sort;
	}

	/**
	 * Set the ItemSorter that determines the rendering order of the VisualItems. Items are drawn in
	 * ascending order of the scores provided by the ItemSorter.
	 */
	public synchronized void setItemSorter(final ItemSorter cmp) {
		damageReport();
		m_queue.sort = cmp;
	}

	/**
	 * Set a background image for this display.
	 * 
	 * @@param image
	 *            the background Image. If a null value is provided, than no background image will
	 *            be shown.
	 * @@param fixed
	 *            true if the background image should stay in a fixed position, invariant to
	 *            panning, zooming, or rotation; false if the image should be subject to view
	 *            transforms
	 * @@param tileImage
	 *            true to tile the image across the visible background, false to only include the
	 *            image once
	 */
	public synchronized void setBackgroundImage(final Image image, final boolean fixed, final boolean tileImage) {
		BackgroundPainter bg = null;
		if (image != null) {
d516 2
a517 2
		setBackgroundPainter(bg);
	}
d519 18
a536 18
	/**
	 * Set a background image for this display.
	 * 
	 * @@param location
	 *            a location String of where to retrieve the image file from. Uses
	 *            {@@link prefuse.util.io.IOLib#urlFromString(String)} to resolve the String. If a
	 *            null value is provided, than no background image will be shown.
	 * @@param fixed
	 *            true if the background image should stay in a fixed position, invariant to
	 *            panning, zooming, or rotation; false if the image should be subject to view
	 *            transforms
	 * @@param tileImage
	 *            true to tile the image across the visible background, false to only include the
	 *            image once
	 */
	public synchronized void setBackgroundImage(final String location, final boolean fixed, final boolean tileImage) {
		BackgroundPainter bg = null;
		if (location != null) {
d539 2
a540 2
		setBackgroundPainter(bg);
	}
d542 2
a543 2
	private void setBackgroundPainter(final BackgroundPainter bg) {
		if (m_bgpainter != null) {
d546 2
a547 2
		m_bgpainter = bg;
		if (bg != null) {
d550 1
a550 1
	}
d552 2
a553 2
	// ------------------------------------------------------------------------
	// ToolTips
d555 9
a563 9
	/**
	 * Returns the tooltip instance to use for this Display. By default, uses the normal Swing
	 * tooltips, returning the result of this same method invoked on the JComponent super-class. If
	 * a custom tooltip has been set, that is returned instead.
	 * 
	 * @@see #setCustomToolTip(JToolTip)
	 * @@see javax.swing.JComponent#createToolTip()
	 */
	@@Override
d565 88
a652 87
		if (m_customToolTip == null) {
			return super.createToolTip();
		} else {
			return m_customToolTip;
		}
	}

	/**
	 * Set a custom tooltip to use for this Display. To trigger tooltip display, you must still use
	 * the <code>setToolTipText</code> method as usual. The actual text will no longer have any
	 * effect, other than that a null text value will result in no tooltip display while a non-null
	 * text value will result in a tooltip being shown. Clients are responsible for setting the tool
	 * tip text to enable/disable tooltips as well as updating the content of their own custom
	 * tooltip instance.
	 * 
	 * @@param tooltip
	 *            the tooltip component to use
	 * @@see prefuse.util.ui.JCustomTooltip
	 */
	public void setCustomToolTip(final JToolTip tooltip) {
		m_customToolTip = tooltip;
	}

	/**
	 * Get the custom tooltip used by this Display. Returns null if normal tooltips are being used.
	 * 
	 * @@return the custom tooltip used by this Display, or null if none
	 */
	public JToolTip getCustomToolTip() {
		return m_customToolTip;
	}

	// ------------------------------------------------------------------------
	// Clip / Bounds Management

	/**
	 * Indicates if damage/redraw rendering is enabled. If enabled, the display will only redraw
	 * within the bounding box of all areas that have changed since the last rendering operation.
	 * For small changes, such as a single item being dragged, this can result in a significant
	 * performance increase. By default, the damage/redraw optimization is enabled. It can be
	 * disabled, however, if rendering artifacts are appearing in your visualization. Be careful
	 * though, as this may not be the best solution. Rendering artifacts may result because the item
	 * bounds returned by {@@link prefuse.visual.VisualItem#getBounds()} are not accurate and the
	 * item's {@@link prefuse.render.Renderer} is drawing outside of the reported bounds. In this
	 * case, there is usually a bug in the Renderer. One reported problem arises from Java itself,
	 * however, which inaccurately redraws images outside of their reported bounds. If you have a
	 * visulization with a number of images and are seeing rendering artifacts, try disabling
	 * damage/redraw.
	 * 
	 * @@return true if damage/redraw optimizations are enabled, false otherwise (in which case the
	 *         entire Display is redrawn upon a repaint)
	 */
	public synchronized boolean isDamageRedraw() {
		return m_damageRedraw;
	}

	/**
	 * Sets if damage/redraw rendering is enabled. If enabled, the display will only redraw within
	 * the bounding box of all areas that have changed since the last rendering operation. For small
	 * changes, such as a single item being dragged, this can result in a significant performance
	 * increase. By default, the damage/redraw optimization is enabled. It can be disabled, however,
	 * if rendering artifacts are appearing in your visualization. Be careful though, as this may
	 * not be the best solution. Rendering artifacts may result because the item bounds returned by
	 * {@@link prefuse.visual.VisualItem#getBounds()} are not accurate and the item's
	 * {@@link prefuse.render.Renderer} is drawing outside of the reported bounds. In this case,
	 * there is usually a bug in the Renderer. One reported problem arises from Java itself,
	 * however, which inaccurately redraws images outside of their reported bounds. If you have a
	 * visulization with a number of images and are seeing rendering artifacts, try disabling
	 * damage/redraw.
	 * 
	 * @@param b
	 *            true to enable damage/redraw optimizations, false otherwise (in which case the
	 *            entire Display will be redrawn upon a repaint)
	 */
	public synchronized void setDamageRedraw(final boolean b) {
		m_damageRedraw = b;
		m_clip.invalidate();
	}

	/**
	 * Reports damage to the Display within in the specified region.
	 * 
	 * @@param region
	 *            the damaged region, in absolute coordinates
	 */
	public synchronized void damageReport(final Rectangle2D region) {
		if (m_damageRedraw) {
d655 1
a655 1
	}
d657 15
a671 14
	/**
	 * Reports damage to the entire Display.
	 */
	public synchronized void damageReport() {
		m_clip.invalidate();
	}

	/**
	 * Clears any reports of damaged regions, causing the Display to believe that the display
	 * contents are up-to-date. If used incorrectly this can cause inaccurate rendering.
	 * <strong>Call this method only if you know what you are doing.</strong>
	 */
	public synchronized void clearDamage() {
		if (m_damageRedraw) {
d674 1
a674 1
	}
d676 130
a805 137
	/**
	 * Returns the bounds, in absolute (item-space) coordinates, of the total bounds occupied by all
	 * currently visible VisualItems. This method allocates a new Rectangle2D instance for the
	 * result.
	 * 
	 * @@return the bounding box of all visible VisualItems
	 * @@see #getItemBounds(Rectangle2D)
	 */
	public synchronized Rectangle2D getItemBounds() {
		return getItemBounds(new Rectangle2D.Double());
	}

	/**
	 * Returns the bounds, in absolute (item-space) coordinates, of the total bounds occupied by all
	 * currently visible VisualItems.
	 * 
	 * @@param b
	 *            the Rectangle2D to use to store the return value
	 * @@return the bounding box of all visible VisualItems
	 */
	public synchronized Rectangle2D getItemBounds(final Rectangle2D b) {
		b.setFrameFromDiagonal(m_bounds.getMinX(), m_bounds.getMinY(), m_bounds.getMaxX(), m_bounds.getMaxY());
		return b;
	}

	// ------------------------------------------------------------------------
	// Rendering

	/**
	 * Returns the offscreen buffer used for double buffering.
	 * 
	 * @@return the offscreen buffer
	 */
	public VolatileImage getOffscreenBuffer() {
		return m_offscreen;
	}

	/**
	 * Creates a new buffered image to use as an offscreen buffer.
	 */
	protected VolatileImage getNewOffscreenBuffer(final int width, final int height) {
		VolatileImage img = null;
		if (!GraphicsEnvironment.isHeadless()) {
			try {
				img = createVolatileImage(width, height);
			} catch (final Exception e) {
				img = null;
			}
		}
		if (img == null) {
			return createVolatileImage(width, height);// , BufferedImage.TYPE_INT_RGB);
		}
		return img;
	}

	/**
	 * Saves a copy of this display as an image to the specified output stream.
	 * 
	 * @@param output
	 *            the output stream to write to.
	 * @@param format
	 *            the image format (e.g., "JPG", "PNG"). The number and kind of available formats
	 *            varies by platform. See {@@link javax.imageio.ImageIO} and related classes for
	 *            more.
	 * @@param scaleX
	 *            how much to scale the image by in the x-dimension. For example, a value of 2.0
	 *            will result in an image with twice the pixel width of this Display.
	 * @@param scaleY
	 *            how much to scale the image by in the y-dimension. For example, a value of 2.0
	 *            will result in an image with twice the pixel height of this Display.
	 * @@return true if image was successfully saved, false if an error occurred.
	 */
	public boolean saveImage(final OutputStream output, final String format, final double scaleX, final double scaleY) {
		try {
			// get an image to draw into
			final Dimension d = new Dimension((int) (scaleX * getWidth()), (int) (scaleY * getHeight()));
			final VolatileImage img = getNewOffscreenBuffer(d.width, d.height);
			final Graphics2D g = (Graphics2D) img.getGraphics();

			// set up the display, render, then revert to normal settings
			final Point2D p = new Point2D.Double(0, 0);
			zoom(p, scaleX, scaleY); // also takes care of damage report
			final boolean q = isHighQuality();
			setHighQuality(true);
			paintDisplay(g, d);
			setHighQuality(q);
			zoom(p, 1 / scaleX, 1 / scaleY); // also takes care of damage report

			// save the image and return
			ImageIO.write(img.getSnapshot(), format, output);
			return true;
		} catch (final Exception e) {
			e.printStackTrace();
			return false;
		}
	}

	/**
	 * @@see java.awt.Component#update(java.awt.Graphics)
	 */
	@@Override
	public void update(final Graphics g) {
		paint(g);
	}

	/**
	 * Paints the offscreen buffer to the provided graphics context.
	 * 
	 * @@param g
	 *            the Graphics context to paint to
	 */
	protected void paintBufferToScreen(final Graphics g) {
		synchronized (this) {
			g.drawImage(m_offscreen, 0, 0, null);
		}
	}

	/**
	 * Immediately repaints the contents of the offscreen buffer to the screen. This bypasses the
	 * usual rendering loop.
	 */
	public void repaintImmediate() {
		final Graphics g = this.getGraphics();
		if (g != null && m_offscreen != null) {
			paintBufferToScreen(g);
		}
	}

	/**
	 * Sets the transform of the provided Graphics context to be the transform of this Display and
	 * sets the desired rendering hints.
	 * 
	 * @@param g
	 *            the Graphics context to prepare.
	 */
	protected void prepareGraphics(final Graphics2D g) {
		if (m_transform != null) {
d808 2
a809 451
		setRenderingHints(g);
	}

	/**
	 * Sets the rendering hints that should be used while drawing the visualization to the screen.
	 * Subclasses can override this method to set hints as desired. Such subclasses should consider
	 * honoring the high quality flag in one form or another.
	 * 
	 * @@param g
	 *            the Graphics context on which to set the rendering hints
	 */
	protected void setRenderingHints(final Graphics2D g) {
		if (m_highQuality) {
			g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		} else {
			g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
		}
		g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
		g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);
	}

	/**
	 * @@see javax.swing.JComponent#paintComponent(java.awt.Graphics)
	 */
	@@Override
	public void paintComponent(final Graphics g) {
		if (m_offscreen == null) {
			m_offscreen = getNewOffscreenBuffer(getWidth(), getHeight());
			damageReport();
		}
		final Graphics2D g2D = (Graphics2D) g;
		final Graphics2D buf_g2D = (Graphics2D) m_offscreen.getGraphics();

		// Why not fire a pre-paint event here?
		// Pre-paint events are fired by the clearRegion method

		// paint the visualization
		paintDisplay(buf_g2D, getSize());
		paintBufferToScreen(g2D);

		// fire post-paint events to any painters
		firePostPaint(g2D);

		buf_g2D.dispose();

		// compute frame rate
		nframes++;
		if (mark < 0) {
			mark = System.currentTimeMillis();
			nframes = 0;
		} else if (nframes == sampleInterval) {
			final long t = System.currentTimeMillis();
			frameRate = 1000.0 * nframes / (t - mark);
			mark = t;
			nframes = 0;
		}
	}

	/**
	 * Renders the display within the given graphics context and size bounds.
	 * 
	 * @@param g2D
	 *            the <code>Graphics2D</code> context to use for rendering
	 * @@param d
	 *            the rendering width and height of the Display
	 */
	public void paintDisplay(final Graphics2D g2D, final Dimension d) {
		// if double-locking *ALWAYS* lock on the visualization first
		synchronized (m_vis) {
			synchronized (this) {

				if (m_clip.isEmpty()) {
					return; // no damage, no render
				}

				// map the screen bounds to absolute coords
				m_screen.setClip(0, 0, d.width + 1, d.height + 1);
				m_screen.transform(m_itransform);

				// compute the approximate size of an "absolute pixel"
				// values too large are OK (though cause unnecessary rendering)
				// values too small will cause incorrect rendering

				final double pixel = 1.0 + 1.0 / Math.min(getScaleX(), getScaleY());

				if (m_damageRedraw) {
					if (m_clip.isInvalid()) {
						// if clip is invalid, we clip to the entire screen
						m_clip.setClip(m_screen);
					} else {
						// otherwise intersect damaged region with display bounds
						m_clip.intersection(m_screen);
					}

					// expand the clip by the extra pixel margin
					m_clip.expand(pixel);

					// set the transform, rendering keys, etc
					prepareGraphics(g2D);

					// now set the actual rendering clip
					m_rclip.setFrameFromDiagonal(m_clip.getMinX(), m_clip.getMinY(), m_clip.getMaxX(), m_clip.getMaxY());
					g2D.setClip(m_rclip);

					// finally, we want to clear the region we'll redraw. we clear
					// a slightly larger area than the clip. if we don't do this,
					// we sometimes get rendering artifacts, possibly due to
					// scaling mismatches in the Java2D implementation
					m_rclip.setFrameFromDiagonal(m_clip.getMinX() - pixel, m_clip.getMinY() - pixel, m_clip.getMaxX() + pixel,
							m_clip.getMaxY() + pixel);

				} else {
					// set the background region to clear
					m_rclip.setFrame(m_screen.getMinX(), m_screen.getMinY(), m_screen.getWidth(), m_screen.getHeight());

					// set the item clip to the current screen
					m_clip.setClip(m_screen);

					// set the transform, rendering keys, etc
					prepareGraphics(g2D);
				}

				// now clear the region
				clearRegion(g2D, m_rclip);

				// -- render ----------------------------
				// the actual rendering loop

				// copy current item bounds into m_rclip, reset item bounds
				getItemBounds(m_rclip);
				m_bounds.reset();

				// fill the rendering and picking queues
				m_queue.clear(); // clear the queue
				m_visibleCount = 0;
				for (final VisualItem<?> item : m_vis.items(m_predicate)) {
					final Rectangle2D bounds = item.getBounds();
					m_bounds.union(bounds); // add to item bounds

					if (m_clip.intersects(bounds, pixel)) {
						m_queue.addToRenderQueue(item);
					}
					if (item.isInteractive()) {
						m_queue.addToPickingQueue(item);
					}
					m_visibleCount++;
				}

				// sort the rendering queue
				m_queue.sortRenderQueue();

				// render each visual item
				for (int i = 0; i < m_queue.rsize; ++i) {
					m_queue.ritems[i].render(g2D);
				}

				// no more damage so reset the clip
				if (m_damageRedraw) {
					m_clip.reset();
				}

				// fire bounds change, if appropriate
				checkItemBoundsChanged(m_rclip);

			}
		} // end synchronized block
	}

	/**
	 * Immediately render the given VisualItem to the screen. This method bypasses the Display's
	 * offscreen buffer.
	 * 
	 * @@param item
	 *            the VisualItem to render immediately
	 */
	public void renderImmediate(final VisualItem<?> item) {
		final Graphics2D g2D = (Graphics2D) this.getGraphics();
		prepareGraphics(g2D);
		item.render(g2D);
	}

	/**
	 * Paints the graph to the provided graphics context, for output to a printer. This method does
	 * not double buffer the painting, in order to provide the maximum print quality.
	 * 
	 * <b>This method may not be working correctly, and will be repaired at a later date.</b>
	 * 
	 * @@param g
	 *            the printer graphics context.
	 */
	@@Override
	protected void printComponent(final Graphics g) {
		final boolean wasDoubleBuffered = isDoubleBuffered();
		final boolean wasHighQuality = m_highQuality;
		try {
			setDoubleBuffered(false);
			// Set the quality to high for the duration of the printing.
			m_highQuality = true;
			// Paint directly to the print graphics context.
			paintDisplay((Graphics2D) g, getSize());
		} finally {
			// Reset the quality to the state it was in before printing.
			m_highQuality = wasHighQuality;
			setDoubleBuffered(wasDoubleBuffered);
		}
	}

	/**
	 * Clears the specified region of the display in the display's offscreen buffer.
	 */
	protected void clearRegion(final Graphics2D g, final Rectangle2D r) {
		g.setColor(getBackground());
		g.fill(r);
		// fire pre-paint events to any painters
		firePrePaint(g);
	}

	// ------------------------------------------------------------------------
	// Transformations

	/**
	 * Set the 2D AffineTransform (e.g., scale, shear, pan, rotate) used by this display before
	 * rendering visual items. The provided transform must be invertible, otherwise an expection
	 * will be thrown. For simple panning and zooming transforms, you can instead use the provided
	 * pan() and zoom() methods.
	 */
	public synchronized void setTransform(final AffineTransform transform) throws NoninvertibleTransformException {
		damageReport();
		m_transform = transform;
		m_itransform = m_transform.createInverse();
	}

	/**
	 * Returns a reference to the AffineTransformation used by this Display. Changes made to this
	 * reference WILL corrupt the state of this display. Use setTransform() to safely update the
	 * transform state.
	 * 
	 * @@return the AffineTransform
	 */
	public AffineTransform getTransform() {
		return m_transform;
	}

	/**
	 * Returns a reference to the inverse of the AffineTransformation used by this display. Direct
	 * changes made to this reference WILL corrupt the state of this display.
	 * 
	 * @@return the inverse AffineTransform
	 */
	public AffineTransform getInverseTransform() {
		return m_itransform;
	}

	/**
	 * Gets the absolute co-ordinate corresponding to the given screen co-ordinate.
	 * 
	 * @@param screen
	 *            the screen co-ordinate to transform
	 * @@param abs
	 *            a reference to put the result in. If this is the same object as the screen
	 *            co-ordinate, it will be overridden safely. If this value is null, a new Point2D
	 *            instance will be created and returned.
	 * @@return the point in absolute co-ordinates
	 */
	public Point2D getAbsoluteCoordinate(final Point2D screen, final Point2D abs) {
		return m_itransform.transform(screen, abs);
	}

	/**
	 * Returns the current scale (zoom) value along the x-dimension. This will usually have the same
	 * value as getScaleY().
	 * 
	 * @@return the scaling factor along the x-dimension.
	 */
	public double getScaleX() {
		return m_transform.getScaleX();
	}

	/**
	 * Returns the current scale (zoom) value along the y-dimension. This will usually have the same
	 * value as getScaleX().
	 * 
	 * @@return the scaling factor along the y-dimension.
	 */
	public double getScaleY() {
		return m_transform.getScaleY();
	}

	/**
	 * Returns the x-coordinate of the top-left of the display, in absolute (item-space)
	 * co-ordinates.
	 * 
	 * @@return the x co-ord of the top-left corner, in absolute coordinates
	 */
	public double getDisplayX() {
		return -m_transform.getTranslateX();
	}

	/**
	 * Returns the y-coordinate of the top-left of the display, in absolute (item-space)
	 * co-ordinates.
	 * 
	 * @@return the y co-ord of the top-left corner, in absolute coordinates
	 */
	public double getDisplayY() {
		return -m_transform.getTranslateY();
	}

	/**
	 * Pans the view provided by this display in screen coordinates.
	 * 
	 * @@param dx
	 *            the amount to pan along the x-dimension, in pixel units
	 * @@param dy
	 *            the amount to pan along the y-dimension, in pixel units
	 */
	public synchronized void pan(final double dx, final double dy) {
		final double panx = dx / m_transform.getScaleX();
		final double pany = dy / m_transform.getScaleY();
		panAbs(panx, pany);
	}

	/**
	 * Pans the view provided by this display in absolute (i.e. item-space) coordinates.
	 * 
	 * @@param dx
	 *            the amount to pan along the x-dimension, in absolute co-ords
	 * @@param dy
	 *            the amount to pan along the y-dimension, in absolute co-ords
	 */
	public synchronized void panAbs(final double dx, final double dy) {
		damageReport();
		m_transform.translate(dx, dy);
		try {
			m_itransform = m_transform.createInverse();
		} catch (final Exception e) { /* will never happen here */
		}
	}

	/**
	 * Pans the display view to center on the provided point in screen (pixel) coordinates.
	 * 
	 * @@param p
	 *            the point to center on, in screen co-ords
	 */
	public synchronized void panTo(final Point2D p) {
		m_itransform.transform(p, m_tmpPoint);
		panToAbs(m_tmpPoint);
	}

	/**
	 * Pans the display view to center on the provided point in absolute (i.e. item-space)
	 * coordinates.
	 * 
	 * @@param p
	 *            the point to center on, in absolute co-ords
	 */
	public synchronized void panToAbs(final Point2D p) {
		final double sx = m_transform.getScaleX();
		final double sy = m_transform.getScaleY();
		double x = p.getX();
		x = Double.isNaN(x) ? 0 : x;
		double y = p.getY();
		y = Double.isNaN(y) ? 0 : y;
		x = getWidth() / (2 * sx) - x;
		y = getHeight() / (2 * sy) - y;

		final double dx = x - m_transform.getTranslateX() / sx;
		final double dy = y - m_transform.getTranslateY() / sy;

		damageReport();
		m_transform.translate(dx, dy);
		try {
			m_itransform = m_transform.createInverse();
		} catch (final Exception e) { /* will never happen here */
		}
	}

	/**
	 * Zooms the view provided by this display by the given scale, anchoring the zoom at the
	 * specified point in screen coordinates.
	 * 
	 * @@param p
	 *            the anchor point for the zoom, in screen coordinates
	 * @@param scaleX
	 *            the amount to zoom by in the x-dimension
	 * @@param scaleY
	 *            the amount to zoom by in the y-dimension
	 */
	public synchronized void zoom(final Point2D p, final double scaleX, final double scaleY) {
		m_itransform.transform(p, m_tmpPoint);
		zoomAbs(m_tmpPoint, scaleX, scaleY);
	}

	/**
	 * Zooms the view provided by this display by the given scale, anchoring the zoom at the
	 * specified point in absolute coordinates.
	 * 
	 * @@param p
	 *            the anchor point for the zoom, in absolute (i.e. item-space) co-ordinates
	 * @@param scaleX
	 *            the amount to zoom by in the x-dimension
	 * @@param scaleY
	 *            the amount to zoom by in the y-dimension
	 */
	public synchronized void zoomAbs(final Point2D p, final double scaleX, final double scaleY) {
		double zx = p.getX(), zy = p.getY();
		damageReport();
		m_transform.translate(zx, zy);
		m_transform.scale(scaleX, scaleY);
		m_transform.translate(-zx, -zy);
		try {
			m_itransform = m_transform.createInverse();
		} catch (final Exception e) { /* will never happen here */
		}
	}

	/**
	 * Rotates the view provided by this display by the given angle in radians, anchoring the
	 * rotation at the specified point in screen coordinates.
	 * 
	 * @@param p
	 *            the anchor point for the rotation, in screen coordinates
	 * @@param theta
	 *            the angle to rotate by, in radians
	 */
	public synchronized void rotate(final Point2D p, final double theta) {
		m_itransform.transform(p, m_tmpPoint);
		rotateAbs(m_tmpPoint, theta);
	}

	/**
	 * Rotates the view provided by this display by the given angle in radians, anchoring the
	 * rotation at the specified point in absolute coordinates.
	 * 
	 * @@param p
	 *            the anchor point for the rotation, in absolute (i.e. item-space) co-ordinates
	 * @@param theta
	 *            the angle to rotation by, in radians
	 */
	public synchronized void rotateAbs(final Point2D p, final double theta) {
		double zx = p.getX(), zy = p.getY();
		damageReport();
		m_transform.translate(zx, zy);
		m_transform.rotate(theta);
		m_transform.translate(-zx, -zy);
		try {
			m_itransform = m_transform.createInverse();
		} catch (final Exception e) { /* will never happen here */
		}
	}
d811 561
a1371 173
	/**
	 * Animate a pan along the specified distance in screen (pixel) co-ordinates using the provided
	 * duration.
	 * 
	 * @@param dx
	 *            the amount to pan along the x-dimension, in pixel units
	 * @@param dy
	 *            the amount to pan along the y-dimension, in pixel units
	 * @@param duration
	 *            the duration of the animation, in milliseconds
	 */
	public synchronized void animatePan(final double dx, final double dy, final long duration) {
		final double panx = dx / m_transform.getScaleX();
		final double pany = dy / m_transform.getScaleY();
		animatePanAbs(panx, pany, duration);
	}

	/**
	 * Animate a pan along the specified distance in absolute (item-space) co-ordinates using the
	 * provided duration.
	 * 
	 * @@param dx
	 *            the amount to pan along the x-dimension, in absolute co-ords
	 * @@param dy
	 *            the amount to pan along the y-dimension, in absolute co-ords
	 * @@param duration
	 *            the duration of the animation, in milliseconds
	 */
	public synchronized void animatePanAbs(final double dx, final double dy, final long duration) {
		m_transact.pan(dx, dy, duration);
	}

	/**
	 * Animate a pan to the specified location in screen (pixel) co-ordinates using the provided
	 * duration.
	 * 
	 * @@param p
	 *            the point to pan to in screen (pixel) units
	 * @@param duration
	 *            the duration of the animation, in milliseconds
	 */
	public synchronized void animatePanTo(final Point2D p, final long duration) {
		final Point2D pp = new Point2D.Double();
		m_itransform.transform(p, pp);
		animatePanToAbs(pp, duration);
	}

	/**
	 * Animate a pan to the specified location in absolute (item-space) co-ordinates using the
	 * provided duration.
	 * 
	 * @@param p
	 *            the point to pan to in absolute (item-space) units
	 * @@param duration
	 *            the duration of the animation, in milliseconds
	 */
	public synchronized void animatePanToAbs(final Point2D p, final long duration) {
		m_tmpPoint.setLocation(0, 0);
		m_itransform.transform(m_tmpPoint, m_tmpPoint);
		double x = p.getX();
		x = Double.isNaN(x) ? 0 : x;
		double y = p.getY();
		y = Double.isNaN(y) ? 0 : y;
		final double w = getWidth() / (2 * m_transform.getScaleX());
		final double h = getHeight() / (2 * m_transform.getScaleY());
		final double dx = w - x + m_tmpPoint.getX();
		final double dy = h - y + m_tmpPoint.getY();
		animatePanAbs(dx, dy, duration);
	}

	/**
	 * Animate a zoom centered on a given location in screen (pixel) co-ordinates by the given scale
	 * using the provided duration.
	 * 
	 * @@param p
	 *            the point to center on in screen (pixel) units
	 * @@param scaleX
	 *            the scale factor (X) to zoom by
	 * @@param scaleY
	 *            the scale factor (Y) to zoom by
	 * @@param duration
	 *            the duration of the animation, in milliseconds
	 */
	public synchronized void animateZoom(final Point2D p, final double scaleX, final double scaleY, final long duration) {
		final Point2D pp = new Point2D.Double();
		m_itransform.transform(p, pp);
		animateZoomAbs(pp, scaleX, scaleY, duration);
	}

	/**
	 * Animate a zoom centered on a given location in absolute (item-space) co-ordinates by the
	 * given scale using the provided duration.
	 * 
	 * @@param p
	 *            the point to center on in absolute (item-space) units
	 * @@param scaleX
	 *            the scale factor (X) to zoom by
	 * @@param scaleY
	 *            the scale factor (Y) to zoom by
	 * @@param duration
	 *            the duration of the animation, in milliseconds
	 */
	public synchronized void animateZoomAbs(final Point2D p, final double scaleX, final double scaleY, final long duration) {
		m_transact.zoom(p, scaleX, scaleY, duration);
	}

	/**
	 * Animate a pan to the specified location in screen (pixel) co-ordinates and zoom to the given
	 * scale using the provided duration.
	 * 
	 * @@param p
	 *            the point to center on in screen (pixel) units
	 * @@param scaleX
	 *            the scale factor (X) to zoom by
	 * @@param scaleY
	 *            the scale factor (Y) to zoom by
	 * @@param duration
	 *            the duration of the animation, in milliseconds
	 */
	public synchronized void animatePanAndZoomTo(final Point2D p, final double scaleX, final double scaleY, final long duration) {
		final Point2D pp = new Point2D.Double();
		m_itransform.transform(p, pp);
		animatePanAndZoomToAbs(pp, scaleX, scaleY, duration);
	}

	/**
	 * Animate a pan to the specified location in absolute (item-space) co-ordinates and zoom to the
	 * given scale using the provided duration.
	 * 
	 * @@param p
	 *            the point to center on in absolute (item-space) units
	 * @@param scaleX
	 *            the scale factor (X) to zoom by
	 * @@param scaleY
	 *            the scale factor (Y) to zoom by
	 * @@param duration
	 *            the duration of the animation, in milliseconds
	 */
	public synchronized void animatePanAndZoomToAbs(final Point2D p, final double scaleX, final double scaleY, final long duration) {
		m_transact.panAndZoom(p, scaleX, scaleY, duration);
	}

	/**
	 * Indicates if a view transformation is currently underway.
	 * 
	 * @@return true if a transform is in progress, false otherwise
	 */
	public boolean isTranformInProgress() {
		return m_transact.isRunning();
	}

	/**
	 * Activity for conducting animated view transformations.
	 */
	private class TransformActivity extends Activity {

		// TODO: change mechanism so that multiple transform
		// activities can be running at once?

		private final double[] src, dst;
		private final AffineTransform m_at;

		public TransformActivity() {
			super(2000, 20, 0);
			src = new double[6];
			dst = new double[6];
			m_at = new AffineTransform();
			setPacingFunction(new SlowInSlowOutPacer());
		}

		private void prepareChange(final long duration) {
			if (this.isScheduled()) {
				m_at.setTransform(dst[0], dst[1], dst[2], dst[3], dst[4], dst[5]);
d1375 68
a1442 70
			this.cancel();
			setDuration(duration);
		}

		private void startChange() {
			m_at.getMatrix(dst);
			m_transform.getMatrix(src);
			this.run();
		}

		public void panAndZoom(final Point2D p, final double scaleX, final double scaleY, final long duration) {
			prepareChange(duration);
			m_tmpPoint.setLocation(0, 0);
			m_itransform.transform(m_tmpPoint, m_tmpPoint);
			double x = p.getX();
			x = Double.isNaN(x) ? 0 : x;
			double y = p.getY();
			y = Double.isNaN(y) ? 0 : y;
			final double w = getWidth() / (2 * m_transform.getScaleX());
			final double h = getHeight() / (2 * m_transform.getScaleY());
			final double dx = w - x + m_tmpPoint.getX();
			final double dy = h - y + m_tmpPoint.getY();
			m_at.translate(dx, dy);
			m_at.translate(p.getX(), p.getY());
			m_at.scale(scaleX, scaleY);
			m_at.translate(-p.getX(), -p.getY());
			startChange();
		}

		public void pan(final double dx, final double dy, final long duration) {
			prepareChange(duration);
			m_at.translate(dx, dy);
			startChange();
		}

		public void zoom(final Point2D p, final double scaleX, final double scaleY, final long duration) {
			prepareChange(duration);
			double zx = p.getX(), zy = p.getY();
			m_at.translate(zx, zy);
			m_at.scale(scaleX, scaleY);
			m_at.translate(-zx, -zy);
			startChange();
		}

		@@Override
		protected void run(final long elapsedTime) {
			final double f = getPace(elapsedTime);
			damageReport();
			m_transform.setTransform(src[0] + f * (dst[0] - src[0]), src[1] + f * (dst[1] - src[1]),
					src[2] + f * (dst[2] - src[2]), src[3] + f * (dst[3] - src[3]), src[4] + f * (dst[4] - src[4]),
					src[5] + f * (dst[5] - src[5]));
			try {
				m_itransform = m_transform.createInverse();
			} catch (final Exception e) { /* won't happen */
			}
			repaint();
		}
	} // end of inner class TransformActivity

	// ------------------------------------------------------------------------
	// Paint Listeners

	/**
	 * Add a PaintListener to this Display to receive notifications about paint events.
	 * 
	 * @@param pl
	 *            the {@@link prefuse.util.display.PaintListener} to add
	 */
	public void addPaintListener(final PaintListener pl) {
		if (m_painters == null) {
d1445 2
a1446 30
		m_painters.add(pl);
	}

	/**
	 * Remove a PaintListener from this Display.
	 * 
	 * @@param pl
	 *            the {@@link prefuse.util.display.PaintListener} to remove
	 */
	public void removePaintListener(final PaintListener pl) {
		m_painters.remove(pl);
	}

	/**
	 * Fires a pre-paint notification to PaintListeners.
	 * 
	 * @@param g
	 *            the current graphics context
	 */
	protected void firePrePaint(final Graphics2D g) {
		if (m_painters != null) {
			for (final PaintListener l : m_painters) {
				try {
					l.prePaint(this, g);
				} catch (final Exception e) {
					s_logger.warning("Exception thrown by PaintListener: " + e + "\n" + StringLib.getStackTrace(e));
				}
			}
		}
	}
d1448 55
a1502 30
	/**
	 * Fires a post-paint notification to PaintListeners.
	 * 
	 * @@param g
	 *            the current graphics context
	 */
	protected void firePostPaint(final Graphics2D g) {
		if (m_painters != null) {
			for (final PaintListener l : m_painters) {
				try {
					l.postPaint(this, g);
				} catch (final Exception e) {
					s_logger.warning("Exception thrown by PaintListener: " + e + "\n" + StringLib.getStackTrace(e));
				}
			}
		}
	}

	// ------------------------------------------------------------------------
	// Item Bounds Listeners

	/**
	 * Add an ItemBoundsListener to receive notifications when the bounds occupied by the
	 * VisualItems in this Display change.
	 * 
	 * @@param ibl
	 *            the {@@link prefuse.util.display.ItemBoundsListener} to add
	 */
	public void addItemBoundsListener(final ItemBoundsListener ibl) {
		if (m_bounders == null) {
d1505 2
a1506 2
		m_bounders.add(ibl);
	}
d1508 15
a1522 19
	/**
	 * Remove an ItemBoundsListener to receive notifications when the bounds occupied by the
	 * VisualItems in this Display change.
	 * 
	 * @@param ibl
	 *            the {@@link prefuse.util.display.ItemBoundsListener} to remove
	 */
	public void removeItemBoundsListener(final ItemBoundsListener ibl) {
		m_bounders.remove(ibl);
	}

	/**
	 * Check if the item bounds has changed, and if so, fire a notification.
	 * 
	 * @@param prev
	 *            the previous item bounds of the Display
	 */
	protected void checkItemBoundsChanged(final Rectangle2D prev) {
		if (m_bounds.equals(prev)) {
d1526 44
a1569 46
		if (m_bounders != null) {
			for (final ItemBoundsListener l : m_bounders) {
				try {
					l.itemBoundsChanged(this);
				} catch (final Exception e) {
					s_logger.warning("Exception thrown by ItemBoundsListener: " + e + "\n" + StringLib.getStackTrace(e));
				}
			}
		}
	}

	// ------------------------------------------------------------------------
	// Control Listeners

	/**
	 * Adds a ControlListener to receive all input events on VisualItems.
	 * 
	 * @@param cl
	 *            the listener to add.
	 */
	public void addControlListener(final Control cl) {
		m_controls.add(cl);
	}

	/**
	 * Removes a registered ControlListener.
	 * 
	 * @@param cl
	 *            the listener to remove.
	 */
	public void removeControlListener(final Control cl) {
		m_controls.remove(cl);
	}

	/**
	 * Returns the VisualItem located at the given point.
	 * 
	 * @@param p
	 *            the Point at which to look
	 * @@return the VisualItem located at the given point, if any
	 */
	public synchronized VisualItem<?> findItem(final Point p) {
		// transform mouse point from screen space to item space
		final Point2D p2 = m_itransform == null ? p : m_itransform.transform(p, m_tmpPoint);
		// ensure that the picking queue has been z-sorted
		if (!m_queue.psorted) {
d1572 4
a1575 4
		// walk queue from front to back looking for hits
		for (int i = m_queue.psize; --i >= 0;) {
			final VisualItem<?> vi = m_queue.pitems[i];
			if (!vi.isValid()) {
d1578 17
a1594 15
			final Renderer r = vi.getRenderer();
			if (r != null && vi.isInteractive() && r.locatePoint(p2, vi)) {
				return vi;
			}
		}
		return null;
	}

	/**
	 * Captures all mouse and key events on the display, detects relevant VisualItems, and informs
	 * ControlListeners.
	 */
	public class InputEventCapturer implements MouseMotionListener, MouseWheelListener, MouseListener, KeyListener {
		private VisualItem<?> activeItem = null;
		private boolean mouseDown = false;
d1596 2
a1597 2
		private boolean validityCheck() {
			if (activeItem.isValid()) {
d1600 8
a1607 8
			activeItem = null;
			return false;
		}

		public void mouseDragged(final MouseEvent e) {
			synchronized (m_vis) {
				if (activeItem != null) {
					if (validityCheck()) {
d1610 13
a1622 13
				} else {
					fireMouseDragged(e);
				}
			}
		}

		public void mouseMoved(final MouseEvent e) {
			synchronized (m_vis) {
				boolean earlyReturn = false;
				// check if we've gone over any item
				final VisualItem<?> vi = findItem(e.getPoint());
				if (activeItem != null && activeItem != vi) {
					if (validityCheck()) {
d1625 8
a1632 8
					earlyReturn = true;
				}
				if (vi != null && vi != activeItem) {
					fireItemEntered(vi, e);
					earlyReturn = true;
				}
				activeItem = vi;
				if (earlyReturn) {
d1636 13
a1648 13
				if (vi != null && vi == activeItem) {
					fireItemMoved(vi, e);
				}
				if (vi == null) {
					fireMouseMoved(e);
				}
			}
		}

		public void mouseWheelMoved(final MouseWheelEvent e) {
			synchronized (m_vis) {
				if (activeItem != null) {
					if (validityCheck()) {
d1651 10
a1660 10
				} else {
					fireMouseWheelMoved(e);
				}
			}
		}

		public void mouseClicked(final MouseEvent e) {
			synchronized (m_vis) {
				if (activeItem != null) {
					if (validityCheck()) {
d1663 6
a1668 5
				} else {
					fireMouseClicked(e);
				}
			}
		}
d1670 5
a1674 5
		public void mousePressed(final MouseEvent e) {
			synchronized (m_vis) {
				mouseDown = true;
				if (activeItem != null) {
					if (validityCheck()) {
d1677 10
a1686 10
				} else {
					fireMousePressed(e);
				}
			}
		}

		public void mouseReleased(final MouseEvent e) {
			synchronized (m_vis) {
				if (activeItem != null) {
					if (validityCheck()) {
d1689 35
a1723 35
				} else {
					fireMouseReleased(e);
				}
				if (activeItem != null && mouseDown && isOffComponent(e)) {
					// mouse was dragged off of the component,
					// then released, so register an exit
					fireItemExited(activeItem, e);
					activeItem = null;
				}
				mouseDown = false;
			}
		}

		public void mouseEntered(final MouseEvent e) {
			synchronized (m_vis) {
				fireMouseEntered(e);
			}
		}

		public void mouseExited(final MouseEvent e) {
			synchronized (m_vis) {
				if (!mouseDown && activeItem != null) {
					// we've left the component and an item
					// is active but not being dragged, deactivate it
					fireItemExited(activeItem, e);
					activeItem = null;
				}
				fireMouseExited(e);
			}
		}

		public void keyPressed(final KeyEvent e) {
			synchronized (m_vis) {
				if (activeItem != null) {
					if (validityCheck()) {
d1726 10
a1735 10
				} else {
					fireKeyPressed(e);
				}
			}
		}

		public void keyReleased(final KeyEvent e) {
			synchronized (m_vis) {
				if (activeItem != null) {
					if (validityCheck()) {
d1738 10
a1747 10
				} else {
					fireKeyReleased(e);
				}
			}
		}

		public void keyTyped(final KeyEvent e) {
			synchronized (m_vis) {
				if (activeItem != null) {
					if (validityCheck()) {
d1750 109
a1858 34
				} else {
					fireKeyTyped(e);
				}
			}
		}

		private boolean isOffComponent(final MouseEvent e) {
			final int x = e.getX(), y = e.getY();
			return x < 0 || x > getWidth() || y < 0 || y > getHeight();
		}

		// --------------------------------------------------------------------
		// Fire Event Notifications

		private void fireItemDragged(final VisualItem<?> item, final MouseEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.itemDragged(item, e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireItemMoved(final VisualItem<?> item, final MouseEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.itemMoved(item, e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
d1860 2
a1861 2
			}
		}
d1863 2
a1864 63
		private void fireItemWheelMoved(final VisualItem<?> item, final MouseWheelEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.itemWheelMoved(item, e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireItemClicked(final VisualItem<?> item, final MouseEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.itemClicked(item, e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireItemPressed(final VisualItem<?> item, final MouseEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.itemPressed(item, e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireItemReleased(final VisualItem<?> item, final MouseEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.itemReleased(item, e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireItemEntered(final VisualItem<?> item, final MouseEvent e) {
			item.setHover(true);
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.itemEntered(item, e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireItemExited(final VisualItem<?> item, final MouseEvent e) {
			if (item.isValid()) {
d1867 2
a1868 2
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
d1870 318
a2187 305
						ctrl.itemExited(item, e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireItemKeyPressed(final VisualItem<?> item, final KeyEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.itemKeyPressed(item, e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireItemKeyReleased(final VisualItem<?> item, final KeyEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.itemKeyReleased(item, e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireItemKeyTyped(final VisualItem<?> item, final KeyEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.itemKeyTyped(item, e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireMouseEntered(final MouseEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.mouseEntered(e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireMouseExited(final MouseEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.mouseExited(e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireMousePressed(final MouseEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.mousePressed(e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireMouseReleased(final MouseEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.mouseReleased(e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireMouseClicked(final MouseEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.mouseClicked(e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireMouseDragged(final MouseEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.mouseDragged(e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireMouseMoved(final MouseEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.mouseMoved(e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireMouseWheelMoved(final MouseWheelEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.mouseWheelMoved(e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireKeyPressed(final KeyEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.keyPressed(e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireKeyReleased(final KeyEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.keyReleased(e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

		private void fireKeyTyped(final KeyEvent e) {
			for (final Control ctrl : m_controls) {
				if (ctrl.isEnabled()) {
					try {
						ctrl.keyTyped(e);
					} catch (final Exception ex) {
						s_logger.warning("Exception thrown by Control: " + ex + "\n" + StringLib.getStackTrace(ex));
					}
				}
			}
		}

	} // end of inner class MouseEventCapturer

	// ------------------------------------------------------------------------
	// Text Editing

	/**
	 * Returns the TextComponent used for on-screen text editing.
	 * 
	 * @@return the TextComponent used for text editing
	 */
	public JTextComponent getTextEditor() {
		return m_editor;
	}

	/**
	 * Sets the TextComponent used for on-screen text editing.
	 * 
	 * @@param tc
	 *            the TextComponent to use for text editing
	 */
	public void setTextEditor(final JTextComponent tc) {
		this.remove(m_editor);
		m_editor = tc;
		this.add(m_editor, 1);
	}

	/**
	 * Edit text for the given VisualItem and attribute. Presents a text editing widget spaning the
	 * item's bounding box. Use stopEditing() to hide the text widget. When stopEditing() is called,
	 * the data field will automatically be updated with the VisualItem.
	 * 
	 * @@param item
	 *            the VisualItem to edit
	 * @@param attribute
	 *            the attribute to edit
	 */
	public void editText(final VisualItem<?> item, final String attribute) {
		if (m_editing) {
			stopEditing();
		}
		final Rectangle2D b = item.getBounds();
		final Rectangle r = m_transform.createTransformedShape(b).getBounds();

		// hacky placement code that attempts to keep text in same place
		// configured under Windows XP and Java 1.4.2b
		if (m_editor instanceof JTextArea) {
			r.y -= 2;
			r.width += 22;
			r.height += 2;
		} else {
			r.x += 3;
			r.y += 1;
			r.width -= 5;
			r.height -= 2;
		}

		final Font f = getFont();
		final int size = (int) Math.round(f.getSize() * m_transform.getScaleX());
		final Font nf = new Font(f.getFontName(), f.getStyle(), size);
		m_editor.setFont(nf);

		editText(item, attribute, r);
	}

	/**
	 * Edit text for the given VisualItem and field. Presents a text editing widget spaning the
	 * given bounding box. Use stopEditing() to hide the text widget. When stopEditing() is called,
	 * the field will automatically be updated with the VisualItem.
	 * 
	 * @@param item
	 *            the VisualItem to edit
	 * @@param attribute
	 *            the attribute to edit
	 * @@param r
	 *            Rectangle representing the desired bounding box of the text editing widget
	 */
	public void editText(final VisualItem<?> item, final String attribute, final Rectangle r) {
		if (m_editing) {
			stopEditing();
		}
		final String txt = item.getString(attribute);
		m_editItem = item;
		m_editAttribute = attribute;
		final Color tc = ColorLib.getColor(item.getTextColor());
		final Color fc = ColorLib.getColor(item.getFillColor());
		m_editor.setForeground(tc);
		m_editor.setBackground(fc);
		editText(txt, r);
	}

	/**
	 * Show a text editing widget containing the given text and spanning the specified bounding box.
	 * Use stopEditing() to hide the text widget. Use the method calls getTextEditor().getText() to
	 * get the resulting edited text.
	 * 
	 * @@param txt
	 *            the text string to display in the text widget
	 * @@param r
	 *            Rectangle representing the desired bounding box of the text editing widget
	 */
	public void editText(final String txt, final Rectangle r) {
		if (m_editing) {
			stopEditing();
		}
		m_editing = true;
		m_editor.setBounds(r.x, r.y, r.width, r.height);
		m_editor.setText(txt);
		m_editor.setVisible(true);
		m_editor.setCaretPosition(txt.length());
		m_editor.requestFocus();
	}

	/**
	 * Stops text editing on the display, hiding the text editing widget. If the text editor was
	 * associated with a specific VisualItem (ie one of the editText() methods which include a
	 * VisualItem as an argument was called), the item is updated with the edited text.
	 */
	public void stopEditing() {
		m_editor.setVisible(false);
		if (m_editItem != null) {
			final String txt = m_editor.getText();
			m_editItem.set(m_editAttribute, txt);
			m_editItem = null;
			m_editAttribute = null;
			m_editor.setBackground(null);
			m_editor.setForeground(null);
		}
		m_editing = false;
	}
@


2.10.4.8
log
@reverted display back to bufferedImage - it seems more performant than VolatileImage
@
text
@d26 1
a26 1
import java.awt.image.BufferedImage;
d119 1
a119 1
	protected BufferedImage m_offscreen;
d274 4
a277 3
	 * <li><b>ctrl P</b> - Print the display</li></ul> Subclasses can override this method to
	 * prevent these commands from being set. Additional commands can be registered using the
	 * <code>registerKeyboardAction</code> method.
d725 1
a725 1
	public BufferedImage getOffscreenBuffer() {
d732 2
a733 2
	protected BufferedImage getNewOffscreenBuffer(final int width, final int height) {
		BufferedImage img = null;
d736 1
a736 1
				img = (BufferedImage) createImage(width, height);
d742 1
a742 1
			return new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
d768 1
a768 1
			final BufferedImage img = getNewOffscreenBuffer(d.width, d.height);
d781 1
a781 1
			ImageIO.write(img, format, output);
d1237 1
a1237 1
		final double zx = p.getX(), zy = p.getY();
d1272 1
a1272 1
		final double zx = p.getX(), zy = p.getY();
d1496 1
a1496 1
			final double zx = p.getX(), zy = p.getY();
@


2.9
log
@Added root node checks to TreeNodeIterator to avoid iteration errors
Updated IOLib to support relative file paths (Bug #1775875 from anonymous)
Updated JRangeSlider to support drags from arrow buttons (Bug #1747778 from colincombe)
Updated ExpressionParser to avoid long parse bug (Bug #1741759)
Updated TupleManager to expand tuple list in face of valid rows from CascadedTable instances (Bug #1741106)
Added checks for min==max condition in NumberRangeModel (Bug #1731911)
Added patch to Activity and ActivityManager to avoid deadlock on Activity.cancel() (Bug #1708926 fix from joperry)
Fixed javadoc example for DefaultRendererFactory (Bug #1674371 from cab938)
Fixed ENDPOLYGON field in VisualItem (Bug #1554408 from dimerman)
Fixed FisheyeMenu demo to avoid deadlock (Bug #1672798)
Updated Tree.getDepth to return -1 if node is valid (in the node table) but not in tree (fix from joperry)
Added Display.reset method to release used memory from an idle, unused Display instance
Added Graph.removeAllGraphListeners() method
Added Table.removeAllTableListeners() method
Added isAsynchronous / setAsynchronous methods to ImageFactory
Updated Visualization.invalidate to invalidate just the group specified (it incorrectly was invalidating all groups)
Updated ActivityManager._schedule to call notifyAll when an already scheduled item is re-scheduled
@
text
@d454 1
a454 1
     * @@return the {@@link prefuse.visual.sort.ItemSorter} to use
@


2.8
log
@Added patch to TreeMLWriter to avoid dumping null values (Patch #1758889 from mwlinnem)
Added patch to Display fixing pan-while-rotating bug (Patch #1770541 from trejkaz for Bug #1770531)
Added patch to allow maximization of GraphView demo (Patch #1574233 from vocaro)
Added patch for WheelZoomControl in TreeView demo (Patch #1574674 from vocaro)
Updated TreeNodeIterator to support both pre-order and post-order traversal policies
Updated SquarifiedTreeMapLayout to properly handle expanded/collapsed nodes
@
text
@d228 10
@


2.7
log
@Fixed background clear bug when damage/redraw is disabled
@
text
@d1048 10
a1057 3
        double panx = dx / m_transform.getScaleX();
        double pany = dy / m_transform.getScaleY();
        panAbs(panx,pany);
@


2.6
log
@Fixed Display to work in a headless graphics environment
@
text
@d865 3
a867 1
                m_rclip.setFrame(0, 0, getWidth(), getHeight());
d870 1
d876 1
a876 1
            clearRegion(g2D, m_rclip);
@


2.5
log
@Changed visibility of update method
@
text
@d8 1
d660 9
a668 3
        try {
            return (BufferedImage)createImage(width, height);
        } catch ( Exception e ) {
d672 1
@


2.4
log
@Fixed argument ordering error in stopEditing()
@
text
@d218 1
a218 1
            protected void update(Object src) { damageReport(); }
@


2.3
log
@Added validity check for updating a hovered-over node
@
text
@d2097 1
a2097 1
            m_editItem.set(txt, m_editAttribute);
@


2.2
log
@Added custom tooltip handling to the Display.
@
text
@d1766 1
a1766 1
            item.setHover(false);
@


2.1
log
@Augmented offscreen buffer generation to work for headless setups
@
text
@d34 1
d146 3
d501 44
@


2.0
log
@Merge beta branch back onto main trunk
@
text
@d610 7
a616 2
    protected BufferedImage getNewOffscreenBuffer() {
        return (BufferedImage)createImage(getWidth(), getHeight());
d633 1
d636 1
a636 1
            BufferedImage img = (BufferedImage)createImage(d.width, d.height);
d638 2
d641 1
a641 1
            zoom(p, scale);
d644 1
a644 1
            paintDisplay(g,d);
d646 4
a649 2
            zoom(p, 1/scale);
            ImageIO.write(img,format,output);
d725 1
a725 1
            m_offscreen = getNewOffscreenBuffer();
@


1.1
log
@file Display.java was initially added on branch beta.
@
text
@d1 2048
@


1.1.2.1
log
@Initial commit of prefuse beta
@
text
@a0 1643
package prefuse;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.io.OutputStream;
import java.util.Iterator;
import java.util.logging.Logger;

import javax.imageio.ImageIO;
import javax.swing.JComponent;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.KeyStroke;
import javax.swing.text.JTextComponent;

import prefuse.activity.Activity;
import prefuse.activity.SlowInSlowOutPacer;
import prefuse.controls.Control;
import prefuse.data.expression.AndPredicate;
import prefuse.data.expression.BooleanLiteral;
import prefuse.data.expression.Predicate;
import prefuse.data.expression.parser.ExpressionParser;
import prefuse.render.Renderer;
import prefuse.util.ColorLib;
import prefuse.util.StringLib;
import prefuse.util.collections.CopyOnWriteArrayList;
import prefuse.util.display.Clip;
import prefuse.util.display.DebugStatsPainter;
import prefuse.util.display.ExportDisplayAction;
import prefuse.util.display.PaintListener;
import prefuse.util.display.RenderingQueue;
import prefuse.visual.VisualItem;
import prefuse.visual.expression.VisiblePredicate;
import prefuse.visual.sort.ItemSorter;


/**
 * <p>User interface component that provides an interactive visualization 
 * of a graph. The Display is responsible for drawing items to the
 * screen and providing callbacks for user interface actions such as
 * mouse and keyboard events. A Display must be associated with an
 * {@@link prefuse.Visualization Visualization} from 
 * which it pulls the items to visualize.</p>
 * 
 * <p>The {@@link prefuse.controls.Control Control}
 * interface provides the various available user interface callbacks. The
 * {@@link prefuse.controls} package contains a number
 * of pre-built <code>Control</code> implementations for common
 * interactions.</p>
 * 
 * <p>The Display class also supports arbitrary graphics transforms through
 * the <code>java.awt.geom.AffineTransform</code> class. The 
 * {@@link #setTransform(java.awt.geom.AffineTransform) setTransform} method
 * allows arbitrary transforms to be applied, while the 
 * {@@link #pan(double,double) pan} and 
 * {@@link #zoom(java.awt.geom.Point2D,double) zoom}
 * methods provide convenience methods that appropriately update the current
 * transform to achieve panning and zooming on the presentation space.</p>
 * 
 * <p>Additionally, each Display instance also supports use of a text editor
 * to facilitate direct editing of text. See the various
 * {@@link #editText(prefuse.VisualItem, String) editItem}
 * methods.</p>
 * 
 * @@version 1.0
 * @@author <a href="http://jheer.org">jeffrey heer</a> prefuse(AT)jheer.org
 * @@see Visualization
 * @@see prefuse.controls.Control
 * @@see prefuse.controls
 */
public class Display extends JComponent {

    private static final Logger s_logger 
        = Logger.getLogger(Display.class.getName());
    
    // visual item source
	protected Visualization m_vis;
    protected AndPredicate  m_predicate = new AndPredicate();
    
    // listeners
    protected CopyOnWriteArrayList m_controls = new CopyOnWriteArrayList();
    protected CopyOnWriteArrayList m_painters;
    
    // display
	protected BufferedImage m_offscreen;
    protected Clip          m_clip = new Clip();
    protected Clip          m_screen = new Clip();
    protected Rectangle2D   m_rclip = new Rectangle2D.Double();
    protected boolean       m_highQuality = false;
    
    // rendering queue
    protected RenderingQueue m_queue = new RenderingQueue();
    protected int            m_visibleCount = 0;
    
    // transform variables
    protected AffineTransform   m_transform  = new AffineTransform();
    protected AffineTransform   m_itransform = new AffineTransform();
    protected TransformActivity m_transact = new TransformActivity();
    protected Point2D m_tmpPoint = new Point2D.Double();
    
    // frame count and debugging output
    protected double frameRate;
    protected int  nframes = 0;
    private int  sampleInterval = 10;
    private long mark = -1L;
    
    // text editing variables
    private JTextComponent m_editor;
    private boolean        m_editing;
    private VisualItem     m_editItem;
    private String         m_editAttribute;
	
    /**
	 * Constructor. Creates a new display instance. You will need to
	 * associate this Display with a Visualization for it to display
	 * anything.
	 */
    public Display() {
        this(null);
    }
    
    public Display(Visualization visualization) {
        this(visualization, (Predicate)null);
    }
    
    public Display(Visualization visualization, String predicate) {
        this(visualization,
                (Predicate)ExpressionParser.parse(predicate));
    }
    
	/**
	 * Creates a new display instance associated with the given
	 * Visualization.
	 * @@param registry the ItemRegistry from which this Display
	 *  should get the items to visualize.
	 */
	public Display(Visualization visualization, Predicate predicate) {
        setDoubleBuffered(false);
        setBackground(Color.WHITE);
        
        // initialize text editor
        m_editing = false;
        m_editor = new JTextField();
        m_editor.setBorder(null);
        m_editor.setVisible(false);
        this.add(m_editor);
        
        // register input event capturer
		InputEventCapturer iec = new InputEventCapturer();
		addMouseListener(iec);
		addMouseMotionListener(iec);
		addMouseWheelListener(iec);
		addKeyListener(iec);
        
        registerDefaultCommands();
        
        setVisualization(visualization);
        setPredicate(predicate);
        setSize(400,400); // set a default size
	}
    
	protected void registerDefaultCommands() {
		// add debugging output control
		registerKeyboardAction(new ActionListener() {
			private PaintListener m_debug = null;

			public void actionPerformed(ActionEvent e) {
				if (m_debug == null) {
					m_debug = new DebugStatsPainter();
					addPaintListener(m_debug);
				} else {
					removePaintListener(m_debug);
					m_debug = null;
				}
				repaint();
			}
		}, "debug info", KeyStroke.getKeyStroke("ctrl D"), WHEN_FOCUSED);
		
		// add quality toggle
		registerKeyboardAction(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				setHighQuality(!isHighQuality());
				repaint();
			}
		}, "toggle high-quality drawing", KeyStroke.getKeyStroke("ctrl H"),
				WHEN_FOCUSED);
		
		// add image output control, if this is not an applet
		try {
			registerKeyboardAction(new ExportDisplayAction(this),
             "export display", KeyStroke.getKeyStroke("ctrl E"), WHEN_FOCUSED);
		} catch (SecurityException se) {
		}
	}
	
	/**
	 * Set the size of the Display.
	 * 
	 * @@see java.awt.Component#setSize(int, int)
	 */
	public void setSize(int width, int height) {
		m_offscreen = null;
        setPreferredSize(new Dimension(width,height));
		super.setSize(width, height);
	} //
	
	/**
	 * Set the size of the Display.
	 * 
	 * @@see java.awt.Component#setSize(java.awt.Dimension)
	 */
	public void setSize(Dimension d) {
		m_offscreen = null;
        setPreferredSize(d);
		super.setSize(d);
	} //

    /**
     * Invalidates this component. Overridden to ensure that an
     * internal damage report is generated.
     * @@see java.awt.Component#invalidate()
     */
    public void invalidate() {
        damageReport();
        super.invalidate();
    }
    
    /**
     * Reshapes (moves and resizes) this component.
     */
    public void reshape(int x, int y, int w, int h) {
        m_offscreen = null;
        super.reshape(x,y,w,h);
    } //
    
    /**
     * Sets the font used by this Display. This determines the font used
     * by this Display's text editor.
     */
    public void setFont(Font f) {
        super.setFont(f);
        m_editor.setFont(f);
    } //
    
    /**
     * Returns the running average frame rate for this display.
     * @@return the frame rate
     */
    public double getFrameRate() {
        return frameRate;
    }
    
    /**
     * Determines if the Display uses a higher quality rendering, using
     * anti-aliasing. This causes drawing to be much slower, however, and
     * so is disabled by default.
     * @@param on true to enable anti-aliased rendering, false to disable it
     */
    public void setHighQuality(boolean on) {
        if ( m_highQuality != on )
            damageReport();
        m_highQuality = on;
    } //
    
    /**
     * Indicates if the Display is using high quality (return value true) or
     * regular quality (return value false) rendering.
     * @@return true if high quality rendering is enabled, false otherwise
     */
    public boolean isHighQuality() {
        return m_highQuality;
    } //
    
    /**
     * Returns the Visualization used by this display.
     * @@return this Display's Visualization
     */
    public Visualization getVisualization() {
        return m_vis;
    }
    
    /**
     * Set the Visualiztion associated with this Display. This Display
     * will render the items contained in the provided visualization. If this
     * Display is already associated with a different Visualization, the
     * Display unregisters itself with the previous registry.
     * @@param registry the ItemRegistry to associate with this Display.
     *  A value of null associates this Display with no ItemRegistry
     *  at all.
     */
    public void setVisualization(Visualization vis) {
        // TODO: synchronization?
        if ( m_vis == vis ) {
            // nothing need be done
            return;
        } else if ( m_vis != null ) {
            // remove this display from it's previous registry
            m_vis.removeDisplay(this);
        }
        m_vis = vis;
        if ( m_vis != null )
            m_vis.addDisplay(this);
    }
    
    public Predicate getPredicate() {
        if ( m_predicate.size() == 1 ) {
            return BooleanLiteral.TRUE;
        } else {
            return m_predicate.get(0);
        }
    }
    
    public void setPredicate(String expr) {
        Predicate p = (Predicate)ExpressionParser.parse(expr);
        setPredicate(p);
    }
    
    public synchronized void setPredicate(Predicate p) {
        if ( p == null ) {
            m_predicate.set(VisiblePredicate.TRUE);
        } else {
            m_predicate.set(new Predicate[] {p, VisiblePredicate.TRUE});
        }
    }
    
    public int getVisibleItemCount() {
        return m_visibleCount;
    }
    
    public ItemSorter getItemSorter() {
        return m_queue.sort;
    }
    
    public synchronized void setItemSorter(ItemSorter cmp) {
        damageReport();
        m_queue.sort = cmp;
    }
    
    // ------------------------------------------------------------------------
    // Rendering
    
	/**
	 * Returns the offscreen buffer used by this component for 
	 *  double-buffering.
	 * @@return the offscreen buffer
	 */
	public BufferedImage getOffscreenBuffer() {
		return m_offscreen;
	} //
	
    /**
     * Creates a new buffered image to use as an offscreen buffer.
     */
	protected BufferedImage getNewOffscreenBuffer() {
        return (BufferedImage)createImage(getWidth(), getHeight());
//        return new BufferedImage(getWidth(), getHeight(), 
//                                 BufferedImage.TYPE_INT_ARGB);
	} //
	
	/**
	 * Saves a copy of this display as an image to the specified output stream.
	 * @@param output the output stream to write to.
	 * @@param format the image format (e.g., "JPG", "PNG").
	 * @@param scale how much to scale the image by.
	 * @@return true if image was successfully saved, false if an error occurred.
	 */
	public boolean saveImage(OutputStream output, String format, double scale) {
	    try {
	        Dimension d = new Dimension((int)(scale*getWidth()),(int)(scale*getHeight()));
	        BufferedImage img = (BufferedImage) createImage(d.width, d.height);
	        Graphics2D g = (Graphics2D)img.getGraphics();
	        Point2D p = new Point2D.Double(0,0);
	        zoom(p, scale);
	        boolean q = isHighQuality();
	        setHighQuality(true);
	        paintDisplay(g,d);
	        setHighQuality(q);
	        zoom(p, 1/scale);
	        ImageIO.write(img,format,output);
	        return true;
	    } catch ( Exception e ) {
	        e.printStackTrace();
	        return false;
	    }
	} //
	
    /**
     * Reports damage to the Display within in the specified region.
     * @@param region the damaged region, in absolute coordinates
     */
    public synchronized void damageReport(Rectangle2D region) {
        m_clip.union(region);
    }
    
    /**
     * Reports damage to the entire Display.
     */
    public synchronized void damageReport() {
        m_clip.invalidate();
    }
   
    /**
     * Updates this display
     */
	public void update(Graphics g) {
		paint(g);
	}
    
    /**
     * Paints the offscreen buffer to the provided graphics context.
     * @@param g the Graphics context to paint to
     */
	protected void paintBufferToScreen(Graphics g) {
        synchronized ( this ) {
            g.drawImage(m_offscreen, 0, 0, null);
        }
	} //

	/**
	 * Immediately repaints the contents of the offscreen buffer
	 * to the screen. This bypasses the usual rendering loop.
	 */
	public void repaintImmediate() {
		Graphics g = this.getGraphics();
		if (g != null && m_offscreen != null) {
			paintBufferToScreen(g);
		}
	} //

    /**
     * Sets the transform of the provided Graphics context to be the
     * transform of this Display and sets the desired rendering hints.
     * @@param g the Graphics context to prepare.
     */
    protected void prepareGraphics(Graphics2D g) {
        if ( m_transform != null )
            g.transform(m_transform);
        setRenderingHints(g);
    } //
    
	/**
	 * Sets the rendering hints that should be used while drawing
	 * the visualization to the screen. Subclasses can override
     * this method to set hints as desired.
	 * @@param g the Graphics context on which to set the rendering hints
	 */
	protected void setRenderingHints(Graphics2D g) {
		if ( m_highQuality ) {
		    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
		            RenderingHints.VALUE_ANTIALIAS_ON);
		} else {
			g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
					RenderingHints.VALUE_ANTIALIAS_OFF);
		}
        g.setRenderingHint(
            RenderingHints.KEY_RENDERING,
            RenderingHints.VALUE_RENDER_QUALITY);
		g.setRenderingHint(
			RenderingHints.KEY_INTERPOLATION,
			RenderingHints.VALUE_INTERPOLATION_BICUBIC);
	} //

	/**
	 * Draws the visualization to the screen. Draws each visible item to the
	 * screen in a rendering loop. Rendering order can be controlled by adding
	 * the desired Comparator to the Display's ItemRegistry.
	 */
	public void paintComponent(Graphics g) {
		if (m_offscreen == null) {
			m_offscreen = getNewOffscreenBuffer();
            damageReport();
        }
        Graphics2D g2D = (Graphics2D)g;
	    Graphics2D buf_g2D = (Graphics2D) m_offscreen.getGraphics();
        
        // draw background
        //g.setColor(getBackground());
        //g.fillRect(0, 0, getWidth(), getHeight());
        
        // fire pre-paint events to any painters
        firePrePaint(g2D);
        
	    // paint the visualization
		paintDisplay(buf_g2D, getSize());
     	paintBufferToScreen(g2D);		
		
        // fire post-paint events to any painters
        firePostPaint(g2D);
        
        buf_g2D.dispose();
        
        // compute frame rate
        nframes++;
        if ( mark < 0 ) {
            mark = System.currentTimeMillis();
            nframes = 0;
        } else if ( nframes == sampleInterval ){
            long t = System.currentTimeMillis();
            frameRate = (1000.0*nframes)/(t-mark);
            mark = t;
            nframes = 0;
        }
	} //
    
	public void paintDisplay(Graphics2D g2D, Dimension d) {
        // if double-locking *ALWAYS* lock on the visualization first
        synchronized ( m_vis ) {
        synchronized ( this ) {
            
            if ( m_clip.isEmpty() )
                return; // no damage, no render
            
            // map the screen bounds to absolute coords
            m_screen.setClip(0, 0, d.width+1, d.height+1);
            m_screen.transform(m_itransform);
            
            if ( m_clip.isInvalid() ) {
                // if clip is invalid, we clip to the entire screen
                m_clip.setClip(m_screen);
            } else {
                // otherwise intersect damaged region with display bounds
                m_clip.intersection(m_screen);
            }
            
            // compute the approximate size of an "absolute pixel"
            // values too large are OK (though cause unnecessary rendering)
            // values too small will cause incorrect rendering
            double pixel = 1.0 + 1.0/getScale();
            
            // expand the clip by the extra pixel margin
            m_clip.expand(pixel);
            
            // set the transform, rendering keys, etc
            prepareGraphics(g2D);
            
            // now set the actual rendering clip
            m_rclip.setFrameFromDiagonal(
                    m_clip.getMinX(), m_clip.getMinY(), 
                    m_clip.getMaxX(), m_clip.getMaxY());
            g2D.setClip(m_rclip);
            
            // finally, we want to clear the region we'll redraw. we clear a
            // slightly larger area than the clip. if we don't do this, we
            // sometimes get rendering artifacts, possibly due to scaling 
            // mismatches in the Java2D implementation
            m_rclip.setFrameFromDiagonal(
                    m_clip.getMinX()-pixel, m_clip.getMinY()-pixel,
                    m_clip.getMaxX()+pixel, m_clip.getMaxY()+pixel);
    
            // now clear the region
            clearRegion(g2D, m_rclip);
    
            
            // -- RENDER INTO IT ----------------------------
            
            // render loop
            
            // fill the rendering and picking queues
            m_queue.clear();
            Iterator items = m_vis.items(m_predicate);
            for ( m_visibleCount=0; items.hasNext(); ++m_visibleCount ) {
                VisualItem item = (VisualItem)items.next();
                if ( m_clip.intersects(item.getBounds(), pixel) )
                    m_queue.addToRenderQueue(item);
                if ( item.isInteractive() )
                    m_queue.addToPickingQueue(item);
            }
            
            // sort the rendering queue
            m_queue.sortRenderQueue();
            
            // render each visual item
            for ( int i=0; i<m_queue.rsize; ++i ) {
                m_queue.ritems[i].render(g2D);
            }
            
            // no more damage so reset the clip
            m_clip.reset();
        }}
	} //
    
	/**
	 * Paints the graph to the provided graphics context, for output to a
	 * printer.  This method does not double buffer the painting, in order to
	 * provide the maximum quality.
	 * 
	 * @@param g the printer graphics context.
	 */
	protected void printComponent(Graphics g) {
		boolean wasHighQuality = m_highQuality;
		try {
			// Set the quality to high for the duration of the printing.
			m_highQuality = true;
			// Paint directly to the print graphics context.
			paintDisplay((Graphics2D) g, getSize());
		} finally {
			// Reset the quality to the state it was in before printing.
			m_highQuality = wasHighQuality;
		}
	}
    
    /**
     * Clears the specified region of the display
     * in the display's offscreen buffer.
     */    
    private void clearRegion(Graphics2D g, Rectangle2D r) {
//        Composite comp = g.getComposite();
//        g.setComposite(AlphaComposite.Clear);
//        g.fill(r);
//        g.setComposite(comp);
        // if not triple buffering
        g.setColor(getBackground());
        g.fill(r);
    }

    // ------------------------------------------------------------------------
    // Transformations
    
    /**
     * Set the 2D AffineTransform (e.g., scale, shear, pan, rotate) used by
     * this display before rendering graph items. The provided transform
     * must be invertible, otherwise an expection will be thrown. For simple
     * panning and zooming transforms, you can instead use the provided
     * pan() and zoom() methods.
     */
    public synchronized void setTransform(AffineTransform transform) 
        throws NoninvertibleTransformException
    {
        damageReport();
        m_transform = transform;
        m_itransform = m_transform.createInverse();
    } //
    
    /**
     * Returns a reference to the AffineTransformation used by this Display.
     * Changes made to this reference WILL corrupt the state of 
     * this display. Use setTransform() to safely update the transform state.
     * @@return the AffineTransform
     */
    public AffineTransform getTransform() {
        return m_transform;
    } //
    
    /**
     * Returns a reference to the inverse of the AffineTransformation used by
     * this display. Changes made to this reference WILL corrupt the
     * state of this display.
     * @@return the inverse AffineTransform
     */
    public AffineTransform getInverseTransform() {
        return m_itransform;
    } //
    
    /**
     * Gets the absolute co-ordinate corresponding to the given screen
     * co-ordinate.
     * @@param screen the screen co-ordinate to transform
     * @@param abs a reference to put the result in. If this is the same
     *  object as the screen co-ordinate, it will be overridden safely. If
     *  this value is null, a new Point2D instance will be created and 
     *  returned.
     * @@return the point in absolute co-ordinates
     */
    public Point2D getAbsoluteCoordinate(Point2D screen, Point2D abs) {
        return m_itransform.transform(screen, abs);
    } //
    
    /**
     * Returns the current scale (i.e. zoom value).
     * @@return the current scale. This is the
     *  scaling factor along the x-dimension, so be careful when
     *  using this value in non-uniform scaling cases.
     */
    public double getScale() {
        return m_transform.getScaleX();
    } //
    
    /**
     * Returns the x-coordinate of the top-left of the display, 
     * in absolute co-ordinates
     * @@return the x co-ord of the top-left corner, in absolute coordinates
     */
    public double getDisplayX() {
        return -m_transform.getTranslateX();
    } //
    
    /**
     * Returns the y-coordinate of the top-left of the display, 
     * in absolute co-ordinates
     * @@return the y co-ord of the top-left corner, in absolute coordinates
     */
    public double getDisplayY() {
        return -m_transform.getTranslateY();
    } //
    
    /**
     * Pans the view provided by this display in screen coordinates.
     * @@param dx the amount to pan along the x-dimension, in pixel units
     * @@param dy the amount to pan along the y-dimension, in pixel units
     */
    public synchronized void pan(double dx, double dy) {
        double panx = dx / m_transform.getScaleX();
        double pany = dy / m_transform.getScaleY();
        panAbs(panx,pany);
    } //
    
    /**
     * Pans the view provided by this display in absolute (i.e. non-screen)
     * coordinates.
     * @@param dx the amount to pan along the x-dimension, in absolute co-ords
     * @@param dy the amount to pan along the y-dimension, in absolute co-ords
     */
    public synchronized void panAbs(double dx, double dy) {
        damageReport();
        m_transform.translate(dx, dy);
        try {
            m_itransform = m_transform.createInverse();
        } catch ( Exception e ) { /*will never happen here*/ }
    } //
    
    /**
     * Pans the display view to center on the provided point in 
     * screen (pixel) coordinates.
     * @@param x the x-point to center on, in screen co-ords
     * @@param y the y-point to center on, in screen co-ords
     */
    public synchronized void panTo(Point2D p) {
        m_itransform.transform(p, m_tmpPoint);
        panToAbs(m_tmpPoint);
    } //
    
    /**
     * Pans the display view to center on the provided point in 
     * absolute (i.e. non-screen) coordinates.
     * @@param x the x-point to center on, in absolute co-ords
     * @@param y the y-point to center on, in absolute co-ords
     */
    public synchronized void panToAbs(Point2D p) {
        double sx = m_transform.getScaleX();
        double sy = m_transform.getScaleY();
        double x = p.getX(); x = (Double.isNaN(x) ? 0 : x);
        double y = p.getY(); y = (Double.isNaN(y) ? 0 : y);
        x = getWidth() /(2*sx) - x;
        y = getHeight()/(2*sy) - y;
        
        double dx = x-(m_transform.getTranslateX()/sx);
        double dy = y-(m_transform.getTranslateY()/sy);

        damageReport();
        m_transform.translate(dx, dy);
        try {
            m_itransform = m_transform.createInverse();
        } catch ( Exception e ) { /*will never happen here*/ }
    } //

    /**
     * Zooms the view provided by this display by the given scale,
     * anchoring the zoom at the specified point in screen coordinates.
     * @@param p the anchor point for the zoom, in screen coordinates
     * @@param scale the amount to zoom by
     */
    public synchronized void zoom(final Point2D p, double scale) {
        m_itransform.transform(p, m_tmpPoint);
        zoomAbs(m_tmpPoint, scale);
    } //    
    
    /**
     * Zooms the view provided by this display by the given scale,
     * anchoring the zoom at the specified point in absolute coordinates.
     * @@param p the anchor point for the zoom, in absolute
     *  (i.e. non-screen) co-ordinates
     * @@param scale the amount to zoom by
     */
    public synchronized void zoomAbs(final Point2D p, double scale) {;
        double zx = p.getX(), zy = p.getY();
        damageReport();
        m_transform.translate(zx, zy);
        m_transform.scale(scale,scale);
        m_transform.translate(-zx, -zy);
        try {
            m_itransform = m_transform.createInverse();
        } catch ( Exception e ) { /*will never happen here*/ }
    } //

    public synchronized void animatePan(double dx, double dy, long duration) {
        double panx = dx / m_transform.getScaleX();
        double pany = dy / m_transform.getScaleY();
        animatePanAbs(panx,pany,duration);
    } //
    
    public synchronized void animatePanAbs(double dx, double dy, long duration) {
        m_transact.pan(dx,dy,duration);
    } //
    
    public synchronized void animatePanTo(Point2D p, long duration) {
        Point2D pp = new Point2D.Double();
        m_itransform.transform(p,pp);
        animatePanToAbs(pp,duration);
    } //
    
    public synchronized void animatePanToAbs(Point2D p, long duration) {
        m_tmpPoint.setLocation(0,0);
        m_itransform.transform(m_tmpPoint,m_tmpPoint);
        double x = p.getX(); x = (Double.isNaN(x) ? 0 : x);
        double y = p.getY(); y = (Double.isNaN(y) ? 0 : y);
        double w = getWidth() /(2*m_transform.getScaleX());
        double h = getHeight()/(2*m_transform.getScaleY());
        double dx = w-x+m_tmpPoint.getX();
        double dy = h-y+m_tmpPoint.getY();
        animatePanAbs(dx,dy,duration);
    } //
    
    public synchronized void animateZoom(final Point2D p, double scale, long duration) {
        Point2D pp = new Point2D.Double();
        m_itransform.transform(p,pp);
        animateZoomAbs(pp,scale,duration);
    } //
    
    public synchronized void animateZoomAbs(final Point2D p, double scale, long duration) {
        m_transact.zoom(p,scale,duration);
    } //
    
    public synchronized void animatePanAndZoomTo(final Point2D p, double scale, long duration) {
        Point2D pp = new Point2D.Double();
        m_itransform.transform(p,pp);
        animatePanAndZoomToAbs(pp,scale,duration);
    } //
    
    public synchronized void animatePanAndZoomToAbs(final Point2D p, double scale, long duration) {
        m_transact.panAndZoom(p,scale,duration);
    } //
    
    public boolean isTranformInProgress() {
        return m_transact.isRunning();
    } //
    
    /**
     * TODO: clean this up to be more general...
     * TODO: change mechanism so that multiple transform
     *        activities can be running at once?
     */
    private class TransformActivity extends Activity {
        private double[] src, dst;
        private AffineTransform m_at;
        public TransformActivity() {
            super(2000,20,0);
            src = new double[6];
            dst = new double[6];
            m_at = new AffineTransform();
            setPacingFunction(new SlowInSlowOutPacer());
        } //
        private AffineTransform getTransform() {
            if ( this.isScheduled() )
                m_at.setTransform(dst[0],dst[1],dst[2],dst[3],dst[4],dst[5]);
            else
                m_at.setTransform(m_transform);
            return m_at;
        } //
        public void panAndZoom(final Point2D p, double scale, long duration) {
            AffineTransform at = getTransform();
            this.cancel();
            setDuration(duration);
            
            m_tmpPoint.setLocation(0,0);
            m_itransform.transform(m_tmpPoint,m_tmpPoint);
            double x = p.getX(); x = (Double.isNaN(x) ? 0 : x);
            double y = p.getY(); y = (Double.isNaN(y) ? 0 : y);
            double w = getWidth() /(2*m_transform.getScaleX());
            double h = getHeight()/(2*m_transform.getScaleY());
            double dx = w-x+m_tmpPoint.getX();
            double dy = h-y+m_tmpPoint.getY();
            at.translate(dx,dy);

            at.translate(p.getX(), p.getY());
            at.scale(scale,scale);
            at.translate(-p.getX(), -p.getY());
            
            at.getMatrix(dst);
            m_transform.getMatrix(src);
            this.run();
        }
        public void pan(double dx, double dy, long duration) {
            AffineTransform at = getTransform();
            this.cancel();
            setDuration(duration);
            at.translate(dx,dy);
            at.getMatrix(dst);
            m_transform.getMatrix(src);
            this.run();
        } //
        public void zoom(final Point2D p, double scale, long duration) {
            AffineTransform at = getTransform();
            this.cancel();
            setDuration(duration);
            double zx = p.getX(), zy = p.getY();
            at.translate(zx, zy);
            at.scale(scale,scale);
            at.translate(-zx, -zy);
            at.getMatrix(dst);
            m_transform.getMatrix(src);
            this.run();
        } //
        protected void run(long elapsedTime) {
            double f = getPace(elapsedTime);
            damageReport();
            m_transform.setTransform(
                src[0] + f*(dst[0]-src[0]),
                src[1] + f*(dst[1]-src[1]),
                src[2] + f*(dst[2]-src[2]),
                src[3] + f*(dst[3]-src[3]),
                src[4] + f*(dst[4]-src[4]),
                src[5] + f*(dst[5]-src[5])
            );
            try {
                m_itransform = m_transform.createInverse();
            } catch ( Exception e ) { /* won't happen */ }
            repaint();
        } //
    } // end of inner class TransformActivity
    
    // ------------------------------------------------------------------------
    // Paint Listeners
    
    public void addPaintListener(PaintListener pl) {
        if ( m_painters == null )
            m_painters = new CopyOnWriteArrayList();
        m_painters.add(pl);
    }
    
    public void removePaintListener(PaintListener pl) {
        m_painters.remove(pl);
    }
    
    protected void firePrePaint(Graphics2D g) {
        if ( m_painters != null && m_painters.size() > 0 ) {
            Object[] lstnrs = m_painters.getArray();
            for ( int i=0; i<lstnrs.length; ++i ) {
                try {
                    ((PaintListener)lstnrs[i]).prePaint(this, g);
                } catch ( Exception e ) {
                    s_logger.warning(
                        "Exception thrown by PaintListener: " + e + "\n" +
                        StringLib.getStackTrace(e));
                }
            }
        }
    }
    
    protected void firePostPaint(Graphics2D g) {
        if ( m_painters != null && m_painters.size() > 0 ) {
            Object[] lstnrs = m_painters.getArray();
            for ( int i=0; i<lstnrs.length; ++i ) {
                try {
                    ((PaintListener)lstnrs[i]).postPaint(this, g);
                } catch ( Exception e ) {
                    s_logger.warning(
                        "Exception thrown by PaintListener: " + e + "\n" +
                        StringLib.getStackTrace(e));
                }
            }
        }
    }
    
    // ------------------------------------------------------------------------
    // Control Listeners
    
	/**
	 * Adds a ControlListener to receive all input events on VisualItems.
	 * @@param cl the listener to add.
	 */
	public void addControlListener(Control cl) {
		m_controls.add(cl);
	}

	/**
	 * Removes a registered ControlListener.
	 * @@param cl the listener to remove.
	 */
	public void removeControlListener(Control cl) {
		m_controls.remove(cl);
	}
    
	/**
	 * Returns the VisualItem located at the given point.
	 * @@param p the Point at which to look
	 * @@return the VisualItem located at the given point, if any
	 */
	public synchronized VisualItem findItem(Point p) {
        // transform mouse point from screen space to item space
        Point2D p2 = (m_itransform==null ? p : 
                      m_itransform.transform(p, m_tmpPoint));
        // ensure that the picking queue has been z-sorted
        if ( !m_queue.psorted )
            m_queue.sortPickingQueue();
        // walk queue from front to back looking for hits
        for ( int i = m_queue.psize; --i >= 0; ) {
            VisualItem vi = m_queue.pitems[i];
            if ( !vi.isValid() ) continue; // in case tuple went invalid
            Renderer r = vi.getRenderer();
            if (r!=null && vi.isInteractive() && r.locatePoint(p2, vi)) {
                return vi;
            }
		}
		return null;
	}
    
	/**
	 * Captures all mouse and key events on the display, detects relevant 
	 * VisualItems, and informs ControlListeners.
	 */
	public class InputEventCapturer implements MouseMotionListener, 
        MouseWheelListener, MouseListener, KeyListener
    {
		private VisualItem activeItem = null;
		private boolean mouseDown = false;

        private boolean validityCheck() {
            if ( activeItem.isValid() )
                return true;
            activeItem = null;
            return false;
        }
        
		public void mouseDragged(MouseEvent e) {
            synchronized ( m_vis ) {
                if ( activeItem != null ) {
                    if ( validityCheck() )
                        fireItemDragged(activeItem, e);
    			} else {
    				fireMouseDragged(e);
    			}
            }
		}

		public void mouseMoved(MouseEvent e) {
            synchronized ( m_vis ) {
    			boolean earlyReturn = false;
    			//check if we've gone over any item
    			VisualItem vi = findItem(e.getPoint());
    			if ( activeItem != null && activeItem != vi ) {
                    if ( validityCheck() )
                        fireItemExited(activeItem, e);
    				earlyReturn = true;
    			}
    			if ( vi != null && vi != activeItem ) {
    				fireItemEntered(vi, e);
    				earlyReturn = true;
    			}
    			activeItem = vi;
    			if ( earlyReturn ) return;
    			
    			if ( vi != null && vi == activeItem ) {
    				fireItemMoved(vi, e);
    			}
    			if ( vi == null ) {
    				fireMouseMoved(e);
    			}
            }
		}

		public void mouseWheelMoved(MouseWheelEvent e) {
            synchronized ( m_vis ) {
    			if ( activeItem != null ) {
                    if ( validityCheck() )
                        fireItemWheelMoved(activeItem, e);
    			} else {
    				fireMouseWheelMoved(e);
    			}
            }
		}

		public void mouseClicked(MouseEvent e) {
            synchronized ( m_vis ) {
    			if ( activeItem != null ) {
                    if ( validityCheck() )
                        fireItemClicked(activeItem, e);
    			} else {
    				fireMouseClicked(e);
    			}
            }
        }
		

		public void mousePressed(MouseEvent e) {
            synchronized ( m_vis ) {
                mouseDown = true;
    			if ( activeItem != null ) {
                    if ( validityCheck() )
                        fireItemPressed(activeItem, e);
    			} else {
    				fireMousePressed(e);
    			}
            }
		}

		public void mouseReleased(MouseEvent e) {
            synchronized ( m_vis ) {
    			if ( activeItem != null ) {
                    if ( validityCheck() )
                        fireItemReleased(activeItem, e);
    			} else {
    				fireMouseReleased(e);
    			}
                if ( activeItem != null && mouseDown && isOffComponent(e) ) {
                    // mouse was dragged off of the component, 
                    // then released, so register an exit
                    fireItemExited(activeItem, e);
                    activeItem = null;
                }
                mouseDown = false;
            }
		}

		public void mouseEntered(MouseEvent e) {
            synchronized ( m_vis ) {
                fireMouseEntered(e);
            }
		}

		public void mouseExited(MouseEvent e) {
            synchronized ( m_vis ) {      
    			if ( !mouseDown && activeItem != null ) {
                    // we've left the component and an item 
                    // is active but not being dragged, deactivate it
                    fireItemExited(activeItem, e);
                    activeItem = null;
    			}
    			fireMouseExited(e);
            }
		}

		public void keyPressed(KeyEvent e) {
            synchronized ( m_vis ) {
    			if ( activeItem != null ) {
                    if ( validityCheck() )
                        fireItemKeyPressed(activeItem, e);
    			} else {
    				fireKeyPressed(e);
    			}
            }
		}

		public void keyReleased(KeyEvent e) {
            synchronized ( m_vis ) {
                if ( activeItem != null ) {
                    if ( validityCheck() )
                        fireItemKeyReleased(activeItem, e);
    			} else {
    				fireKeyReleased(e);
    			}
            }
		}

		public void keyTyped(KeyEvent e) {
            synchronized ( m_vis ) {
    			if ( activeItem != null ) {
                    if ( validityCheck() )
                        fireItemKeyTyped(activeItem, e);
    			} else {
    				fireKeyTyped(e);
    			}
            }
		}
        
        private boolean isOffComponent(MouseEvent e) {
            int x = e.getX(), y = e.getY();
            return ( x<0 || x>getWidth() || y<0 || y>getHeight() );
        }
        
        // --------------------------------------------------------------------
        // Fire Event Notifications
        
        private void fireItemDragged(VisualItem item, MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemDragged(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemMoved(VisualItem item, MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemMoved(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemWheelMoved(VisualItem item, MouseWheelEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemWheelMoved(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemClicked(VisualItem item, MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemClicked(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemPressed(VisualItem item, MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemPressed(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemReleased(VisualItem item, MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemReleased(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemEntered(VisualItem item, MouseEvent e) {
            item.setHover(true);
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemEntered(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemExited(VisualItem item, MouseEvent e) {
            item.setHover(false);
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemExited(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemKeyPressed(VisualItem item, KeyEvent e) {
            Object[] lstnrs = m_controls.getArray();
            if (lstnrs.length == 0)
                return;
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemKeyPressed(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemKeyReleased(VisualItem item, KeyEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemKeyReleased(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireItemKeyTyped(VisualItem item, KeyEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.itemKeyTyped(item, e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireMouseEntered(MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.mouseEntered(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireMouseExited(MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.mouseExited(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireMousePressed(MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.mousePressed(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireMouseReleased(MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.mouseReleased(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireMouseClicked(MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.mouseClicked(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireMouseDragged(MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.mouseDragged(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireMouseMoved(MouseEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.mouseMoved(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireMouseWheelMoved(MouseWheelEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.mouseWheelMoved(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireKeyPressed(KeyEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.keyPressed(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireKeyReleased(KeyEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.keyReleased(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }

        private void fireKeyTyped(KeyEvent e) {
            Object[] lstnrs = m_controls.getArray();
            for (int i = 0; i < lstnrs.length; ++i) {
                Control ctrl = (Control) lstnrs[i];
                if (ctrl.isEnabled())
                    try {
                        ctrl.keyTyped(e);
                    } catch ( Exception ex ) {
                        s_logger.warning(
                            "Exception thrown by Control: " + ex + "\n" +
                            StringLib.getStackTrace(ex));
                    }
            }
        }
        
	} // end of inner class MouseEventCapturer
    
    
    // ------------------------------------------------------------------------
    // Text Editing
    
    /**
     * Returns the TextComponent used for on-screen text editing.
     * 
     * @@return the TextComponent used for text editing
     */
    public JTextComponent getTextEditor() {
        return m_editor;
    } //
    
    /**
     * Sets the TextComponent used for on-screen text editing.
     * 
     * @@param tc
     *            the TextComponent to use for text editing
     */
    public void setTextEditor(JTextComponent tc) {
        this.remove(m_editor);
        m_editor = tc;
        this.add(m_editor, 1);
    } //
    
    /**
     * Edit text for the given VisualItem and attribute. Presents a text
     * editing widget spaning the item's bounding box. Use stopEditing()
     * to hide the text widget. When stopEditing() is called, the attribute
     * will automatically be updated with the VisualItem.
     * @@param item the VisualItem to edit
     * @@param attribute the attribute to edit
     */
    public void editText(VisualItem item, String attribute) {
        if ( m_editing ) { stopEditing(); }
        Rectangle2D b = item.getBounds();
        Rectangle r = m_transform.createTransformedShape(b).getBounds();
        
        // hacky placement code that attempts to keep text in same place
        // configured under Windows XP and Java 1.4.2b
        if ( m_editor instanceof JTextArea ) {
            r.y -= 2; r.width += 22; r.height += 2;
        } else {
            r.x += 3; r.y += 1; r.width -= 5; r.height -= 2;
        }
        
        Font f = getFont();
        int size = (int)Math.round(f.getSize()*m_transform.getScaleX());
        Font nf = new Font(f.getFontName(), f.getStyle(), size);
        m_editor.setFont(nf);
        
        editText(item, attribute, r);
    } //
    
    /**
     * Edit text for the given VisualItem and attribute. Presents a text
     * editing widget spaning the given bounding box. Use stopEditing()
     * to hide the text widget. When stopEditing() is called, the attribute
     * will automatically be updated with the VisualItem.
     * @@param item the VisualItem to edit
     * @@param attribute the attribute to edit
     * @@param r Rectangle representing the desired bounding box of the text
     *  editing widget
     */
    public void editText(VisualItem item, String attribute, Rectangle r) {
        if ( m_editing ) { stopEditing(); }
        String txt = item.getString(attribute);
        m_editItem = item;
        m_editAttribute = attribute;
        Color tc = ColorLib.getColor(item.getTextColor());
        Color fc = ColorLib.getColor(item.getFillColor());
        m_editor.setForeground(tc);
        m_editor.setBackground(fc);
        editText(txt, r);
    } //
    
    /**
     * Show a text editing widget containing the given text and spanning the
     * specified bounding box. Use stopEditing() to hide the text widget. Use
     * the method calls getTextEditor().getText() to get the resulting edited
     * text.
     * @@param txt the text string to display in the text widget
     * @@param r Rectangle representing the desired bounding box of the text
     *  editing widget
     */
    public void editText(String txt, Rectangle r) {
        if ( m_editing ) { stopEditing(); }
        m_editing = true;
        m_editor.setBounds(r.x,r.y,r.width,r.height);
        m_editor.setText(txt);
        m_editor.setVisible(true);
        m_editor.setCaretPosition(txt.length());
        m_editor.requestFocus();
    } //
    
    /**
     * Stops text editing on the display, hiding the text editing widget. If
     * the text editor was associated with a specific VisualItem (ie one of the
     * editText() methods which include a VisualItem as an argument was called),
     * the item is updated with the edited text.
     */
    public void stopEditing() {
        m_editor.setVisible(false);
        if ( m_editItem != null ) {
            String txt = m_editor.getText();
            m_editItem.set(m_editAttribute, txt);
            m_editItem = null;
            m_editAttribute = null;
            m_editor.setBackground(null);
            m_editor.setForeground(null);
        }
        m_editing = false;
    } //
    
} // end of class Display
@


1.1.2.2
log
@Damage display when filter predicate changes
@
text
@a45 1
import prefuse.util.UpdateListener;
a176 5
        // invalidate the display when the filter changes
        m_predicate.addExpressionListener(new UpdateListener() {
            protected void update(Object src) { damageReport(); }
        });
        
@


1.1.2.3
log
@Table method refactoring. Added PredicateChain, included in ColorFunction, SizeFunction, and RendererFactory. Added ItemBoundsListener, included in GraphView demo. Updated ColorMap to use int representation, moved palette creators to ColorLib. Added minExtent to JRangeSlider. Fixed round-off rendering glitches int optimized rendering, added RenderingAccuracy test class. Updated PrefuseConfig to support logging output to file system. Added DelmitedTextTableWriter. Added CompositeTupleSet. Added directionality to edges, increased support to EdgeRenderer, including reversed directionality.
@
text
@a50 1
import prefuse.util.display.ItemBoundsListener;
a103 1
    protected CopyOnWriteArrayList m_bounders;
a108 1
    protected Clip          m_bounds = new Clip();
d255 1
a255 1
     * Sets the new bounds. Reshapes (moves and resizes) this component.
d257 1
a257 1
    public void setBounds(int x, int y, int w, int h) {
d259 2
a260 2
        super.setBounds(x,y,w,h);
    }
d269 1
a269 1
    }
a365 51
    // Clip / Bounds Management
    
    /**
     * Reports damage to the Display within in the specified region.
     * @@param region the damaged region, in absolute coordinates
     */
    public synchronized void damageReport(Rectangle2D region) {
        m_clip.union(region);
    }
    
    /**
     * Reports damage to the entire Display.
     */
    public synchronized void damageReport() {
        m_clip.invalidate();
    }
   
    /**
     * Clears any reports of damaged regions, causing the Display to believe
     * that the display contents are up-to-date. If used incorrectly this
     * can cause inaccurate rendering. <strong>Call this method only
     * if you know what you are doing.</strong>
     */
    public synchronized void clearDamage() {
        m_clip.reset();
    }
    
    /**
     * Returns the bounds, in aboluste (item-space) coordinates, of the total
     * bounds occupied by all currently visible VisualItems. This method
     * allocates a new Rectangle2D instance for the result.
     * @@return the bounding box for all visibile VisualItems
     * @@see #getItemBounds(Rectangle2D)
     */
    public synchronized Rectangle2D getItemBounds() {
    	return getItemBounds(new Rectangle2D.Double());
    }

    /**
     * Returns the bounds, in aboluste (item-space) coordinates, of the total
     * bounds occupied by all currently visible VisualItems.
     * @@param the Rectangle2D to use to store the return value
     * @@return the bounding box for all visibile VisualItems
     */
    public synchronized Rectangle2D getItemBounds(Rectangle2D b) {
    	b.setFrameFromDiagonal(m_bounds.getMinX(), m_bounds.getMinY(),
    			               m_bounds.getMaxX(), m_bounds.getMaxY());
    	return b;
    }
    
    // ------------------------------------------------------------------------
d375 1
a375 1
	}
d382 3
a384 1
	}
d411 17
a427 2
	}

d443 1
a443 1
	}
d454 1
a454 1
	}
d465 1
a465 1
    }
a480 2
        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,
                RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
d502 4
d529 1
a529 1
	}
d580 1
a580 2
            // -- render ----------------------------
            // the actual rendering  loop
d582 1
a582 3
            // copy current item bounds into m_rclip, reset item bounds
            getItemBounds(m_rclip);
            m_bounds.reset();
d585 1
a585 1
            m_queue.clear();   // clear the queue
d589 1
a589 4
                Rectangle2D bounds = item.getBounds();
                m_bounds.union(bounds); // add to item bounds
                
                if ( m_clip.intersects(bounds, pixel) )
a604 3
            
            // fire bounds change, if appropriate
            checkItemBoundsChanged(m_rclip);
d606 1
a606 7
	}
    
    public void renderImmediate(VisualItem item) {
        Graphics2D g2D = (Graphics2D)this.getGraphics();
        prepareGraphics(g2D);
        item.render(g2D);
    }
d632 6
a637 1
    protected void clearRegion(Graphics2D g, Rectangle2D r) {
a989 33
    
    // ------------------------------------------------------------------------
    // Item Bounds Listeners
    
    public void addItemBoundsListener(ItemBoundsListener ibl) {
    	if ( m_bounders == null )
    		m_bounders = new CopyOnWriteArrayList();
    	m_bounders.add(ibl);
    }
    
    public void removeItemBoundsListener(ItemBoundsListener ibl) {
    	m_bounders.remove(ibl);
    }
    
    protected void checkItemBoundsChanged(Rectangle2D prev) {
    	if ( m_bounds.equals(prev) )
    		return; // nothing to do
    	
        if ( m_bounders != null && m_bounders.size() > 0 ) {
            Object[] lstnrs = m_bounders.getArray();
            for ( int i=0; i<lstnrs.length; ++i ) {
                try {
                    ((ItemBoundsListener)lstnrs[i]).itemBoundsChanged(this);
                } catch ( Exception e ) {
                    s_logger.warning(
                        "Exception thrown by ItemBoundsListener: " + e + "\n" +
                        StringLib.getStackTrace(e));
                }
            }
        }
    }
    
    
d1640 1
a1640 1
            m_editItem.set(txt, m_editAttribute);
@


1.1.2.4
log
@Disabled anti-aliased text as default.
@
text
@d518 2
a519 2
//        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,
//                RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
d526 1
a526 1
	}
@


1.1.2.5
log
@Replaced all tab characters with 4 spaces.
Ensured UNIX style line endings.
@
text
@d99 1
a99 1
    protected Visualization m_vis;
d108 1
a108 1
    protected BufferedImage m_offscreen;
d136 1
a136 1
    
d138 4
a141 4
     * Constructor. Creates a new display instance. You will need to
     * associate this Display with a Visualization for it to display
     * anything.
     */
d155 7
a161 7
    /**
     * Creates a new display instance associated with the given
     * Visualization.
     * @@param registry the ItemRegistry from which this Display
     *  should get the items to visualize.
     */
    public Display(Visualization visualization, Predicate predicate) {
d173 5
a177 5
        InputEventCapturer iec = new InputEventCapturer();
        addMouseListener(iec);
        addMouseMotionListener(iec);
        addMouseWheelListener(iec);
        addKeyListener(iec);
d189 1
a189 1
    }
d191 29
a219 29
    protected void registerDefaultCommands() {
        // add debugging output control
        registerKeyboardAction(new ActionListener() {
            private PaintListener m_debug = null;

            public void actionPerformed(ActionEvent e) {
                if (m_debug == null) {
                    m_debug = new DebugStatsPainter();
                    addPaintListener(m_debug);
                } else {
                    removePaintListener(m_debug);
                    m_debug = null;
                }
                repaint();
            }
        }, "debug info", KeyStroke.getKeyStroke("ctrl D"), WHEN_FOCUSED);
        
        // add quality toggle
        registerKeyboardAction(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                setHighQuality(!isHighQuality());
                repaint();
            }
        }, "toggle high-quality drawing", KeyStroke.getKeyStroke("ctrl H"),
                WHEN_FOCUSED);
        
        // add image output control, if this is not an applet
        try {
            registerKeyboardAction(new ExportDisplayAction(this),
d221 11
a231 11
        } catch (SecurityException se) {
        }
    }
    
    /**
     * Set the size of the Display.
     * 
     * @@see java.awt.Component#setSize(int, int)
     */
    public void setSize(int width, int height) {
        m_offscreen = null;
d233 10
a242 10
        super.setSize(width, height);
    } //
    
    /**
     * Set the size of the Display.
     * 
     * @@see java.awt.Component#setSize(java.awt.Dimension)
     */
    public void setSize(Dimension d) {
        m_offscreen = null;
d244 2
a245 2
        super.setSize(d);
    } //
d404 1
a404 1
        return getItemBounds(new Rectangle2D.Double());
d414 3
a416 3
        b.setFrameFromDiagonal(m_bounds.getMinX(), m_bounds.getMinY(),
                               m_bounds.getMaxX(), m_bounds.getMaxY());
        return b;
d422 9
a430 9
    /**
     * Returns the offscreen buffer used by this component for 
     *  double-buffering.
     * @@return the offscreen buffer
     */
    public BufferedImage getOffscreenBuffer() {
        return m_offscreen;
    }
    
d434 1
a434 1
    protected BufferedImage getNewOffscreenBuffer() {
d436 28
a463 28
    }
    
    /**
     * Saves a copy of this display as an image to the specified output stream.
     * @@param output the output stream to write to.
     * @@param format the image format (e.g., "JPG", "PNG").
     * @@param scale how much to scale the image by.
     * @@return true if image was successfully saved, false if an error occurred.
     */
    public boolean saveImage(OutputStream output, String format, double scale) {
        try {
            Dimension d = new Dimension((int)(scale*getWidth()),(int)(scale*getHeight()));
            BufferedImage img = (BufferedImage) createImage(d.width, d.height);
            Graphics2D g = (Graphics2D)img.getGraphics();
            Point2D p = new Point2D.Double(0,0);
            zoom(p, scale);
            boolean q = isHighQuality();
            setHighQuality(true);
            paintDisplay(g,d);
            setHighQuality(q);
            zoom(p, 1/scale);
            ImageIO.write(img,format,output);
            return true;
        } catch ( Exception e ) {
            e.printStackTrace();
            return false;
        }
    }
d468 3
a470 3
    public void update(Graphics g) {
        paint(g);
    }
d476 1
a476 1
    protected void paintBufferToScreen(Graphics g) {
d480 1
a480 1
    }
d482 10
a491 10
    /**
     * Immediately repaints the contents of the offscreen buffer
     * to the screen. This bypasses the usual rendering loop.
     */
    public void repaintImmediate() {
        Graphics g = this.getGraphics();
        if (g != null && m_offscreen != null) {
            paintBufferToScreen(g);
        }
    }
d504 3
a506 3
    /**
     * Sets the rendering hints that should be used while drawing
     * the visualization to the screen. Subclasses can override
d508 10
a517 10
     * @@param g the Graphics context on which to set the rendering hints
     */
    protected void setRenderingHints(Graphics2D g) {
        if ( m_highQuality ) {
            g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                    RenderingHints.VALUE_ANTIALIAS_ON);
        } else {
            g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                    RenderingHints.VALUE_ANTIALIAS_OFF);
        }
d523 13
a535 13
        g.setRenderingHint(
            RenderingHints.KEY_INTERPOLATION,
            RenderingHints.VALUE_INTERPOLATION_BICUBIC);
    }

    /**
     * Draws the visualization to the screen. Draws each visible item to the
     * screen in a rendering loop. Rendering order can be controlled by adding
     * the desired Comparator to the Display's ItemRegistry.
     */
    public void paintComponent(Graphics g) {
        if (m_offscreen == null) {
            m_offscreen = getNewOffscreenBuffer();
d539 1
a539 1
        Graphics2D buf_g2D = (Graphics2D) m_offscreen.getGraphics();
d544 4
a547 4
        // paint the visualization
        paintDisplay(buf_g2D, getSize());
        paintBufferToScreen(g2D);       
        
d564 1
a564 1
    }
d566 1
a566 1
    public void paintDisplay(Graphics2D g2D, Dimension d) {
d650 1
a650 1
    }
d658 19
a676 19
    /**
     * Paints the graph to the provided graphics context, for output to a
     * printer.  This method does not double buffer the painting, in order to
     * provide the maximum quality.
     * 
     * @@param g the printer graphics context.
     */
    protected void printComponent(Graphics g) {
        boolean wasHighQuality = m_highQuality;
        try {
            // Set the quality to high for the duration of the printing.
            m_highQuality = true;
            // Paint directly to the print graphics context.
            paintDisplay((Graphics2D) g, getSize());
        } finally {
            // Reset the quality to the state it was in before printing.
            m_highQuality = wasHighQuality;
        }
    }
d1040 3
a1042 3
        if ( m_bounders == null )
            m_bounders = new CopyOnWriteArrayList();
        m_bounders.add(ibl);
d1046 1
a1046 1
        m_bounders.remove(ibl);
d1050 3
a1052 3
        if ( m_bounds.equals(prev) )
            return; // nothing to do
        
d1071 22
a1092 22
    /**
     * Adds a ControlListener to receive all input events on VisualItems.
     * @@param cl the listener to add.
     */
    public void addControlListener(Control cl) {
        m_controls.add(cl);
    }

    /**
     * Removes a registered ControlListener.
     * @@param cl the listener to remove.
     */
    public void removeControlListener(Control cl) {
        m_controls.remove(cl);
    }
    
    /**
     * Returns the VisualItem located at the given point.
     * @@param p the Point at which to look
     * @@return the VisualItem located at the given point, if any
     */
    public synchronized VisualItem findItem(Point p) {
d1107 9
a1115 9
        }
        return null;
    }
    
    /**
     * Captures all mouse and key events on the display, detects relevant 
     * VisualItems, and informs ControlListeners.
     */
    public class InputEventCapturer implements MouseMotionListener, 
d1118 2
a1119 2
        private VisualItem activeItem = null;
        private boolean mouseDown = false;
d1128 1
a1128 1
        public void mouseDragged(MouseEvent e) {
d1133 3
a1135 3
                } else {
                    fireMouseDragged(e);
                }
d1137 1
a1137 1
        }
d1139 1
a1139 1
        public void mouseMoved(MouseEvent e) {
d1141 4
a1144 4
                boolean earlyReturn = false;
                //check if we've gone over any item
                VisualItem vi = findItem(e.getPoint());
                if ( activeItem != null && activeItem != vi ) {
d1147 15
a1161 15
                    earlyReturn = true;
                }
                if ( vi != null && vi != activeItem ) {
                    fireItemEntered(vi, e);
                    earlyReturn = true;
                }
                activeItem = vi;
                if ( earlyReturn ) return;
                
                if ( vi != null && vi == activeItem ) {
                    fireItemMoved(vi, e);
                }
                if ( vi == null ) {
                    fireMouseMoved(e);
                }
d1163 1
a1163 1
        }
d1165 1
a1165 1
        public void mouseWheelMoved(MouseWheelEvent e) {
d1167 1
a1167 1
                if ( activeItem != null ) {
d1170 3
a1172 3
                } else {
                    fireMouseWheelMoved(e);
                }
d1174 1
a1174 1
        }
d1176 1
a1176 1
        public void mouseClicked(MouseEvent e) {
d1178 1
a1178 1
                if ( activeItem != null ) {
d1181 3
a1183 3
                } else {
                    fireMouseClicked(e);
                }
d1186 1
a1186 1
        
d1188 1
a1188 1
        public void mousePressed(MouseEvent e) {
d1191 1
a1191 1
                if ( activeItem != null ) {
d1194 3
a1196 3
                } else {
                    fireMousePressed(e);
                }
d1198 1
a1198 1
        }
d1200 1
a1200 1
        public void mouseReleased(MouseEvent e) {
d1202 1
a1202 1
                if ( activeItem != null ) {
d1205 3
a1207 3
                } else {
                    fireMouseReleased(e);
                }
d1216 1
a1216 1
        }
d1218 1
a1218 1
        public void mouseEntered(MouseEvent e) {
d1222 1
a1222 1
        }
d1224 1
a1224 1
        public void mouseExited(MouseEvent e) {
d1226 1
a1226 1
                if ( !mouseDown && activeItem != null ) {
d1231 2
a1232 2
                }
                fireMouseExited(e);
d1234 1
a1234 1
        }
d1236 1
a1236 1
        public void keyPressed(KeyEvent e) {
d1238 1
a1238 1
                if ( activeItem != null ) {
d1241 3
a1243 3
                } else {
                    fireKeyPressed(e);
                }
d1245 1
a1245 1
        }
d1247 1
a1247 1
        public void keyReleased(KeyEvent e) {
d1252 3
a1254 3
                } else {
                    fireKeyReleased(e);
                }
d1256 1
a1256 1
        }
d1258 1
a1258 1
        public void keyTyped(KeyEvent e) {
d1260 1
a1260 1
                if ( activeItem != null ) {
d1263 3
a1265 3
                } else {
                    fireKeyTyped(e);
                }
d1267 1
a1267 1
        }
d1611 1
a1611 1
    } // end of inner class MouseEventCapturer
@


1.1.2.6
log
@Lots of javadoc
@
text
@d60 2
a61 2
 * <p>User interface component that provides an interactive view onto
 * a visualization. The Display is responsible for drawing items to the
d64 2
a65 11
 * {@@link prefuse.Visualization} from which it pulls the items to visualize.
 * </p>
 * 
 * <p>To control which {@@link prefuse.visual.VisualItem} instances are
 * drawn, the Display also maintains an optional 
 * {@@link prefuse.data.expression.Predicate} for filtering items. The
 * z-ordering items (which items are drawn on top of the other) is
 * controlled by an {@@link prefuse.visual.sort.ItemSorter} instance,
 * which calculates a score for each item. Items with higher scores
 * are drawn later, and hence on top of lower scoring items.
 * </p>
d80 1
a80 1
 * transform to achieve panning and zooming of the presentation space.</p>
d84 2
a85 1
 * {@@link #editText(prefuse.VisualItem, String) editItem} methods.</p>
d127 2
a128 2
    protected int nframes = 0;
    private int sampleInterval = 10;
d138 3
a140 2
     * Creates a new Display instance. You will need to associate this
     * Display with a {@@link Visualization} for it to display anything.
a145 6
    /**
     * Creates a new Display associated with the given Visualization.
     * By default, all {@@link prefuse.visual.VisualItem} instances in the
     * {@@link Visualization} will be drawn by the Display.
     * @@param visualization the {@@link Visualization} backing this Display
     */
a149 11
    /**
     * Creates a new Display associated with the given Visualization that
     * draws all VisualItems in the visualization that pass the given
     * predicate. The predicate string will be parsed by the
     * {@@link prefuse.data.expression.parser.ExpressionParser} to get a
     * {@@link prefuse.data.expression.Predicate} instance.
     * @@param visualization the {@@link Visualization} backing this Display
     * @@param a predicate expression in the prefuse expression language.
     * This expression will be parsed; if the parsing fails or does not
     * result in a Predicate instance, an exception will result.
     */
d152 1
a152 1
                (Predicate)ExpressionParser.parse(predicate, true));
d156 4
a159 5
     * Creates a new Display associated with the given Visualization that
     * draws all VisualItems in the visualization that pass the given
     * Predicate.
     * @@param visualization the {@@link Visualization} backing this Display
     * @@param the filtering {@@link prefuse.data.expression.Predicate}
a190 10
    /**
     * Registers default keystroke commands on the Display. The default
     * commands are
     * <ul><li><b>ctrl D</b> - Toggle debug info display</li>
     *     <li><b>ctrl H</b> - Toggle high quality rendering</li>
     *     <li><b>ctrl E</b> - Export display view to an image file</li></ul>
     * Subclasses can override this method to prevent these commands from
     * being set. Additional commands can be registered using the
     * <code>registerKeyboardAction</code> method.
     */
d227 1
a227 2
     * @@param width the width of the Display in pixels
     * @@param height the height of the Display in pixels
d234 1
a234 1
    }
d238 1
a238 1
     * @@param d the dimensions of the Display in pixels
d245 1
a245 1
    }
d258 1
a258 1
     * @@see java.awt.Component#setBounds(int, int, int, int)
d267 1
a267 2
     * by this Display's text editor and in any debugging text.
     * @@param f the Font to use
d275 1
a275 1
     * Returns the running average frame rate for this Display.
d292 1
a292 1
    }
d301 1
a301 1
    }
d304 2
a305 2
     * Returns the Visualization backing this Display.
     * @@return this Display's {@@link Visualization}
d315 4
a318 2
     * Display unregisters itself with the previous one.
     * @@param vis the backing {@@link Visualization} to use.
a333 5
    /**
     * Returns the filtering Predicate used to control what items are drawn
     * by this display.
     * @@return the filtering {@@link prefuse.data.expression.Predicate}
     */
d341 1
a341 10

    /**
     * Sets the filtering Predicate used to control what items are drawn by
     * this Display.
     * @@param p the filtering predicate to use. The predicate string will be
     * parsed by the {@@link prefuse.data.expression.parser.ExpressionParser}.
     * If the parse fails or does not result in a
     * {@@link prefuse.data.expression.Predicate} instance, an exception will
     * be thrown.
     */
d343 1
a343 1
        Predicate p = (Predicate)ExpressionParser.parse(expr, true);
a346 5
    /**
     * Sets the filtering Predicate used to control what items are drawn by
     * this Display.
     * @@param p the filtering {@@link prefuse.data.expression.Predicate} to use
     */
a354 6
    /**
     * Returns the number of visible items processed by this Display. This
     * includes items not currently visible on screen due to the current
     * panning or zooming state.
     * @@return the count of visible items
     */
a358 6
    /**
     * Get the ItemSorter that determines the rendering order of the
     * VisualItems. Items are drawn in ascending order of the scores provided
     * by the ItemSorter.
     * @@return this Display's {@@link prefuse.visual.sort.ItemSorter}
     */
d362 1
a362 7

    /**
     * Set the ItemSorter that determines the rendering order of the
     * VisualItems. Items are drawn in ascending order of the scores provided
     * by the ItemSorter.
     * @@return the {@@link prefuse.visual.sort.ItemSorter} to use
     */
d397 1
a397 1
     * Returns the bounds, in absolute (item-space) coordinates, of the total
d400 1
a400 1
     * @@return the bounding box of all visibile VisualItems
d408 1
a408 1
     * Returns the bounds, in absolute (item-space) coordinates, of the total
d411 1
a411 1
     * @@return the bounding box of all visibile VisualItems
d423 2
a424 1
     * Returns the offscreen buffer used for double buffering.
d441 2
a442 6
     * @@param format the image format (e.g., "JPG", "PNG"). The number and kind
     * of available formats varies by platform. See the 
     * {@@link javax.ImageIO javax.ImageIO} package for more.
     * @@param scale how much to scale the image by. For example, a value of 2.0
     * will result in an image with twice the pixel width and height of this
     * Display.
d445 1
a445 2
    public boolean saveImage(OutputStream output, String format, double scale)
    {
d447 2
a448 3
            Dimension d = new Dimension((int)(scale*getWidth()),
                                        (int)(scale*getHeight()));
            BufferedImage img = (BufferedImage)createImage(d.width, d.height);
d466 1
a466 1
     * @@see java.awt.Component#update(java.awt.Graphics)
d507 1
a507 2
     * this method to set hints as desired. Such subclasses should
     * consider honoring the high quality flag in one form or another.
d518 2
a527 1

d529 3
a531 1
     * @@see javax.swing.JComponent#paintComponent(java.awt.Graphics)
a565 5
    /**
     * Renders the display within the given graphics context and size bounds.
     * @@param g2D the <code>Graphics2D</code> context to use for rendering
     * @@param d the rendering width and height of the Display
     */
a651 5
    /**
     * Immediately render the given VisualItem to the screen. This method
     * bypasses the Display's offscreen buffer.
     * @@param item the VisualItem to render immediately
     */
a662 3
     * <b>This method may not be working correctly,
     * and will be repaired at a later date.</b>
     * 
d692 1
a692 1
     * this display before rendering visual items. The provided transform
d703 1
a703 1
    }
d713 1
a713 1
    }
d717 1
a717 1
     * this display. Direct changes made to this reference WILL corrupt the
d723 1
a723 1
    }
d737 1
a737 1
    }
d740 1
a740 1
     * Returns the current scale (zoom) value.
d743 1
a743 1
     *  using this value in rare non-uniform scaling cases.
d747 1
a747 1
    }
d751 1
a751 1
     * in absolute (item-space) co-ordinates.
d756 1
a756 1
    }
d760 1
a760 1
     * in absolute (item-space) co-ordinates.
d765 1
a765 1
    }
d776 1
a776 1
    }
d779 1
a779 1
     * Pans the view provided by this display in absolute (i.e. item-space)
d790 1
a790 1
    }
d801 1
a801 1
    }
d805 1
a805 1
     * absolute (i.e. item-space) coordinates.
d825 1
a825 1
    }
d836 1
a836 1
    }    
d842 1
a842 1
     *  (i.e. item-space) co-ordinates
d854 1
a854 1
    }
a855 7
    /**
     * Animate a pan along the specified distance in screen (pixel) 
     * co-ordinates using the provided duration.
     * @@param dx the amount to pan along the x-dimension, in pixel units
     * @@param dy the amount to pan along the y-dimension, in pixel units
     * @@param duration the duration of the animation, in milliseconds
     */
d860 1
a860 1
    }
a861 7
    /**
     * Animate a pan along the specified distance in absolute (item-space)
     * co-ordinates using the provided duration.
     * @@param dx the amount to pan along the x-dimension, in absolute co-ords
     * @@param dy the amount to pan along the y-dimension, in absolute co-ords
     * @@param duration the duration of the animation, in milliseconds
     */
d864 1
a864 1
    }
a865 6
    /**
     * Animate a pan to the specified location in screen (pixel) 
     * co-ordinates using the provided duration.
     * @@param p the point to pan to in screen (pixel) units
     * @@param duration the duration of the animation, in milliseconds
     */
d870 1
a870 1
    }
a871 6
    /**
     * Animate a pan to the specified location in absolute (item-space) 
     * co-ordinates using the provided duration.
     * @@param p the point to pan to in absolute (item-space) units
     * @@param duration the duration of the animation, in milliseconds
     */
d882 1
a882 1
    }
a883 7
    /**
     * Animate a zoom centered on a given location in screen (pixel) 
     * co-ordinates by the given scale using the provided duration.
     * @@param p the point to center on in screen (pixel) units
     * @@param scale the scale factor to zoom by
     * @@param duration the duration of the animation, in milliseconds
     */
d888 1
a888 1
    }
a889 7
    /**
     * Animate a zoom centered on a given location in absolute (item-space) 
     * co-ordinates by the given scale using the provided duration.
     * @@param p the point to center on in absolute (item-space) units
     * @@param scale the scale factor to zoom by
     * @@param duration the duration of the animation, in milliseconds
     */
d892 1
a892 1
    }
a893 7
    /**
     * Animate a pan to the specified location in screen (pixel) 
     * co-ordinates and zoom to the given scale using the provided duration.
     * @@param p the point to center on in screen (pixel) units
     * @@param scale the scale factor to zoom by
     * @@param duration the duration of the animation, in milliseconds
     */
d898 1
a898 1
    }
a899 7
    /**
     * Animate a pan to the specified location in absolute (item-space) 
     * co-ordinates and zoom to the given scale using the provided duration.
     * @@param p the point to center on in absolute (item-space) units
     * @@param scale the scale factor to zoom by
     * @@param duration the duration of the animation, in milliseconds
     */
d902 1
a902 1
    }
a903 4
    /**
     * Indicates if a view transformation is currently underway.
     * @@return true if a transform is in progress, false otherwise
     */
d906 1
a906 1
    }
d909 3
a911 1
     * Activity for conducting animated view transformations.
a913 4
        // TODO: clean this up to be more general...
        // TODO: change mechanism so that multiple transform
        //        activities can be running at once?
         
d922 1
a922 1
        }
d929 1
a929 1
        }
d961 1
a961 1
        }
d973 1
a973 1
        }
d989 1
a989 1
        }
a994 5
    /**
     * Add a PaintListener to this Display to receive notifications
     * about paint events.
     * @@param pl the {@@link prefuse.util.display.PaintListener} to add
     */
a1000 4
    /**
     * Remove a PaintListener from this Display.
     * @@param pl the {@@link prefuse.util.display.PaintListener} to remove
     */
a1004 4
    /**
     * Fires a pre-paint notification to PaintListeners.
     * @@param g the current graphics context
     */
a1019 4
    /**
     * Fires a post-paint notification to PaintListeners.
     * @@param g the current graphics context
     */
a1038 5
    /**
     * Add an ItemBoundsListener to receive notifications when the bounds
     * occupied by the VisualItems in this Display change.
     * @@param ibl the {@@link prefuse.util.display.ItemBoundsListener} to add
     */
a1044 5
    /**
     * Remove an ItemBoundsListener to receive notifications when the bounds
     * occupied by the VisualItems in this Display change.
     * @@param ibl the {@@link prefuse.util.display.ItemBoundsListener} to remove
     */
a1048 4
    /**
     * Check if the item bounds has changed, and if so, fire a notification.
     * @@param prev the previous item bounds of the Display
     */
d1619 1
d1624 1
a1624 1
    }
d1628 3
a1630 1
     * @@param tc the TextComponent to use for text editing
d1636 1
a1636 1
    }
d1641 1
a1641 1
     * to hide the text widget. When stopEditing() is called, the data field
d1665 1
a1665 1
    }
d1668 1
a1668 1
     * Edit text for the given VisualItem and field. Presents a text
d1670 1
a1670 1
     * to hide the text widget. When stopEditing() is called, the field
d1687 1
a1687 1
    }
d1706 1
a1706 1
    }
d1725 1
a1725 1
    }
@


1.1.2.7
log
@Javadoc'd.
@
text
@d93 1
a93 1
 * {@@link #editText(prefuse.visual.VisualItem, String)} methods.</p>
d170 3
a172 3
     * @@param predicate a predicate expression in the prefuse expression
     * language. This expression will be parsed; if the parsing fails or does
     * not result in a Predicate instance, an exception will result.
d184 1
a184 1
     * @@param predicate the filtering {@@link prefuse.data.expression.Predicate}
d385 1
a385 1
     * @@param expr the filtering predicate to use. The predicate string will be
d482 1
a482 1
     * @@param b the Rectangle2D to use to store the return value
d513 2
a514 2
     * of available formats varies by platform. See
     * {@@link javax.imageio.ImageIO} and related classes for more.
d883 2
a884 1
     * @@param p the point to center on, in screen co-ords
d894 2
a895 1
     * @@param p the point to center on, in absolute co-ords
@


1.1.2.8
log
@Standardized @@author tag contents
Added toggle for enabling/disabling damage/redraw
EdgeRenderer now cleanly pulls edge widths from the size field
Refactored TupleManager to a single reusable class
@
text
@d96 1
a96 1
 * @@author <a href="http://jheer.org">jeffrey heer</a>
a120 1
    protected boolean       m_damageRedraw = true;
a443 47
     * Indicates if damage/redraw rendering is enabled. If enabled, the display
     * will only redraw within the bounding box of all areas that have changed
     * since the last rendering operation. For small changes, such as a single
     * item being dragged, this can results in a significant performance
     * increase. By default, the damage/redraw optimization is enabled. It can
     * be disabled, however, if rendering artifacts are appearing in your
     * visualization. Be careful though, as this may not be the best solution.
     * Rendering artifacts may result because the item bounds returned by
     * {@@link prefuse.visual.VisualItem#getBounds()} are not accurate and the
     * item's {@@link prefuse.render.Renderer} is drawing outside of the
     * reported bounds. In this case, there is usually a bug in the Renderer.
     * One reported problem arises from Java itself, however, which
     * inaccurately redraws images outside of their reported bounds. If you
     * have a visulization with a number of images and are seeing rendering
     * artifacts, try disabling damage/redraw.
     * @@return true if damage/redraw optimizations are enabled, false
     * otherwise (in which case the entire Display is redrawn upon a repaint)
     */
    public synchronized boolean isDamageRedraw() {
        return m_damageRedraw;
    }
    
    /**
     * Sets if damage/redraw rendering is enabled. If enabled, the display
     * will only redraw within the bounding box of all areas that have changed
     * since the last rendering operation. For small changes, such as a single
     * item being dragged, this can results in a significant performance
     * increase. By default, the damage/redraw optimization is enabled. It can
     * be disabled, however, if rendering artifacts are appearing in your
     * visualization. Be careful though, as this may not be the best solution.
     * Rendering artifacts may result because the item bounds returned by
     * {@@link prefuse.visual.VisualItem#getBounds()} are not accurate and the
     * item's {@@link prefuse.render.Renderer} is drawing outside of the
     * reported bounds. In this case, there is usually a bug in the Renderer.
     * One reported problem arises from Java itself, however, which
     * inaccurately redraws images outside of their reported bounds. If you
     * have a visulization with a number of images and are seeing rendering
     * artifacts, try disabling damage/redraw.
     * @@param b true to enable damage/redraw optimizations, false otherwise
     * (in which case the entire Display will be redrawn upon a repaint)
     */
    public synchronized void setDamageRedraw(boolean b) {
        m_damageRedraw = b;
        m_clip.invalidate();
    }
    
    /**
d448 1
a448 2
        if ( m_damageRedraw )
            m_clip.union(region);
d465 1
a465 2
        if ( m_damageRedraw )
            m_clip.reset();
d658 8
d671 20
a690 38
            if ( m_damageRedraw ) {  
                if ( m_clip.isInvalid() ) {
                    // if clip is invalid, we clip to the entire screen
                    m_clip.setClip(m_screen);
                } else {
                    // otherwise intersect damaged region with display bounds
                    m_clip.intersection(m_screen);
                }
  
                // expand the clip by the extra pixel margin
                m_clip.expand(pixel);
                
                // set the transform, rendering keys, etc
                prepareGraphics(g2D);
                
                // now set the actual rendering clip
                m_rclip.setFrameFromDiagonal(
                        m_clip.getMinX(), m_clip.getMinY(), 
                        m_clip.getMaxX(), m_clip.getMaxY());
                g2D.setClip(m_rclip);
                
                // finally, we want to clear the region we'll redraw. we clear
                // a slightly larger area than the clip. if we don't do this,
                // we sometimes get rendering artifacts, possibly due to
                // scaling mismatches in the Java2D implementation
                m_rclip.setFrameFromDiagonal(
                        m_clip.getMinX()-pixel, m_clip.getMinY()-pixel,
                        m_clip.getMaxX()+pixel, m_clip.getMaxY()+pixel);

            } else {
                // set the background region to clear
                m_rclip.setFrame(0, 0, getWidth(), getHeight());
                // set the item clip to the current screen
                m_clip.setClip(m_screen);
                // set the transform, rendering keys, etc
                prepareGraphics(g2D);
            }

d693 1
d725 1
a725 2
            if ( m_damageRedraw )
                m_clip.reset();
d729 1
a729 2
            
        }} // end synchronized block
@


1.1.2.9
log
@Intermediate commit in run-up to release.
Upgraded Tuple, Node, and Edge to the data package.
Renamed "Function" classes to "Action" classes.
Added Shape to VisualItem Schema.
Added ShapeActions, moved Shape constants to Constants interface.
Added Background image handling to the Display class.
Added social network data file.
@
text
@a7 1
import java.awt.Image;
a47 1
import prefuse.util.display.BackgroundPainter;
d70 1
a70 1
 * drawing order of items is
d77 2
a78 2
 * interface provides the user interface callbacks for supporting
 * interaction. The {@@link prefuse.controls} package contains a number
a123 3
    // optional background image
    protected BackgroundPainter m_bgpainter = null;
    
d167 1
a167 1
     * Predicate. The predicate string will be parsed by the
d269 1
a269 1
        setPreferredSize(new Dimension(width, height));
a440 50

    /**
     * Set a background image for this display.
     * @@param image the background Image. If a null value is provided, 
     * than no background image will be shown.
     * @@param fixed true if the background image should stay in a fixed
     * position, invariant to panning, zooming, or rotation; false if
     * the image should be subject to view transforms
     * @@param tileImage true to tile the image across the visible background,
     * false to only include the image once
     */
    public synchronized void setBackgroundImage(Image image,
                                      boolean fixed, boolean tileImage)
    {
        BackgroundPainter bg = null;
        if ( image != null )
            bg = new BackgroundPainter(image, fixed, tileImage);
        setBackgroundPainter(bg);
    }

    /**
     * Set a background image for this display.
     * @@param location a location String of where to retrieve the
     * image file from. Uses
     * {@@link prefuse.util.io.IOLib#urlFromString(String)} to resolve
     * the String. If a null value is provided, than no background
     * image will be shown.
     * @@param fixed true if the background image should stay in a fixed
     * position, invariant to panning, zooming, or rotation; false if
     * the image should be subject to view transforms
     * @@param tileImage true to tile the image across the visible background,
     * false to only include the image once
     */
    public synchronized void setBackgroundImage(String location,
                                      boolean fixed, boolean tileImage)
    {
        BackgroundPainter bg = null;
        if ( location != null )
            bg = new BackgroundPainter(location, fixed, tileImage);
        setBackgroundPainter(bg);        
    }
    
    private void setBackgroundPainter(BackgroundPainter bg) {
        if ( m_bgpainter != null )
            removePaintListener(m_bgpainter);
        m_bgpainter = bg;
        if ( bg != null )
            addPaintListener(bg);
    }
    
d448 1
a448 1
     * item being dragged, this can result in a significant performance
d471 1
a471 1
     * item being dragged, this can result in a significant performance
d666 2
a667 2
        // Why not fire a pre-paint event here?
        // Pre-paint events are fired by the clearRegion method
a833 2
        // fire pre-paint events to any painters
        firePrePaint(g);
a1001 29
    
    /**
     * Rotates the view provided by this display by the given angle in radians,
     * anchoring the rotation at the specified point in screen coordinates.
     * @@param p the anchor point for the rotation, in screen coordinates
     * @@param theta the angle to rotate by, in radians
     */
    public synchronized void rotate(final Point2D p, double theta) {
        m_itransform.transform(p, m_tmpPoint);
        rotateAbs(m_tmpPoint, theta);
    }    
    
    /**
     * Rotates the view provided by this display by the given angle in radians,
     * anchoring the rotation at the specified point in absolute coordinates.
     * @@param p the anchor point for the rotation, in absolute
     *  (i.e. item-space) co-ordinates
     * @@param theta the angle to rotation by, in radians
     */
    public synchronized void rotateAbs(final Point2D p, double theta) {
        double zx = p.getX(), zy = p.getY();
        damageReport();
        m_transform.translate(zx, zy);
        m_transform.rotate(theta);
        m_transform.translate(-zx, -zy);
        try {
            m_itransform = m_transform.createInverse();
        } catch ( Exception e ) { /*will never happen here*/ }
    }
@


1.1.2.10
log
@Changed interaction mechanism of RotationControl
Added documentation of expression language to ExpressionParser javadoc
Added inclusion of edge arrows in bounds computation for EdgeRenderer
Added integer dimensions check to LabelRenderer
Added new readme file
@
text
@d862 1
a862 1
     * provide the maximum print quality.
@


