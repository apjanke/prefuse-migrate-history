head	2.2;
access;
symbols
	java_1_5:2.2.0.4
	Root_java_1_5:2.2
	beta:2.2.0.2
	beta-20080113:2.2
	beta-20071021:2.1
	beta-20060220:2.0
	beta-20060209:2.0;
locks; strict;
comment	@# @;


2.2
date	2008.01.17.03.52.31;	author jheer;	state Exp;
branches
	2.2.4.1;
next	2.1;

2.1
date	2007.10.21.21.36.05;	author jheer;	state Exp;
branches;
next	2.0;

2.0
date	2006.02.12.18.23.43;	author jheer;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.30.09.16.19;	author jheer;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2005.12.30.09.16.19;	author jheer;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2006.01.23.23.07.18;	author jheer;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2006.01.27.09.05.19;	author jheer;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2006.02.01.19.22.43;	author jheer;	state Exp;
branches;
next	;

2.2.4.1
date	2008.01.23.23.55.40;	author jogiles;	state Exp;
branches;
next	2.2.4.2;

2.2.4.2
date	2008.02.21.04.27.42;	author amarsden;	state Exp;
branches;
next	2.2.4.3;

2.2.4.3
date	2008.04.27.21.59.56;	author amarsden;	state Exp;
branches;
next	2.2.4.4;

2.2.4.4
date	2008.05.21.23.08.06;	author jogiles;	state Exp;
branches;
next	2.2.4.5;

2.2.4.5
date	2008.05.28.06.51.48;	author jogiles;	state Exp;
branches;
next	;


desc
@@


2.2
log
@Added rescheduling bug fix
@
text
@package prefuse.activity;

import java.util.ArrayList;

import prefuse.util.PrefuseConfig;


/**
 * <p>The ActivityManager is responsible for scheduling and running timed 
 * activities that perform data processing and animation.</p>
 * 
 * <p>The AcivityManager runs in its own separate thread of execution, and
 * one instance is used to schedule activities from any number of currently
 * active visualizations. The class is implemented as a singleton; the single
 * instance of this class is interacted with through static methods. These
 * methods are called by an Activity's run methods, and so are made only
 * package visible here.</p>
 * 
 * <p>Activity instances can be scheduled by using their  
 * {@@link prefuse.activity.Activity#run()},
 * {@@link prefuse.activity.Activity#runAt(long)}, and 
 * {@@link prefuse.activity.Activity#runAfter(Activity)}
 * methods. These will automatically call the
 * appropriate methods with the ActivityManager.</p>
 * 
 * <p>For {@@link prefuse.action.Action} instances, one can also register
 * the actions with a {@@link prefuse.Visualization} and use the
 * visualizations provided run methods to launch Actions in a
 * convenient fashion. The interface, which is backed by an {@@link ActivityMap}
 * instance, also provides a useful level of indirection, allowing actions
 * to be changed dynamically without changes to code in other locations.
 * </p>
 *
 * @@author <a href="http://jheer.org">jeffrey heer</a>
 * @@see Activity
 * @@see prefuse.action.Action
 */
public class ActivityManager extends Thread {
    
    private static ActivityManager s_instance;
    
    private ArrayList m_activities;
    private ArrayList m_tmp;
    private long      m_nextTime;
    private boolean   m_run;
    
    /**
     * Returns the active ActivityManager instance.
     * @@return the ActivityManager
     */
    private synchronized static ActivityManager getInstance() {
        if ( s_instance == null || !s_instance.isAlive() ) {
            s_instance = new ActivityManager();
        }
        return s_instance;
    }
    
    /**
     * Create a new ActivityManger.
     */
    private ActivityManager() {
        super("prefuse_ActivityManager");
        m_activities = new ArrayList();
        m_tmp = new ArrayList();
        m_nextTime = Long.MAX_VALUE;
        
        int priority = PrefuseConfig.getInt("activity.threadPriority");
        if ( priority >= Thread.MIN_PRIORITY && 
             priority <= Thread.MAX_PRIORITY )
        {
            this.setPriority(priority);
        }
        this.setDaemon(true);
        this.start();
    }
    
    /**
     * Stops the activity manager thread. All scheduled actvities are
     * canceled, and then the thread is then notified to stop running.
     */
    public static void stopThread() {
        ActivityManager am;
        synchronized ( ActivityManager.class ) {
            am = s_instance;
        }
        if ( am != null )
            am._stop();
    }
    
    /**
     * Schedules an Activity with the manager.
     * @@param a the Activity to schedule
     */
    static void schedule(Activity a) {
        getInstance()._schedule(a, a.getStartTime());
    }
    
    /**
     * Schedules an Activity to start immediately, overwriting the
     * Activity's currently set startTime.
     * @@param a the Activity to schedule
     */
    static void scheduleNow(Activity a) {
        getInstance()._schedule(a, System.currentTimeMillis());
    }
    
    /**
     * Schedules an Activity at the specified startTime, overwriting the
     * Activity's currently set startTime.
     * @@param a the Activity to schedule
     * @@param startTime the time at which the activity should run
     */
    static void scheduleAt(Activity a, long startTime) {
        getInstance()._schedule(a, startTime);
    }
    
    /**
     * Schedules an Activity to start immediately after another Activity.
     * The second Activity will be scheduled to start immediately after the
     * first one finishes, overwriting any previously set startTime. If the
     * first Activity is cancelled, the second one will not run.
     * 
     * This functionality is provided by using an ActivityListener to monitor
     * the first Activity. The listener is removed upon completion or
     * cancellation of the first Activity.
     * 
     * This method does not effect the scheduling of the first Activity.
     * @@param before the first Activity to run
     * @@param after the Activity to run immediately after the first
     */
    static void scheduleAfter(Activity before, Activity after) {
        getInstance()._scheduleAfter(before, after);
    }
    
    /**
     * Schedules an Activity to start immediately after another Activity.
     * The second Activity will be scheduled to start immediately after the
     * first one finishes, overwriting any previously set startTime. If the
     * first Activity is cancelled, the second one will not run.
     * 
     * This functionality is provided by using an ActivityListener to monitor
     * the first Activity. The listener will persist across mulitple runs,
     * meaning the second Activity will always be evoked upon a successful
     * finish of the first.
     * 
     * This method does not otherwise effect the scheduling of the first Activity.
     * @@param before the first Activity to run
     * @@param after the Activity to run immediately after the first
     */
    static void alwaysScheduleAfter(Activity before, Activity after) {
        getInstance()._alwaysScheduleAfter(before, after);
    }
    
    /**
     * Cancels an Activity and removes it from this manager, called by
     * an Activity when the activity needs to be cancelled. 
     * @@param a The activity to cancel.
     */
    static void cancelActivity(Activity a){
    	getInstance()._cancelActivity(a);
    }
    
    /**
     * Returns the number of scheduled activities
     * @@return the number of scheduled activities
     */
    public static int activityCount() {
        return getInstance()._activityCount();
    }
    
    /**
     * Stops the activity manager thread. All scheduled actvities are
     * canceled, and then the thread is then notified to stop running.
     */
    private synchronized void _stop() {
        while ( m_activities.size() > 0 ) {
            Activity a = (Activity)m_activities.get(m_activities.size()-1);
            a.cancel();
        }
        _setRunning(false);
        notify();
    }
    
    /**
     * Schedules an Activity with the manager.
     * @@param a the Activity to schedule
     */
    private void _schedule(Activity a, long startTime) {
        if ( a.isScheduled() ) {
        	// reset the start time for reschedules, bug fix from mgara
        	a.setStartTime(startTime);
        	try { notifyAll(); } catch ( Exception e ) {}
            return; // already scheduled, do nothing
        }
        a.setStartTime(startTime);
        synchronized ( this ) {
            m_activities.add(a);
            a.setScheduled(true);
            if ( startTime < m_nextTime ) { 
               m_nextTime = startTime;
               notify();
            }
        }
    }
    
    /**
     * Schedules an Activity to start immediately after another Activity.
     * The second Activity will be scheduled to start immediately after the
     * first one finishes, overwriting any previously set startTime. If the
     * first Activity is cancelled, the second one will not run.
     * 
     * This functionality is provided by using an ActivityListener to monitor
     * the first Activity. The listener is removed upon completion or
     * cancellation of the first Activity.
     * 
     * This method does not effect the scheduling of the first Activity.
     * @@param before the first Activity to run
     * @@param after the Activity to run immediately after the first
     */
    private void _scheduleAfter(Activity before, Activity after) {
        before.addActivityListener(new ScheduleAfterActivity(after,true));
    }
    
    /**
     * Schedules an Activity to start immediately after another Activity.
     * The second Activity will be scheduled to start immediately after the
     * first one finishes, overwriting any previously set startTime. If the
     * first Activity is cancelled, the second one will not run.
     * 
     * This functionality is provided by using an ActivityListener to monitor
     * the first Activity. The listener will persist across mulitple runs,
     * meaning the second Activity will always be evoked upon a successful
     * finish of the first.
     * 
     * This method does not otherwise effect the scheduling of the first Activity.
     * @@param before the first Activity to run
     * @@param after the Activity to run immediately after the first
     */
    private void _alwaysScheduleAfter(Activity before, Activity after) {
        before.addActivityListener(new ScheduleAfterActivity(after,false));
    }
    
    /**
     * Cancels an action, called by an Activity when it is cancelled. 
     * Application code should not call this method! Instead, use 
     * Activity.cancel() to stop a sheduled or running Activity.
     * @@param a The Activity to cancel
     */
    private void _cancelActivity(Activity a){
    	/*
    	 * Prefuse Bug ID #1708926
         * The fix ("Contribution") has not been tested and/or validated for release as or in products,
         * combinations with products or other commercial use.
         * Any use of the Contribution is entirely made at the user's own responsibility and the user can
         * not rely on any features, functionalities or performances Alcatel-Lucent has attributed to the Contribution.
         * THE CONTRIBUTION BY ALCATEL-LUCENT (...) IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND,
         * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
         * FITNESS FOR A PARTICULAR PURPOSE, COMPLIANCE, NON-INTERFERENCE  AND/OR INTERWORKING WITH THE SOFTWARE
         * TO WHICH THE CONTRIBUTION HAS BEEN MADE, TITLE AND NON-INFRINGEMENT.
         * IN NO EVENT SHALL ALCATEL-LUCENT (...) BE LIABLE FOR ANY DAMAGES OR OTHER LIABLITY,
         * WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE CONTRIBUTION
         * OR THE USE OR OTHER DEALINGS IN THE CONTRIBUTION,
         * WHETHER TOGETHER WITH THE SOFTWARE TO WHICH THE CONTRIBUTION RELATES OR ON A STAND ALONE BASIS.
    	 */
        boolean fire = false;
        //removeActivity synchronizes on this, we need to lock this
        //before we lock the activity to avoid deadlock
        synchronized ( this ) {
        	synchronized(a)
        	{
        		if ( a.isScheduled() ) {
        			// attempt to remove this activity, if the remove fails,
        			// this activity is not currently scheduled with the manager
        			_removeActivity(a);
        			fire = true;
        		}
        		a.setRunning(false);
        	}
        }
        if ( fire )
            a.fireActivityCancelled();
    }
    
    /**
     * Removes an Activity from this manager, called by an
     * Activity when it finishes or is cancelled. Application 
     * code should not call this method! Instead, use 
     * Activity.cancel() to stop a sheduled or running Activity.
     * @@param a
     * @@return true if the activity was found and removed, false
     *  if the activity is not scheduled with this manager.
     */
    private boolean _removeActivity(Activity a) {
        boolean r;
        synchronized ( this ) {
            r = m_activities.remove(a);
            if ( r ) {
                if ( m_activities.size() == 0 ) {
                    m_nextTime = Long.MAX_VALUE;
                }
            }
        }
        if ( r ) {
            a.setScheduled(false);
        }
        return r;
    }
    
    /**
     * Returns the number of scheduled activities
     * @@return the number of scheduled activities
     */
    private synchronized int _activityCount() {
        return m_activities.size();
    }
    
    /**
     * Sets the running flag for the ActivityManager instance.
     */
    private synchronized void _setRunning(boolean b) {
        m_run = b;
    }
    
    /**
     * Used by the activity loop to determine if the ActivityManager
     * thread should keep running or exit.
     */
    private synchronized boolean _keepRunning() {
        return m_run;
    }
    
    /**
     * Main scheduling thread loop. This is automatically started upon
     * initialization of the ActivityManager.
     */
    public void run() {
        _setRunning(true);
        while ( _keepRunning() ) {
            if ( _activityCount() > 0 ) {
                long currentTime = System.currentTimeMillis();
                long t = -1;
                
                synchronized (this) {
                    // copy content of activities, as new activities might
                    // be added while we process the current ones
                    for ( int i=0; i<m_activities.size(); i++ ) {
                        Activity a = (Activity)m_activities.get(i);
                        m_tmp.add(a);
                        
                        // remove activities that won't be run again
                        if ( currentTime >= a.getStopTime() )
                        {
                            m_activities.remove(i--);
                            a.setScheduled(false);
                        }
                    }
                    // if no activities left, reflect that in the next time
                    if ( m_activities.size() == 0 ) {
                        m_nextTime = Long.MAX_VALUE;
                    }
                }
                
                for ( int i=0; i<m_tmp.size(); i++ ) {
                    // run the activity - the activity will check for
                    // itself if it should perform any action or not
                    Activity a = (Activity)m_tmp.get(i);
                    long s = a.runActivity(currentTime);
                    // compute minimum time for next activity cycle
                    t = (s<0 ? t : t<0 ? s : Math.min(t,s));
                }

                // clear the temporary list
                m_tmp.clear();
                
                if ( t == -1 ) continue;
                
                // determine the next time we should run
                try {
                    synchronized (this) { wait(t); }
                } catch (InterruptedException e) { }
                
            } else {
                // nothing to do, chill out until notified
                try {
                    synchronized (this) { wait(); }
                } catch (InterruptedException e) { }
            }
        }
    }
    
    public class ScheduleAfterActivity extends ActivityAdapter {
        Activity after;
        boolean remove;
        public ScheduleAfterActivity(Activity after, boolean remove) {
            this.after = after;
            this.remove = remove;
        }
        public void activityFinished(Activity a) {
            if ( remove ) a.removeActivityListener(this);
            scheduleNow(after);
        }
        public void activityCancelled(Activity a) {
            if ( remove ) a.removeActivityListener(this);
        }
    } // end of inner class ScheduleAfterActivity
    
} // end of class ActivityManager
@


2.2.4.1
log
@First import of a Java 1.5-targetted version of prefuse.
@
text
@a3 1
import java.util.List;
d9 1
a9 1
 * <p>The ActivityManager is responsible for scheduling and running timed
d11 1
a11 1
 *
d18 2
a19 2
 *
 * <p>Activity instances can be scheduled by using their
d21 1
a21 1
 * {@@link prefuse.activity.Activity#runAt(long)}, and
d25 1
a25 1
 *
d39 1
a39 1

d41 3
a43 3

    private final List<Activity> m_activities;
    private final List<Activity> m_tmp;
d46 1
a46 1

d57 1
a57 10

    /**
     * Cancels an Activity and removes it from this manager, called by
     * an Activity when the activity needs to be cancelled.
     * @@param a The activity to cancel.
     */
    static void cancelActivity(Activity a){
    	getInstance()._cancelActivity(a);
    }

d63 2
a64 2
        m_activities = new ArrayList<Activity>();
        m_tmp = new ArrayList<Activity>();
d66 1
a66 1

d68 1
a68 1
        if ( priority >= Thread.MIN_PRIORITY &&
d76 1
a76 1

d86 2
a87 3
        if ( am != null ) {
			am._stop();
		}
d89 1
a89 1

d97 1
a97 1

d106 1
a106 1

d116 1
a116 1

d122 1
a122 1
     *
d126 1
a126 1
     *
d134 1
a134 1

d140 1
a140 1
     *
d145 1
a145 1
     *
d153 1
a153 1

d155 3
a157 7
     * Removes an Activity from this manager, called by an
     * Activity when it finishes or is cancelled. Application
     * code should not call this method! Instead, use
     * Activity.cancel() to stop a sheduled or running Activity.
     * @@param a
     * @@return true if the activity was found and removed, false
     *  if the activity is not scheduled with this manager.
d159 2
a160 2
    static void removeActivity(Activity a) {
        getInstance()._removeActivity(a);
d162 1
a162 1

d170 1
a170 1

d177 1
a177 1
            Activity a = m_activities.get(m_activities.size()-1);
d183 1
a183 1

d190 2
d199 1
a199 1
            if ( startTime < m_nextTime ) {
d205 1
a205 1

d211 1
a211 1
     *
d215 1
a215 1
     *
d223 1
a223 1

d229 1
a229 1
     *
d234 1
a234 1
     *
d242 1
a242 1

d244 2
a245 2
     * Cancels an action, called by an Activity when it is cancelled.
     * Application code should not call this method! Instead, use
d283 1
a283 1

d286 2
a287 2
     * Activity when it finishes or is cancelled. Application
     * code should not call this method! Instead, use
d308 1
a308 1

d316 1
a316 1

d323 1
a323 1

d331 1
a331 1

d336 1
a336 2
    @@Override
	public void run() {
d342 1
a342 1

d347 1
a347 1
                        Activity a = m_activities.get(i);
d349 1
a349 1

d362 1
a362 1

d366 1
a366 1
                    Activity a = m_tmp.get(i);
d369 1
a369 1
                    t = s<0 ? t : t<0 ? s : Math.min(t,s);
d374 3
a376 5

                if ( t == -1 ) {
					continue;
				}

d381 1
a381 1

d390 1
a390 1

d398 2
a399 5
        @@Override
		public void activityFinished(Activity a) {
            if ( remove ) {
				a.removeActivityListener(this);
			}
d402 2
a403 5
        @@Override
		public void activityCancelled(Activity a) {
            if ( remove ) {
				a.removeActivityListener(this);
			}
d406 1
a406 1

@


2.2.4.2
log
@incorporated bug fix from the HEAD
@
text
@a204 2
        	// reset the start time for reschedules, bug fix from mgara
        	a.setStartTime(startTime);
@


2.2.4.3
log
@fixed some typos
@
text
@d88 2
a89 2
     * Stops the activity manager thread. All scheduled activities are
     * cancelled, and then the thread is then notified to stop running.
d207 1
a207 1
        	try { notifyAll(); } catch ( Exception e ) { }
d246 1
a246 1
     * the first Activity. The listener will persist across multiple runs,
d261 1
a261 1
     * Activity.cancel() to stop a scheduled or running Activity.
d303 1
a303 1
     * Activity.cancel() to stop a scheduled or running Activity.
@


2.2.4.4
log
@Increased ActivityManager stack depth to prevent NBodyForce causing a StackOverflowError. Thanks to Trejkaz for submitting the patch.
@
text
@d8 1
d10 12
a21 14
 * <p>
 * The ActivityManager is responsible for scheduling and running timed activities that perform data
 * processing and animation.
 * </p>
 * 
 * <p>
 * The AcivityManager runs in its own separate thread of execution, and one instance is used to
 * schedule activities from any number of currently active visualizations. The class is implemented
 * as a singleton; the single instance of this class is interacted with through static methods.
 * These methods are called by an Activity's run methods, and so are made only package visible here.
 * </p>
 * 
 * <p>
 * Activity instances can be scheduled by using their {@@link prefuse.activity.Activity#run()},
d23 10
a32 2
 * {@@link prefuse.activity.Activity#runAfter(Activity)} methods. These will automatically call the
 * appropriate methods with the ActivityManager.
d34 1
a34 9
 * 
 * <p>
 * For {@@link prefuse.action.Action} instances, one can also register the actions with a
 * {@@link prefuse.Visualization} and use the visualizations provided run methods to launch Actions
 * in a convenient fashion. The interface, which is backed by an {@@link ActivityMap} instance, also
 * provides a useful level of indirection, allowing actions to be changed dynamically without
 * changes to code in other locations.
 * </p>
 * 
d41 1
a41 18
	private static ActivityManager s_instance;

	private final List<Activity> m_activities;
	private final List<Activity> m_tmp;
	private long m_nextTime;
	private boolean m_run;

	/**
	 * Returns the active ActivityManager instance.
	 * 
	 * @@return the ActivityManager
	 */
	private synchronized static ActivityManager getInstance() {
		if (s_instance == null || !s_instance.isAlive()) {
			s_instance = new ActivityManager();
		}
		return s_instance;
	}
d43 54
a96 38
	/**
	 * Cancels an Activity and removes it from this manager, called by an Activity when the activity
	 * needs to be cancelled.
	 * 
	 * @@param a
	 *            The activity to cancel.
	 */
	static void cancelActivity(final Activity a) {
		getInstance()._cancelActivity(a);
	}

	/**
	 * Create a new ActivityManger.
	 */
	private ActivityManager() {
		super(null, null, "prefuse_ActivityManager", 1024 * 1024);
		m_activities = new ArrayList<Activity>();
		m_tmp = new ArrayList<Activity>();
		m_nextTime = Long.MAX_VALUE;

		final int priority = PrefuseConfig.getInt("activity.threadPriority");
		if (priority >= Thread.MIN_PRIORITY && priority <= Thread.MAX_PRIORITY) {
			this.setPriority(priority);
		}
		this.setDaemon(true);
		this.start();
	}

	/**
	 * Stops the activity manager thread. All scheduled activities are cancelled, and then the
	 * thread is then notified to stop running.
	 */
	public static void stopThread() {
		ActivityManager am;
		synchronized (ActivityManager.class) {
			am = s_instance;
		}
		if (am != null) {
d99 1
a99 217
	}

	/**
	 * Schedules an Activity with the manager.
	 * 
	 * @@param a
	 *            the Activity to schedule
	 */
	static void schedule(final Activity a) {
		getInstance()._schedule(a, a.getStartTime());
	}

	/**
	 * Schedules an Activity to start immediately, overwriting the Activity's currently set
	 * startTime.
	 * 
	 * @@param a
	 *            the Activity to schedule
	 */
	static void scheduleNow(final Activity a) {
		getInstance()._schedule(a, System.currentTimeMillis());
	}

	/**
	 * Schedules an Activity at the specified startTime, overwriting the Activity's currently set
	 * startTime.
	 * 
	 * @@param a
	 *            the Activity to schedule
	 * @@param startTime
	 *            the time at which the activity should run
	 */
	static void scheduleAt(final Activity a, final long startTime) {
		getInstance()._schedule(a, startTime);
	}

	/**
	 * Schedules an Activity to start immediately after another Activity. The second Activity will
	 * be scheduled to start immediately after the first one finishes, overwriting any previously
	 * set startTime. If the first Activity is cancelled, the second one will not run.
	 * 
	 * This functionality is provided by using an ActivityListener to monitor the first Activity.
	 * The listener is removed upon completion or cancellation of the first Activity.
	 * 
	 * This method does not effect the scheduling of the first Activity.
	 * 
	 * @@param before
	 *            the first Activity to run
	 * @@param after
	 *            the Activity to run immediately after the first
	 */
	static void scheduleAfter(final Activity before, final Activity after) {
		getInstance()._scheduleAfter(before, after);
	}

	/**
	 * Schedules an Activity to start immediately after another Activity. The second Activity will
	 * be scheduled to start immediately after the first one finishes, overwriting any previously
	 * set startTime. If the first Activity is cancelled, the second one will not run.
	 * 
	 * This functionality is provided by using an ActivityListener to monitor the first Activity.
	 * The listener will persist across mulitple runs, meaning the second Activity will always be
	 * evoked upon a successful finish of the first.
	 * 
	 * This method does not otherwise effect the scheduling of the first Activity.
	 * 
	 * @@param before
	 *            the first Activity to run
	 * @@param after
	 *            the Activity to run immediately after the first
	 */
	static void alwaysScheduleAfter(final Activity before, final Activity after) {
		getInstance()._alwaysScheduleAfter(before, after);
	}

	/**
	 * Removes an Activity from this manager, called by an Activity when it finishes or is
	 * cancelled. Application code should not call this method! Instead, use Activity.cancel() to
	 * stop a sheduled or running Activity.
	 * 
	 * @@param a
	 * @@return true if the activity was found and removed, false if the activity is not scheduled
	 *         with this manager.
	 */
	static void removeActivity(final Activity a) {
		getInstance()._removeActivity(a);
	}

	/**
	 * Returns the number of scheduled activities
	 * 
	 * @@return the number of scheduled activities
	 */
	public static int activityCount() {
		return getInstance()._activityCount();
	}

	/**
	 * Stops the activity manager thread. All scheduled actvities are canceled, and then the thread
	 * is then notified to stop running.
	 */
	private synchronized void _stop() {
		while (m_activities.size() > 0) {
			final Activity a = m_activities.get(m_activities.size() - 1);
			a.cancel();
		}
		_setRunning(false);
		notify();
	}

	/**
	 * Schedules an Activity with the manager.
	 * 
	 * @@param a
	 *            the Activity to schedule
	 */
	private void _schedule(final Activity a, final long startTime) {
		if (a.isScheduled()) {
			// reset the start time for reschedules, bug fix from mgara
			a.setStartTime(startTime);
			try {
				notifyAll();
			} catch (final Exception e) {
			}
			return; // already scheduled, do nothing
		}
		a.setStartTime(startTime);
		synchronized (this) {
			m_activities.add(a);
			a.setScheduled(true);
			if (startTime < m_nextTime) {
				m_nextTime = startTime;
				notify();
			}
		}
	}

	/**
	 * Schedules an Activity to start immediately after another Activity. The second Activity will
	 * be scheduled to start immediately after the first one finishes, overwriting any previously
	 * set startTime. If the first Activity is cancelled, the second one will not run.
	 * 
	 * This functionality is provided by using an ActivityListener to monitor the first Activity.
	 * The listener is removed upon completion or cancellation of the first Activity.
	 * 
	 * This method does not effect the scheduling of the first Activity.
	 * 
	 * @@param before
	 *            the first Activity to run
	 * @@param after
	 *            the Activity to run immediately after the first
	 */
	private void _scheduleAfter(final Activity before, final Activity after) {
		before.addActivityListener(new ScheduleAfterActivity(after, true));
	}

	/**
	 * Schedules an Activity to start immediately after another Activity. The second Activity will
	 * be scheduled to start immediately after the first one finishes, overwriting any previously
	 * set startTime. If the first Activity is cancelled, the second one will not run.
	 * 
	 * This functionality is provided by using an ActivityListener to monitor the first Activity.
	 * The listener will persist across multiple runs, meaning the second Activity will always be
	 * evoked upon a successful finish of the first.
	 * 
	 * This method does not otherwise effect the scheduling of the first Activity.
	 * 
	 * @@param before
	 *            the first Activity to run
	 * @@param after
	 *            the Activity to run immediately after the first
	 */
	private void _alwaysScheduleAfter(final Activity before, final Activity after) {
		before.addActivityListener(new ScheduleAfterActivity(after, false));
	}

	/**
	 * Cancels an action, called by an Activity when it is cancelled. Application code should not
	 * call this method! Instead, use Activity.cancel() to stop a scheduled or running Activity.
	 * 
	 * @@param a
	 *            The Activity to cancel
	 */
	private void _cancelActivity(final Activity a) {
		/*
		 * Prefuse Bug ID #1708926 The fix ("Contribution") has not been tested and/or validated for
		 * release as or in products, combinations with products or other commercial use. Any use of
		 * the Contribution is entirely made at the user's own responsibility and the user can not
		 * rely on any features, functionalities or performances Alcatel-Lucent has attributed to
		 * the Contribution. THE CONTRIBUTION BY ALCATEL-LUCENT (...) IS PROVIDED AS IS, WITHOUT
		 * WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, COMPLIANCE, NON-INTERFERENCE AND/OR
		 * INTERWORKING WITH THE SOFTWARE TO WHICH THE CONTRIBUTION HAS BEEN MADE, TITLE AND
		 * NON-INFRINGEMENT. IN NO EVENT SHALL ALCATEL-LUCENT (...) BE LIABLE FOR ANY DAMAGES OR
		 * OTHER LIABLITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
		 * CONNECTION WITH THE CONTRIBUTION OR THE USE OR OTHER DEALINGS IN THE CONTRIBUTION,
		 * WHETHER TOGETHER WITH THE SOFTWARE TO WHICH THE CONTRIBUTION RELATES OR ON A STAND ALONE
		 * BASIS.
		 */
		boolean fire = false;
		// removeActivity synchronizes on this, we need to lock this
		// before we lock the activity to avoid deadlock
		synchronized (this) {
			synchronized (a) {
				if (a.isScheduled()) {
					// attempt to remove this activity, if the remove fails,
					// this activity is not currently scheduled with the manager
					_removeActivity(a);
					fire = true;
				}
				a.setRunning(false);
			}
		}
		if (fire) {
			a.fireActivityCancelled();
		}
	}
d101 251
a351 54
	/**
	 * Removes an Activity from this manager, called by an Activity when it finishes or is
	 * cancelled. Application code should not call this method! Instead, use Activity.cancel() to
	 * stop a scheduled or running Activity.
	 * 
	 * @@param a
	 * @@return true if the activity was found and removed, false if the activity is not scheduled
	 *         with this manager.
	 */
	private boolean _removeActivity(final Activity a) {
		boolean r;
		synchronized (this) {
			r = m_activities.remove(a);
			if (r) {
				if (m_activities.size() == 0) {
					m_nextTime = Long.MAX_VALUE;
				}
			}
		}
		if (r) {
			a.setScheduled(false);
		}
		return r;
	}

	/**
	 * Returns the number of scheduled activities
	 * 
	 * @@return the number of scheduled activities
	 */
	private synchronized int _activityCount() {
		return m_activities.size();
	}

	/**
	 * Sets the running flag for the ActivityManager instance.
	 */
	private synchronized void _setRunning(final boolean b) {
		m_run = b;
	}

	/**
	 * Used by the activity loop to determine if the ActivityManager thread should keep running or
	 * exit.
	 */
	private synchronized boolean _keepRunning() {
		return m_run;
	}

	/**
	 * Main scheduling thread loop. This is automatically started upon initialization of the
	 * ActivityManager.
	 */
	@@Override
d353 34
a386 33
		_setRunning(true);
		while (_keepRunning()) {
			if (_activityCount() > 0) {
				final long currentTime = System.currentTimeMillis();
				long t = -1;

				synchronized (this) {
					// copy content of activities, as new activities might
					// be added while we process the current ones
					for (int i = 0; i < m_activities.size(); i++) {
						final Activity a = m_activities.get(i);
						m_tmp.add(a);

						// remove activities that won't be run again
						if (currentTime >= a.getStopTime()) {
							m_activities.remove(i--);
							a.setScheduled(false);
						}
					}
					// if no activities left, reflect that in the next time
					if (m_activities.size() == 0) {
						m_nextTime = Long.MAX_VALUE;
					}
				}

				for (int i = 0; i < m_tmp.size(); i++) {
					// run the activity - the activity will check for
					// itself if it should perform any action or not
					final Activity a = m_tmp.get(i);
					final long s = a.runActivity(currentTime);
					// compute minimum time for next activity cycle
					t = s < 0 ? t : t < 0 ? s : Math.min(t, s);
				}
d388 2
a389 2
				// clear the temporary list
				m_tmp.clear();
d391 1
a391 1
				if (t == -1) {
d395 24
a418 32
				// determine the next time we should run
				try {
					synchronized (this) {
						wait(t);
					}
				} catch (final InterruptedException e) {
				}

			} else {
				// nothing to do, chill out until notified
				try {
					synchronized (this) {
						wait();
					}
				} catch (final InterruptedException e) {
				}
			}
		}
	}

	public class ScheduleAfterActivity extends ActivityAdapter {
		Activity after;
		boolean remove;

		public ScheduleAfterActivity(final Activity after, final boolean remove) {
			this.after = after;
			this.remove = remove;
		}

		@@Override
		public void activityFinished(final Activity a) {
			if (remove) {
d421 5
a425 6
			scheduleNow(after);
		}

		@@Override
		public void activityCancelled(final Activity a) {
			if (remove) {
d428 2
a429 2
		}
	} // end of inner class ScheduleAfterActivity
@


2.2.4.5
log
@updated activity manager to have a 5MB stack size - this allows for a greater recursion depth before we get exceptions from overflowing the stack.
@
text
@d76 1
a76 3
		// reserve 5 megabytes for the activity manager thread. This allows for a large recursion
		// depth before we get a stack overflow or out of memory exception.
		super(null, null, "prefuse_ActivityManager", 5 * 1024 * 1024);
@


2.1
log
@Added root node checks to TreeNodeIterator to avoid iteration errors
Updated IOLib to support relative file paths (Bug #1775875 from anonymous)
Updated JRangeSlider to support drags from arrow buttons (Bug #1747778 from colincombe)
Updated ExpressionParser to avoid long parse bug (Bug #1741759)
Updated TupleManager to expand tuple list in face of valid rows from CascadedTable instances (Bug #1741106)
Added checks for min==max condition in NumberRangeModel (Bug #1731911)
Added patch to Activity and ActivityManager to avoid deadlock on Activity.cancel() (Bug #1708926 fix from joperry)
Fixed javadoc example for DefaultRendererFactory (Bug #1674371 from cab938)
Fixed ENDPOLYGON field in VisualItem (Bug #1554408 from dimerman)
Fixed FisheyeMenu demo to avoid deadlock (Bug #1672798)
Updated Tree.getDepth to return -1 if node is valid (in the node table) but not in tree (fix from joperry)
Added Display.reset method to release used memory from an idle, unused Display instance
Added Graph.removeAllGraphListeners() method
Added Table.removeAllTableListeners() method
Added isAsynchronous / setAsynchronous methods to ImageFactory
Updated Visualization.invalidate to invalidate just the group specified (it incorrectly was invalidating all groups)
Updated ActivityManager._schedule to call notifyAll when an already scheduled item is re-scheduled
@
text
@d190 2
@


2.0
log
@Merge beta branch back onto main trunk
@
text
@d155 3
a157 7
     * Removes an Activity from this manager, called by an
     * Activity when it finishes or is cancelled. Application 
     * code should not call this method! Instead, use 
     * Activity.cancel() to stop a sheduled or running Activity.
     * @@param a
     * @@return true if the activity was found and removed, false
     *  if the activity is not scheduled with this manager.
d159 2
a160 2
    static void removeActivity(Activity a) {
        getInstance()._removeActivity(a);
d190 1
d242 41
@


1.1
log
@file ActivityManager.java was initially added on branch beta.
@
text
@d1 367
@


1.1.2.1
log
@Initial commit of prefuse beta
@
text
@a0 361
package prefuse.activity;

import java.util.ArrayList;

import prefuse.util.PrefuseConfig;


/**
 * <p>The ActivityManager is responsible for scheduling and running timed 
 * activities that perform graph processing and animation.</p>
 * 
 * <p>The AcivityManager runs in its own separate thread of execution, and
 * one instance is used to schedule activities from any number of currently
 * active visualizations. The class is implemented as a singleton; the single
 * instance of this class is interacted with through static methods. These
 * methods are called by an Activity's run methods, and so are made only
 * package visible here.</p>
 * 
 * <p>Activity instances can be scheduled by using their 
 * {@@link prefuse.activity.Activity#runWhen() run()}, 
 * {@@link prefuse.activity.Activity#run() runNow()},
 * {@@link prefuse.activity.Activity#runAt(long) runAt()}, and 
 * {@@link prefuse.activity.Activity#runAfter(Activity) 
 * runAfter()} methods. These will automatically call the
 * appropriate methods with the ActivityManager.</p>
 *
 * @@version 1.0
 * @@author <a href="http://jheer.org">Jeffrey Heer</a> prefuse(AT)jheer.org
 * @@see Activity
 * @@see ActionList
 */
public class ActivityManager extends Thread {
    
    private static ActivityManager s_instance;
    
    private ArrayList m_activities;
    private ArrayList m_tmp;
    private long      m_nextTime;
    private boolean   m_run;
    
    /**
     * Returns the active ActivityManager instance.
     * @@return the ActivityManager
     */
    private synchronized static ActivityManager getInstance() {
        if ( s_instance == null || !s_instance.isAlive() ) {
            s_instance = new ActivityManager();
        }
        return s_instance;
    }
    
    /**
     * Create a new ActivityManger.
     */
    private ActivityManager() {
        super("prefuse_ActivityManager");
        m_activities = new ArrayList();
        m_tmp = new ArrayList();
        m_nextTime = Long.MAX_VALUE;
        
        int priority = PrefuseConfig.getInt("activity.threadPriority");
        if ( priority >= Thread.MIN_PRIORITY && 
             priority <= Thread.MAX_PRIORITY )
        {
            this.setPriority(priority);
        }
        this.setDaemon(true);
        this.start();
    }
    
    /**
     * Stops the activity manager thread. All scheduled actvities are
     * canceled, and then the thread is then notified to stop running.
     */
    public static void stopThread() {
        ActivityManager am;
        synchronized ( ActivityManager.class ) {
            am = s_instance;
        }
        if ( am != null )
            am._stop();
    }
    
    /**
     * Schedules an Activity with the manager.
     * @@param a the Activity to schedule
     */
    static void schedule(Activity a) {
        getInstance()._schedule(a, a.getStartTime());
    }
    
    /**
     * Schedules an Activity to start immediately, overwriting the
     * Activity's currently set startTime.
     * @@param a the Activity to schedule
     */
    static void scheduleNow(Activity a) {
        getInstance()._schedule(a, System.currentTimeMillis());
    }
    
    /**
     * Schedules an Activity at the specified startTime, overwriting the
     * Activity's currently set startTime.
     * @@param a the Activity to schedule
     * @@param startTime the time at which the activity should run
     */
    static void scheduleAt(Activity a, long startTime) {
        getInstance()._schedule(a, startTime);
    }
    
    /**
     * Schedules an Activity to start immediately after another Activity.
     * The second Activity will be scheduled to start immediately after the
     * first one finishes, overwriting any previously set startTime. If the
     * first Activity is cancelled, the second one will not run.
     * 
     * This functionality is provided by using an ActivityListener to monitor
     * the first Activity. The listener is removed upon completion or
     * cancellation of the first Activity.
     * 
     * This method does not effect the scheduling of the first Activity.
     * @@param before the first Activity to run
     * @@param after the Activity to run immediately after the first
     */
    static void scheduleAfter(Activity before, Activity after) {
        getInstance()._scheduleAfter(before, after);
    }
    
    /**
     * Schedules an Activity to start immediately after another Activity.
     * The second Activity will be scheduled to start immediately after the
     * first one finishes, overwriting any previously set startTime. If the
     * first Activity is cancelled, the second one will not run.
     * 
     * This functionality is provided by using an ActivityListener to monitor
     * the first Activity. The listener will persist across mulitple runs,
     * meaning the second Activity will always be evoked upon a successful
     * finish of the first.
     * 
     * This method does not otherwise effect the scheduling of the first Activity.
     * @@param before the first Activity to run
     * @@param after the Activity to run immediately after the first
     */
    static void alwaysScheduleAfter(Activity before, Activity after) {
        getInstance()._alwaysScheduleAfter(before, after);
    }
    
    /**
     * Removes an Activity from this manager, called by an
     * Activity when it finishes or is cancelled. Application 
     * code should not call this method! Instead, use 
     * Activity.cancel() to stop a sheduled or running Activity.
     * @@param a
     * @@return true if the activity was found and removed, false
     *  if the activity is not scheduled with this manager.
     */
    static void removeActivity(Activity a) {
        getInstance()._removeActivity(a);
    }
    
    /**
     * Returns the number of scheduled activities
     * @@return the number of scheduled activities
     */
    public static int activityCount() {
        return getInstance()._activityCount();
    }
    
    /**
     * Stops the activity manager thread. All scheduled actvities are
     * canceled, and then the thread is then notified to stop running.
     */
    private synchronized void _stop() {
        while ( m_activities.size() > 0 ) {
            Activity a = (Activity)m_activities.get(m_activities.size()-1);
            a.cancel();
        }
        _setRunning(false);
        notify();
    }
    
    /**
     * Schedules an Activity with the manager.
     * @@param a the Activity to schedule
     */
    private void _schedule(Activity a, long startTime) {
        if ( a.isScheduled() ) {
            return; // already scheduled, do nothing
        }
        a.setStartTime(startTime);
        synchronized ( this ) {
	        m_activities.add(a);
	        a.setScheduled(true);
	        if ( startTime < m_nextTime ) { 
	           m_nextTime = startTime;
	           notify();
	        }
        }
    }
    
    /**
     * Schedules an Activity to start immediately after another Activity.
     * The second Activity will be scheduled to start immediately after the
     * first one finishes, overwriting any previously set startTime. If the
     * first Activity is cancelled, the second one will not run.
     * 
     * This functionality is provided by using an ActivityListener to monitor
     * the first Activity. The listener is removed upon completion or
     * cancellation of the first Activity.
     * 
     * This method does not effect the scheduling of the first Activity.
     * @@param before the first Activity to run
     * @@param after the Activity to run immediately after the first
     */
    private void _scheduleAfter(Activity before, Activity after) {
        before.addActivityListener(new ScheduleAfterActivity(after,true));
    }
    
    /**
     * Schedules an Activity to start immediately after another Activity.
     * The second Activity will be scheduled to start immediately after the
     * first one finishes, overwriting any previously set startTime. If the
     * first Activity is cancelled, the second one will not run.
     * 
     * This functionality is provided by using an ActivityListener to monitor
     * the first Activity. The listener will persist across mulitple runs,
     * meaning the second Activity will always be evoked upon a successful
     * finish of the first.
     * 
     * This method does not otherwise effect the scheduling of the first Activity.
     * @@param before the first Activity to run
     * @@param after the Activity to run immediately after the first
     */
    private void _alwaysScheduleAfter(Activity before, Activity after) {
        before.addActivityListener(new ScheduleAfterActivity(after,false));
    }
    
    /**
     * Removes an Activity from this manager, called by an
     * Activity when it finishes or is cancelled. Application 
     * code should not call this method! Instead, use 
     * Activity.cancel() to stop a sheduled or running Activity.
     * @@param a
     * @@return true if the activity was found and removed, false
     *  if the activity is not scheduled with this manager.
     */
    private boolean _removeActivity(Activity a) {
        boolean r;
        synchronized ( this ) {
            r = m_activities.remove(a);
            if ( r ) {
                if ( m_activities.size() == 0 ) {
                    m_nextTime = Long.MAX_VALUE;
                }
            }
        }
        if ( r ) {
            a.setScheduled(false);
        }
        return r;
    }
    
    /**
     * Returns the number of scheduled activities
     * @@return the number of scheduled activities
     */
    private synchronized int _activityCount() {
        return m_activities.size();
    }
    
    /**
     * Sets the running flag for the ActivityManager instance.
     */
    private synchronized void _setRunning(boolean b) {
        m_run = b;
    }
    
    /**
     * Used by the activity loop to determine if the ActivityManager
     * thread should keep running or exit.
     */
    private synchronized boolean _keepRunning() {
        return m_run;
    }
    
    /**
     * Main scheduling thread loop. This is automatically started upon
     * initialization of the ActivityManager.
     */
    public void run() {
        _setRunning(true);
        while ( _keepRunning() ) {
            if ( _activityCount() > 0 ) {
                long currentTime = System.currentTimeMillis();
                long t = -1;
                
                synchronized (this) {
                    // copy content of activities, as new activities might
                    // be added while we process the current ones
                    for ( int i=0; i<m_activities.size(); i++ ) {
                        Activity a = (Activity)m_activities.get(i);
                        m_tmp.add(a);
                        
                        // remove activities that won't be run again
                        if ( currentTime >= a.getStopTime() )
                        {
                            m_activities.remove(i--);
                            a.setScheduled(false);
                        }
                    }
                    // if no activities left, reflect that in the next time
                    if ( m_activities.size() == 0 ) {
                        m_nextTime = Long.MAX_VALUE;
                    }
                }
                
                for ( int i=0; i<m_tmp.size(); i++ ) {
                    // run the activity - the activity will check for
                    // itself if it should perform any action or not
                    Activity a = (Activity)m_tmp.get(i);
                    long s = a.runActivity(currentTime);
                    // compute minimum time for next activity cycle
                    t = (s<0 ? t : t<0 ? s : Math.min(t,s));
                }

                // clear the temporary list
                m_tmp.clear();
                
                if ( t == -1 ) continue;
                
                // determine the next time we should run
                try {
                    synchronized (this) { wait(t); }
                } catch (InterruptedException e) { }
                
            } else {
                // nothing to do, chill out until notified
                try {
                    synchronized (this) { wait(); }
                } catch (InterruptedException e) { }
            }
        }
    }
    
    public class ScheduleAfterActivity extends ActivityAdapter {
        Activity after;
        boolean remove;
        public ScheduleAfterActivity(Activity after, boolean remove) {
            this.after = after;
            this.remove = remove;
        }
        public void activityFinished(Activity a) {
            if ( remove ) a.removeActivityListener(this);
            scheduleNow(after);
        }
        public void activityCancelled(Activity a) {
            if ( remove ) a.removeActivityListener(this);
        }
    } // end of inner class ScheduleAfterActivity
    
} // end of class ActivityManager
@


1.1.2.2
log
@Replaced all tab characters with 4 spaces.
Ensured UNIX style line endings.
@
text
@d192 6
a197 6
            m_activities.add(a);
            a.setScheduled(true);
            if ( startTime < m_nextTime ) { 
               m_nextTime = startTime;
               notify();
            }
@


1.1.2.3
log
@Lots of javadoc
@
text
@d10 1
a10 1
 * activities that perform data processing and animation.</p>
d20 2
a21 2
 * {@@link prefuse.activity.Activity#runWhen() runWhen()}, 
 * {@@link prefuse.activity.Activity#run() run()},
a25 8
 * 
 * <p>For {@@link prefuse.action.Action} instances, one can also register
 * the actions with a {@@link prefuse.Visualization} and use the
 * visualizations provided run methods to launch Actions in a
 * convenient fashion. The interface, which is backed by an {@@link ActivityMap}
 * instance, also provides a useful level of indirection, allowing actions
 * to be changed dynamically without changes to code in other locations.
 * </p>
d27 2
a28 1
 * @@author <a href="http://jheer.org">jeffrey heer</a>
@


1.1.2.4
log
@Javadoc'd.
@
text
@d19 6
a24 5
 * <p>Activity instances can be scheduled by using their  
 * {@@link prefuse.activity.Activity#run()},
 * {@@link prefuse.activity.Activity#runAt(long)}, and 
 * {@@link prefuse.activity.Activity#runAfter(Activity)}
 * methods. These will automatically call the
d37 1
a37 1
 * @@see prefuse.action.Action
@


