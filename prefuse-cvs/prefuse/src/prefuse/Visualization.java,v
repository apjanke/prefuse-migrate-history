head	2.12;
access;
symbols
	java_1_5:2.10.0.4
	Root_java_1_5:2.10
	beta:2.10.0.2
	beta-20080113:2.10
	beta-20071021:2.10
	beta-20060220:2.2
	beta-20060209:2.0;
locks; strict;
comment	@# @;


2.12
date	2008.03.28.08.53.22;	author chrisnf;	state Exp;
branches;
next	2.11;

2.11
date	2008.03.28.08.49.19;	author chrisnf;	state Exp;
branches;
next	2.10;

2.10
date	2007.10.21.21.36.05;	author jheer;	state Exp;
branches
	2.10.4.1;
next	2.9;

2.9
date	2006.11.03.19.17.16;	author jheer;	state Exp;
branches;
next	2.8;

2.8
date	2006.07.15.17.13.21;	author jheer;	state Exp;
branches;
next	2.7;

2.7
date	2006.04.14.06.59.04;	author jheer;	state Exp;
branches;
next	2.6;

2.6
date	2006.03.24.17.33.32;	author jheer;	state Exp;
branches;
next	2.5;

2.5
date	2006.03.06.00.37.21;	author jheer;	state Exp;
branches;
next	2.4;

2.4
date	2006.02.27.03.59.10;	author jheer;	state Exp;
branches;
next	2.3;

2.3
date	2006.02.25.01.56.08;	author jheer;	state Exp;
branches;
next	2.2;

2.2
date	2006.02.20.09.36.39;	author jheer;	state Exp;
branches;
next	2.1;

2.1
date	2006.02.17.18.02.56;	author jheer;	state Exp;
branches;
next	2.0;

2.0
date	2006.02.12.18.23.42;	author jheer;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.30.09.16.20;	author jheer;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2005.12.30.09.16.20;	author jheer;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2006.01.16.20.07.42;	author jheer;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2006.01.23.22.08.48;	author jheer;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2006.01.23.23.07.20;	author jheer;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2006.02.01.19.22.44;	author jheer;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2006.02.02.19.01.53;	author jheer;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2006.02.07.00.42.53;	author jheer;	state Exp;
branches;
next	;

2.10.4.1
date	2008.01.23.23.55.41;	author jogiles;	state Exp;
branches;
next	2.10.4.2;

2.10.4.2
date	2008.04.27.22.00.41;	author amarsden;	state Exp;
branches;
next	2.10.4.3;

2.10.4.3
date	2008.05.06.01.46.22;	author amarsden;	state Exp;
branches;
next	2.10.4.4;

2.10.4.4
date	2008.06.09.00.47.45;	author jogiles;	state Exp;
branches;
next	;


desc
@@


2.12
log
@fixed Javadoc on Visualization.addAggregates(String, Schema)
@
text
@package prefuse;

import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;

import prefuse.action.Action;
import prefuse.activity.Activity;
import prefuse.activity.ActivityMap;
import prefuse.data.Graph;
import prefuse.data.Node;
import prefuse.data.Schema;
import prefuse.data.Table;
import prefuse.data.Tree;
import prefuse.data.Tuple;
import prefuse.data.expression.Expression;
import prefuse.data.expression.Predicate;
import prefuse.data.expression.parser.ExpressionParser;
import prefuse.data.tuple.CompositeTupleSet;
import prefuse.data.tuple.DefaultTupleSet;
import prefuse.data.tuple.TupleManager;
import prefuse.data.tuple.TupleSet;
import prefuse.render.DefaultRendererFactory;
import prefuse.render.Renderer;
import prefuse.render.RendererFactory;
import prefuse.util.PrefuseConfig;
import prefuse.util.PrefuseLib;
import prefuse.util.collections.CompositeIterator;
import prefuse.visual.AggregateTable;
import prefuse.visual.VisualGraph;
import prefuse.visual.VisualItem;
import prefuse.visual.VisualTable;
import prefuse.visual.VisualTree;
import prefuse.visual.VisualTupleSet;
import prefuse.visual.expression.ValidatedPredicate;
import prefuse.visual.expression.VisiblePredicate;
import prefuse.visual.tuple.TableDecoratorItem;
import prefuse.visual.tuple.TableEdgeItem;
import prefuse.visual.tuple.TableNodeItem;

/**
 * <p>Central data structure representing an interactive Visualization.
 * This class is responsible for
 * managing the mappings between source data and onscreen VisualItems,
 * maintaining a list of {@@link Display} instances responsible for rendering
 * of and interaction with the contents of this visualization, and
 * providing a collection of named Action instances for performing
 * data processing such as layout, animation, and size, shape, and color
 * assignment.</p>
 * 
 * <p>The primary responsibility of the Visualization class is the creation
 * of <em>visual abstractions</em> of input data. Regardless of the data
 * structure (i.e., {@@link prefuse.data.Table}, {@@link prefuse.data.Graph},
 * or {@@link prefuse.data.Tree}), this class takes source data such as that
 * loaded from a file (see {@@link prefuse.data.io}) or from a relational
 * database (see {@@link prefuse.data.io.sql}) and creates a visual
 * representation of the data. These visual representations of the data are
 * data sets in their own right, providing access to the underlying source
 * data to be visualized while also adding addition data fields specific to a
 * visualization. These fields include spatial location (x, y
 * coordinates and item bounds), color (for stroke, fill, and text), size,
 * shape, and font. For a given input data set of type
 * {@@link prefuse.data.Table}, {@@link prefuse.data.Graph}, or
 * or {@@link prefuse.data.Tree}, a corresponding instance of
 * {@@link prefuse.visual.VisualTable}, {@@link prefuse.visual.VisualGraph}, or
 * {@@link prefuse.visual.VisualTree} is created and stored in the
 * visualization. These data types inherit the data values of the source
 * data (and indeed, manipulate it directly) while additionally providing
 * the aforementioned visual variables unique to that generated
 * visual abstraction. Similarly, all {@@link prefuse.data.Tuple},
 * {@@link prefuse.data.Node}, or {@@link prefuse.data.Edge}
 * instances used to represent an entry in the source data have a
 * corresponding {@@link prefuse.visual.VisualItem},
 * {@@link prefuse.visual.NodeItem}, or {@@link prefuse.visual.EdgeItem}
 * representing the interactive, visual realization of the backing data.</p>
 * 
 * <p>The mapping of source data to a visual abstraction is accomplished
 * using {@@link #add(String, TupleSet)} and the other "add" methods. These
 * methods will automatically create the visual abstraction, and store it
 * in this visualization, associating it with a provided <em>data group name
 * </em>. This group name allows for queries to this visualization that
 * consider only VisualItem instances from that particular group. This is
 * quite useful when crafting {@@link prefuse.action.Action} instances that
 * process only a particular group of visual data. The Visualization class
 * provides mechanisms for querying any or all groups within the visualization,
 * using one or both of the group name or a filtering
 * {@@link prefuse.data.expression.Predicate} to determine the items to
 * include (see {@@link #items(Predicate)} for an examples). Source data
 * may be added multiple times to a Visualization under different group
 * names, allowing for multiple representations of the same backing data.</p>
 * 
 * <p>Additionally, the Visualization class supports VisualItem instances
 * that are not directly grounded in backing source data. Examples include
 * {@@link prefuse.visual.DecoratorItem} which "decorates" another pre-existing
 * VisualItem with a separate interactive visual object, and
 * {@@link prefuse.visual.AggregateItem} which provides an interactive visual
 * representation of an aggregated of other VisualItems. Methods for adding
 * data groups of these kinds include {@@link #addDecorators(String, String)}
 * and {@@link #addAggregates(String)}.</p>
 * 
 * <p>All of the examples discussed above are examples of <em>primary, or
 * visual, data groups</em> of VisualItems. Visualizations also support
 * <em>secondary, or focus data groups</em> that maintain additional
 * collections of the VisualItems stored in the primary groups. Examples
 * include a set of focus items (such as those that have been clicked
 * by the user), selected items (items selected by a user), or search
 * items (all matches to a search query). The exact semantics of these
 * groups and the mechanisms by which they are populated is determined by
 * application creators, but some defaults are provided. The Visualization
 * class includes some default group names, namely {@@link #FOCUS_ITEMS},
 * {@@link #SELECTED_ITEMS}, and {@@link #SEARCH_ITEMS} for the above 
 * mentioned tasks. By default, both the {@@link #FOCUS_ITEMS},
 * {@@link #SELECTED_ITEMS} focus groups are included in the Visualization,
 * represented using {@@link prefuse.data.tuple.DefaultTupleSet} instances.
 * Also, some of the interactive controls provided by the
 * {@@link prefuse.controls} package populate these sets by default. See
 * {@@link prefuse.controls.FocusControl} for an example.</p>
 * 
 * <p>Visualizations also maintain references to all the {@@link Display}
 * instances providing interactive views of the content of this
 * visualization. {@@link Display} instances registers themselves with
 * the visualization either in their constructor or through
 * the {@@link Display#setVisualization(Visualization)} method, so they
 * do not otherwise need to be added manually. Displays can be configured
 * to show all or only a subset of the data in the Visualization. A
 * filtering {@@link prefuse.data.expression.Predicate} can be used to
 * control what items are drawn by the displaying, including limiting
 * the Display to particular data groups (for example, using a
 * {@@link prefuse.visual.expression.InGroupPredicate}). The Visualization's
 * {@@link #repaint()} method will trigger a repaint on all Displays
 * associated with the visualization.</p>
 * 
 * <p>Finally, the Visualization class provides a map of named
 * {@@link prefuse.action.Action} instances that can be invoked to perform
 * processing on the VisualItems contained in the visualization.
 * Using the {@@link #putAction(String, Action)} will add a named Action
 * to the visualization, registering the Action such that a reference
 * to this Visualization will be available within the scope of the
 * Action's {@@link prefuse.action.Action#run(double)} method. Processing
 * Actions can later be invoked by name using the {@@link #run(String)}
 * method and other similar methods. This functionality not only
 * provides a convenient means of organizing a Visualization-specific
 * collection of processing Actions, it also allows for a layer of indirection
 * between an Action and its name. This allows Actions to be dynamically
 * swapped at runtime. For example, an application may make a call to
 * invoke an Action named "layout", but the actual layout processing maybe
 * be dynamically swapped by changing the Action that corresponds to that
 * name. For more information on processing Actions, see the
 * {@@link prefuse.action} packages and the top-level
 * {@@link prefuse.action.Action} class.</p>
 * 
 * @@author <a href="http://jheer.org">jeffrey heer</a>
 */
public class Visualization {
    
    /** Data group name for indicating all groups */
    public static final String ALL_ITEMS 
        = PrefuseConfig.get("visualization.allItems");
    /** Default data group name for focus items */
    public static final String FOCUS_ITEMS
        = PrefuseConfig.get("visualization.focusItems");
    /** Default data group name for selected items */
    public static final String SELECTED_ITEMS
        = PrefuseConfig.get("visualization.selectedItems");
    /** Default data group name for search result items */
    public static final String SEARCH_ITEMS
        = PrefuseConfig.get("visualization.searchItems");
    
    // visual abstraction
    // filtered tables and groups
    private Map m_visual;
    private Map m_source;
    private Map m_focus;
    
    // actions
    private ActivityMap m_actions;
    
    // renderers
    private RendererFactory m_renderers;
    
    // displays
    private ArrayList m_displays;
    
    // ------------------------------------------------------------------------
    // Constructor
    
    /**
     * Create a new, empty Visualization. Uses a DefaultRendererFactory.
     */
    public Visualization() {
        m_actions = new ActivityMap();
        m_renderers = new DefaultRendererFactory();
        m_visual = new LinkedHashMap();
        m_source = new HashMap();
        m_focus = new HashMap();
        m_displays = new ArrayList();
        
        addFocusGroup(Visualization.FOCUS_ITEMS,    new DefaultTupleSet());
        addFocusGroup(Visualization.SELECTED_ITEMS, new DefaultTupleSet());
    }
    
    // ------------------------------------------------------------------------
    // Data Methods
    
    /**
     * Add a data set to this visualization, using the given data group name.
     * A visual abstraction of the data will be created and registered with
     * the visualization. An exception will be thrown if the group name is
     * already in use.
     * @@param group the data group name for the visualized data
     * @@param data the data to visualize
     * @@return a visual abstraction of the input data, a VisualTupleSet
     * instance
     */
    public synchronized VisualTupleSet add(String group, TupleSet data) {
        return add(group, data, null);
    }

    /**
     * Add a data set to this visualization, using the given data group name.
     * A visual abstraction of the data will be created and registered with
     * the visualization. An exception will be thrown if the group name is
     * already in use.
     * @@param group the data group name for the visualized data
     * @@param data the data to visualize
     * @@param filter a filter Predicate determining which data Tuples in the
     * input data set are visualized
     * @@return a visual abstraction of the input data, a VisualTupleSet
     * instance
     */
    public synchronized VisualTupleSet add(
            String group, TupleSet data, Predicate filter)
    {
        if ( data instanceof Table ) {
            return addTable(group, (Table)data, filter);
        } else if ( data instanceof Tree ) {
            return addTree(group, (Tree)data, filter);
        } else if ( data instanceof Graph ) {
            return addGraph(group, (Graph)data, filter);
        } else {
            throw new IllegalArgumentException("Unsupported TupleSet type.");
        }
    }
    
    protected void checkGroupExists(String group) {
    	if ( m_visual.containsKey(group) || m_focus.containsKey(group) ) {
    		throw new IllegalArgumentException(
    				"Group name \'"+group+"\' already in use");
    	}
    }
    
    protected void addDataGroup(String group, VisualTupleSet ts, TupleSet src) {
    	checkGroupExists(group);
    	m_visual.put(group, ts);
    	if ( src != null )
    		m_source.put(group, src);
    }
    
    // -- Tables --------------------------------------------------------------
    
    /**
     * Add an empty VisualTable to this visualization, using the given data
     * group name. This adds a group of VisualItems that do not have a
     * backing data set, useful for creating interactive visual objects
     * that do not represent data. An exception will be thrown if the group
     * name is already in use.
     * @@param group the data group name for the visualized data
     * @@return the added VisualTable
     */
    public synchronized VisualTable addTable(String group) {
    	VisualTable vt = new VisualTable(this, group);
    	addDataGroup(group, vt, null);
        return vt;
    }
    
    /**
     * Add an empty VisualTable to this visualization, using the given data
     * group name and table schema. This adds a group of VisualItems that do
     * not have a backing data set, useful for creating interactive visual
     * objects that do not represent data. An exception will be thrown if the
     * group name is already in use.
     * @@param group the data group name for the visualized data
     * @@param schema the data schema to use for the VisualTable
     * @@return the added VisualTable
     */
    public synchronized VisualTable addTable(String group, Schema schema) {
    	VisualTable vt = new VisualTable(this, group, schema);
        addDataGroup(group, vt, null);
        return vt;
    }
    
    /**
     * Adds a data table to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized data
     * @@param table the data table to visualize
     */
    public synchronized VisualTable addTable(String group, Table table) {
        return addTable(group, table, (Predicate)null);
    }
    
    /**
     * Adds a data table to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized data
     * @@param table the data table to visualize
     * @@param filter a filter Predicate determining which data Tuples in the
     * input table are visualized
     */
    public synchronized VisualTable addTable(
            String group, Table table, Predicate filter)
    {
    	VisualTable vt = new VisualTable(table, this, group, filter);
    	addDataGroup(group, vt, table);
        return vt;
    }

    /**
     * Adds a data table to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized data
     * @@param table the data table to visualize
     * @@param schema the data schema to use for the created VisualTable
     */
    public synchronized VisualTable addTable(
            String group, Table table, Schema schema)
    {
        return addTable(group, table, null, schema);
    }
    
    /**
     * Adds a data table to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized data
     * @@param table the data table to visualize
     * @@param filter a filter Predicate determining which data Tuples in the
     * input table are visualized
     * @@param schema the data schema to use for the created VisualTable
     */
    public synchronized VisualTable addTable(
            String group, Table table, Predicate filter, Schema schema)
    {
        VisualTable vt = new VisualTable(table, this, group, filter, schema);
        addDataGroup(group, vt, table);
        return vt;
    }
    
    /**
     * Add a VisualTable to this visualization, using the table's
     * pre-set group name. An exception will be thrown if the group
     * name is already in use. This method allows you to insert custom
     * implementations of VisualTable into a Visualization. It is intended
     * for advanced users and should <b>NOT</b> be used if you do not know
     * what you are doing. In almost all cases, one of the other add methods
     * is preferred.
     * @@param table the pre-built VisualTable to add
     * @@return the added VisualTable
     */
    public synchronized VisualTable addTable(VisualTable table) {
    	addDataGroup(table.getGroup(), table, table.getParentTable());
    	table.setVisualization(this);
    	return table;
    }
    
    // -- Graphs and Trees ----------------------------------------------------
    
    /**
     * Adds a graph to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized graph. The nodes
     * and edges will be available in the "group.nodes" and "group.edges"
     * subgroups.
     * @@param graph the graph to visualize
     */
    public synchronized VisualGraph addGraph(String group, Graph graph) {
        return addGraph(group, graph, null);
    }
    
    /**
     * Adds a graph to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized graph. The nodes
     * and edges will be available in the "group.nodes" and "group.edges"
     * subgroups.
     * @@param graph the graph to visualize
     * @@param filter a filter Predicate determining which data Tuples in the
     * input graph are visualized
     */
    public synchronized VisualGraph addGraph(
            String group, Graph graph, Predicate filter)
    {
        return addGraph(group, graph, filter, VisualItem.SCHEMA, VisualItem.SCHEMA);
    }
    
    /**
     * Adds a graph to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized graph. The nodes
     * and edges will be available in the "group.nodes" and "group.edges"
     * subgroups.
     * @@param graph the graph to visualize
     * @@param filter a filter Predicate determining which data Tuples in the
     * input graph are visualized
     * @@param nodeSchema the data schema to use for the visual node table
     * @@param edgeSchema the data schema to use for the visual edge table
     */
    public synchronized VisualGraph addGraph(String group, Graph graph,
            Predicate filter, Schema nodeSchema, Schema edgeSchema)
    {
    	checkGroupExists(group); // check before adding sub-tables
        String ngroup = PrefuseLib.getGroupName(group, Graph.NODES); 
        String egroup = PrefuseLib.getGroupName(group, Graph.EDGES);

        VisualTable nt, et;
        nt = addTable(ngroup, graph.getNodeTable(), filter, nodeSchema);
        et = addTable(egroup, graph.getEdgeTable(), filter, edgeSchema);
        
        VisualGraph vg = new VisualGraph(nt, et, 
                graph.isDirected(), graph.getNodeKeyField(),
                graph.getEdgeSourceField(), graph.getEdgeTargetField());
        vg.setVisualization(this);
        vg.setGroup(group);
     
        addDataGroup(group, vg, graph);
        
        TupleManager ntm = new TupleManager(nt, vg, TableNodeItem.class);
        TupleManager etm = new TupleManager(et, vg, TableEdgeItem.class);
        nt.setTupleManager(ntm);
        et.setTupleManager(etm);
        vg.setTupleManagers(ntm, etm);
        
        return vg;
    }
    
    /**
     * Adds a tree to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized tree. The nodes
     * and edges will be available in the "group.nodes" and "group.edges"
     * subgroups.
     * @@param tree the tree to visualize
     */
    public synchronized VisualTree addTree(String group, Tree tree) {
        return addTree(group, tree, null);
    }
    
    /**
     * Adds a tree to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized tree. The nodes
     * and edges will be available in the "group.nodes" and "group.edges"
     * subgroups.
     * @@param tree the tree to visualize
     * @@param filter a filter Predicate determining which data Tuples in the
     * input graph are visualized
     */
    public synchronized VisualTree addTree(
            String group, Tree tree, Predicate filter)
    {
        return addTree(group, tree, filter, VisualItem.SCHEMA, VisualItem.SCHEMA);
    }
    
    /**
     * Adds a tree to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized tree. The nodes
     * and edges will be available in the "group.nodes" and "group.edges"
     * subgroups.
     * @@param tree the tree to visualize
     * @@param filter a filter Predicate determining which data Tuples in the
     * input graph are visualized
     * @@param nodeSchema the data schema to use for the visual node table
     * @@param edgeSchema the data schema to use for the visual edge table
     */
    public synchronized VisualTree addTree(String group, Tree tree,
            Predicate filter, Schema nodeSchema, Schema edgeSchema)
    {
    	checkGroupExists(group); // check before adding sub-tables
        String ngroup = PrefuseLib.getGroupName(group, Graph.NODES); 
        String egroup = PrefuseLib.getGroupName(group, Graph.EDGES);
        
        VisualTable nt, et;
        nt = addTable(ngroup, tree.getNodeTable(), filter, nodeSchema);
        et = addTable(egroup, tree.getEdgeTable(), filter, edgeSchema);

        VisualTree vt = new VisualTree(nt, et, tree.getNodeKeyField(),
                tree.getEdgeSourceField(), tree.getEdgeTargetField());
        vt.setVisualization(this);
        vt.setGroup(group);
        
        addDataGroup(group, vt, tree);
        
        TupleManager ntm = new TupleManager(nt, vt, TableNodeItem.class);
        TupleManager etm = new TupleManager(et, vt, TableEdgeItem.class);
        nt.setTupleManager(ntm);
        et.setTupleManager(etm);
        vt.setTupleManagers(ntm, etm);
        
        return vt;
    }
    
    // -- Aggregates ----------------------------------------------------------
    
    /**
     * Add a group of aggregates to this visualization. Aggregates are
     * used to visually represent groups of VisualItems.
     * @@param group the data group name for the aggregates.
     * @@return the generated AggregateTable
     * @@see prefuse.visual.AggregateTable
     */
    public synchronized AggregateTable addAggregates(String group) {
        return addAggregates(group, VisualItem.SCHEMA);
    }
    
    /**
     * Add a group of aggregates to this visualization. Aggregates are
     * used to visually represent groups of VisualItems.  
     * @@param group the data group name for the aggregates. 
     * @@param schema the data schema to use for the AggregateTable, should usually extend PrefuseLib.getVisualItemSchema()
     * @@return the generated AggregateTable
     * @@see prefuse.visual.AggregateTable
     */
    public synchronized AggregateTable addAggregates(String group,
                                                     Schema schema)
    {
        AggregateTable vat = new AggregateTable(this, group, schema);
        addDataGroup(group, vat, null);
        return vat;
    }
    
    // -- Derived Tables and Decorators ---------------------------------------
    
    /**
     * Add a derived table, a VisualTable that is cascaded from an
     * existing VisualTable. This is useful for creating VisualItems
     * that inherit a set of visual properties from another group of
     * VisualItems. This might be used, for example, in the creation
     * of small multiples where only a few visual attributes vary
     * across the multiples.
     * @@param group the data group to use for the derived table
     * @@param source the source data group to derive from
     * @@param filter a Predicate filter indicating which tuples of the
     * source group should be inheritable by the new group
     * @@param override a data schema indicating which data fields
     * should not be inherited, but managed locally by the derived group
     * @@return the derived VisualTable
     */
    public synchronized VisualTable addDerivedTable(
            String group, String source, Predicate filter, Schema override)
    {
        VisualTable src = (VisualTable)getGroup(source);
        VisualTable vt = new VisualTable(src, this, group, filter, override);
     
        addDataGroup(group, vt, getSourceData(source));
        return vt;
    }
    
    /**
     * Add a group of decorators to an existing visual data group. Decorators
     * are VisualItem instances intended to "decorate" another VisualItem,
     * such as providing a label or dedicated interactive control, and are
     * realizeed as {@@link prefuse.visual.DecoratorItem} instances that provide
     * access to the decorated item in addition to the standard VisualItem
     * properties. The generated table is created using the
     * {@@link #addDerivedTable(String, String, Predicate, Schema)} method,
     * but with no VisualItem properties inherited from the source group.
     * @@param group the data group to use for the decorators
     * @@param source the source data group to decorate
     * @@return the generated VisualTable of DecoratorItem instances
     */
    public synchronized VisualTable addDecorators(String group,String source) {
        return addDecorators(group, source, (Predicate)null);
    }
    
    /**
     * Add a group of decorators to an existing visual data group. Decorators
     * are VisualItem instances intended to "decorate" another VisualItem,
     * such as providing a label or dedicated interactive control, and are
     * realizeed as {@@link prefuse.visual.DecoratorItem} instances that provide
     * access to the decorated item in addition to the standard VisualItem
     * properties.
     * @@param group the data group to use for the decorators
     * @@param source the source data group to decorate
     * @@param schema schema indicating which variables should <b>not</b> be
     * inherited from the source data group and instead be managed locally
     * by the generated VisualTable
     * @@return the generated VisualTable of DecoratorItem instances
     */
    public synchronized VisualTable addDecorators(
            String group, String source, Schema schema)
    {
        return addDecorators(group, source, null, schema);
    }
    
    /**
     * Add a group of decorators to an existing visual data group. Decorators
     * are VisualItem instances intended to "decorate" another VisualItem,
     * such as providing a label or dedicated interactive control, and are
     * realizeed as {@@link prefuse.visual.DecoratorItem} instances that provide
     * access to the decorated item in addition to the standard VisualItem
     * properties.
     * @@param group the data group to use for the decorators
     * @@param source the source data group to decorate
     * @@param filter a Predicate filter indicating which tuples of the
     * source group should be inheritable by the new group
     * @@return the generated VisualTable of DecoratorItem instances
     */
    public synchronized VisualTable addDecorators(
            String group, String source, Predicate filter)
    {
        VisualTable t = addDerivedTable(group,source,filter,VisualItem.SCHEMA);
        t.setTupleManager(new TupleManager(t, null, TableDecoratorItem.class));
        return t;
    }
    
    /**
     * Add a group of decorators to an existing visual data group. Decorators
     * are VisualItem instances intended to "decorate" another VisualItem,
     * such as providing a label or dedicated interactive control, and are
     * realizeed as {@@link prefuse.visual.DecoratorItem} instances that provide
     * access to the decorated item in addition to the standard VisualItem
     * properties.
     * @@param group the data group to use for the decorators
     * @@param source the source data group to decorate
     * @@param filter a Predicate filter indicating which tuples of the
     * source group should be inheritable by the new group
     * @@param schema schema indicating which variables should <b>not</b> be
     * inherited from the source data group and instead be managed locally
     * by the generated VisualTable
     * @@return the generated VisualTable of DecoratorItem instances
     */
    public synchronized VisualTable addDecorators(
            String group, String source, Predicate filter, Schema schema)
    {
        VisualTable t = addDerivedTable(group, source, filter, schema);
        t.setTupleManager(new TupleManager(t, null, TableDecoratorItem.class));
        return t;
    }
    
    // -- Data Removal --------------------------------------------------------
    
    /**
     * Removes a data group from this Visualization. If the group is a focus
     * group, the group will simply be removed, and any subsequent attempts to
     * retrieve the group will return null. If the group is a primary group, it
     * will be removed, and any members of the group will also be removed
     * from any registered focus groups.
     * @@param group the data group to remove
     * @@return true if the group was found and removed, false if the group
     * was not found in this visualization.
     */
    public synchronized boolean removeGroup(String group) {
        // check for focus group first
        TupleSet ts = getFocusGroup(group);
        if ( ts != null ) {
            // invalidate the item to reflect group membership change
            for ( Iterator items = ts.tuples(ValidatedPredicate.TRUE);
                  items.hasNext(); )
            {
                ((VisualItem)items.next()).setValidated(false);
            }
            ts.clear(); // trigger group removal callback
            m_focus.remove(group);
            return true;
        }
        
        // focus group not found, check for primary group
        ts = getVisualGroup(group);
        if ( ts == null ) {
            // exit with false if group not found
            return false;
        }
        // remove group members from focus sets and invalidate them
        TupleSet[] focus = new TupleSet[m_focus.size()];
        m_focus.values().toArray(focus);
        for ( Iterator items = ts.tuples(); items.hasNext(); ) {
            VisualItem item = (VisualItem)items.next();
            for ( int j=0; j<focus.length; ++j ) {
                focus[j].removeTuple(item);
            }
            item.setValidated(false);
        }
        // remove data
        if ( ts instanceof CompositeTupleSet ) {
            CompositeTupleSet cts = (CompositeTupleSet)ts;
            for ( Iterator names = cts.setNames(); names.hasNext(); ) {
                String name = (String)names.next();
                String subgroup = PrefuseLib.getGroupName(group,name); 
                m_visual.remove(subgroup);
                m_source.remove(subgroup);
            }
        }
        m_visual.remove(group);
        m_source.remove(group);
        return true;
    }
    
    /**
     * Reset this visualization, clearing out all visualization tuples. All
     * data sets added using the "addXXX" methods will be removed from the
     * visualization. All registered focus groups added using the 
     * addFocusGroup() methods will be retained, but will be cleared of all
     * tuples.
     */
    public synchronized void reset() {
        // first clear out all the focus groups
        Iterator iter = m_focus.entrySet().iterator();
        while ( iter.hasNext() ) {
            Map.Entry entry = (Map.Entry)iter.next();
            TupleSet ts = (TupleSet)entry.getValue();
            ts.clear();
        }
        // finally clear out all map entries
        m_visual.clear();
        m_source.clear();
    }
    
    // ------------------------------------------------------------------------
    // Groups
    
    /**
     * Get the source data TupleSet backing the given visual data group.
     * @@return the backing source data set, or null if there is no such
     * data set
     */
    public TupleSet getSourceData(String group) {
        return (TupleSet)m_source.get(group);
    }
    
    /**
     * Get the source data TupleSet backing the given visual tuple set.
     * @@return the backing source data set, or null if there is no such
     * data set
     */
    public TupleSet getSourceData(VisualTupleSet ts) {
        return (TupleSet)m_source.get(ts.getGroup());
    }
    
    /**
     * Get the Tuple from a backing source data set that corresponds most
     * closely to the given VisualItem.
     * @@param item the VisualItem for which to retreive the source tuple
     * @@return the data source tuple, or null if no such tuple could
     * be found
     */
    public Tuple getSourceTuple(VisualItem item) {
        // get the source group and tuple set, exit if none
        String group = item.getGroup();
        TupleSet source = getSourceData(group);
        if ( source == null ) return null;
        
        // first get the source table and row value
        int row = item.getRow();
        Table t = item.getTable();
        while ( t instanceof VisualTable ) {
            VisualTable vt = (VisualTable)t;
            row = vt.getParentRow(row);
            t   = vt.getParentTable();
        }
        
        // now get the appropriate source tuple
        // graphs maintain their own tuple managers so treat them specially
        String cgroup = PrefuseLib.getChildGroup(group);
        if ( cgroup != null ) {
            String pgroup = PrefuseLib.getParentGroup(group);
            Graph g = (Graph)getSourceData(pgroup);
            if ( t == g.getNodeTable() ) {
                return g.getNode(row);
            } else {
                return g.getEdge(row);
            }
        } else {
            return t.getTuple(row);
        }
    }
    
    /**
     * Get the VisualItem associated with a source data tuple, if it exists.
     * @@param group the data group from which to lookup the source tuple,
     * only primary visual groups are valid, focus groups will not work
     * @@param t the source data tuple
     * @@return the associated VisualItem from the given data group, or
     * null if no such VisualItem exists
     */
    public VisualItem getVisualItem(String group, Tuple t) {
        TupleSet ts = getVisualGroup(group);
        VisualTable vt;
        if ( ts instanceof VisualTable ) {
            vt = (VisualTable)ts;
        } else if ( ts instanceof Graph ) {
            Graph g = (Graph)ts;
            vt = (VisualTable)(t instanceof Node ? g.getNodeTable() 
                                                 : g.getEdgeTable());
        } else {
            return null;
        }
        int pr = t.getRow();
        int cr = vt.getChildRow(pr);
        return cr<0 ? null : vt.getItem(cr);
    }
    
    // ------------------------------------------------------------------------
    
    /**
     * Get the TupleSet associated with the given data group name. 
     * @@param group a visual data group name
     * @@return the data group TupleSet
     */
    public TupleSet getGroup(String group) {
        TupleSet ts = getVisualGroup(group);
        if ( ts == null )
            ts = getFocusGroup(group);
        return ts;
    }
    
    /**
     * Indicates if a given VisualItem is contained in the given visual
     * data group.
     * @@param item the VisualItem instance
     * @@param group the data group to check for containment
     * @@return true if the VisualItem is in the group, false otherwise
     */
    public boolean isInGroup(VisualItem item, String group) {
        if ( ALL_ITEMS.equals(group) )
            return true;
        if ( item.getGroup() == group )
            return true;
        
        TupleSet tset = getGroup(group);
        return ( tset==null ? false : tset.containsTuple(item) );
    }
    
    /**
     * Add a new secondary, or focus, group to this visualization. By
     * default the added group is an instance of
     * {@@link prefuse.data.tuple.DefaultTupleSet}.
     * @@param group the name of the focus group to add
     */
    public void addFocusGroup(String group) {
    	checkGroupExists(group);
        m_focus.put(group, new DefaultTupleSet());
    }

    /**
     * Add a new secondary, or focus, group to this visualization.
     * @@param group the name of the focus group to add
     * @@param tset the TupleSet for the focus group
     */
    public void addFocusGroup(String group, TupleSet tset) {
        checkGroupExists(group);
    	m_focus.put(group, tset);
    }
    
    // ------------------------------------------------------------------------
    // VisualItems
    
    /**
     * Get the size of the given visual data group.
     * @@param group the visual data group
     * @@return the size (number of tuples) of the group
     */
    public int size(String group) {
        TupleSet tset = getGroup(group);
        return ( tset==null ? 0 : tset.getTupleCount() );
    }
    
    /**
     * Retrieve the visual data group of the given group name. Only primary
     * visual groups will be considered.
     * @@param group the visual data group
     * @@return the requested data group, or null if not found
     */
    public TupleSet getVisualGroup(String group) {
        return (TupleSet)m_visual.get(group);
    }
    
    /**
     * Retrieve the focus data group of the given group name. Only secondary,
     * or focus, groups will be considered.
     * @@param group the focus data group
     * @@return the requested data group, or null if not found
     */
    public TupleSet getFocusGroup(String group) {
        return (TupleSet)m_focus.get(group);
    }
    
    /**
     * Invalidate the bounds of all VisualItems in the given group. This
     * will cause the bounds to be recomputed for all items upon the next
     * redraw.
     * @@param group the visual data group to invalidate
     */
    public void invalidate(String group) {
        Iterator items = items(group, ValidatedPredicate.TRUE);
        while ( items.hasNext() ) {
            VisualItem item = (VisualItem)items.next();
            item.setValidated(false);
        }
    }
    
    /**
     * Invalidate the bounds of all VisualItems in this visualization. This
     * will cause the bounds to be recomputed for all items upon the next
     * redraw.
     */
    public void invalidateAll() {
        invalidate(ALL_ITEMS);
    }
    
    /**
     * Get an iterator over all visible items.
     * @@return an iterator over all visible items.
     */
    public Iterator visibleItems() {
        return items(VisiblePredicate.TRUE);
    }
    
    /**
     * Get an iterator over all visible items in the specified group.
     * @@param group the visual data group name
     * @@return an iterator over all visible items in the specified group
     */
    public Iterator visibleItems(String group) {
        return items(group, VisiblePredicate.TRUE);
    }
    
    /**
     * Get an iterator over all items, visible or not.
     * @@return an iterator over all items, visible or not.
     */
    public Iterator items() {
        return items((Predicate)null);
    }
    
    /**
     * Get an iterator over all items which match the given
     * Predicate filter.
     * @@param filter a Predicate indicating which items should be included
     * in the iteration
     * @@return a filtered iterator over VisualItems
     */
    public Iterator items(Predicate filter) {
        int size = m_visual.size();
        if ( size == 0 ) {
            return Collections.EMPTY_LIST.iterator();
        } else if ( size == 1 ) {
            Iterator it = m_visual.keySet().iterator();
            return items((String)it.next(), filter);
        } else {
            CompositeIterator iter = new CompositeIterator(m_visual.size());
            Iterator it = m_visual.keySet().iterator();
            for ( int i=0; it.hasNext(); ) {
                String group = (String)it.next();
                if ( !PrefuseLib.isChildGroup(group) )
                    iter.setIterator(i++, items(group, filter));
            }
            return iter;
        }
    }
    
    /**
     * Get an iterator over all items in the specified group.
     * @@param group the visual data group name
     * @@return an iterator over all items in the specified group.
     */
    public Iterator items(String group) {
        return items(group, (Predicate)null);
    }
    
    /**
     * Get an iterator over all items in the given group which match the given
     * filter expression.
     * @@param group the visual data group to iterate over
     * @@param expr an expression string that should parse to a Predicate
     * indicating which items should be included in the iteration. The input
     * string will be parsed using the
     * {@@link prefuse.data.expression.parser.ExpressionParser} class. If a
     * parse error occurs, an empty iterator is returned.
     * @@return a filtered iterator over VisualItems
     */
    public Iterator items(String group, String expr) {
        Expression e = ExpressionParser.parse(expr);
        if ( !(e instanceof Predicate) || ExpressionParser.getError()!=null )
            return Collections.EMPTY_LIST.iterator();
        return items(group, (Predicate)e);
    }
    
    /**
     * Get an iterator over all items in the given group which match the given
     * Predicate filter.
     * @@param group the visual data group to iterate over
     * @@param filter a Predicate indicating which items should be included in
     * the iteration.
     * @@return a filtered iterator over VisualItems
     */
    public Iterator items(String group, Predicate filter) {
        if ( ALL_ITEMS.equals(group) )
            return items(filter);

        TupleSet t = getGroup(group);
        return ( t==null ? Collections.EMPTY_LIST.iterator() 
                         : t.tuples(filter) );
    }
    
    // ------------------------------------------------------------------------
    // Batch Methods
    
    /**
     * Set a data field value for all items in a given data group matching a
     * given filter predicate.
     * @@param group the visual data group name
     * @@param p the filter predicate determining which items to modify
     * @@param field the data field / column name to set
     * @@param val the value to set
     */
    public void setValue(String group, Predicate p, String field, Object val) {
        Iterator items = items(group, p);
        while ( items.hasNext() ) {
            VisualItem item = (VisualItem)items.next();
            item.set(field, val);
        }
    }
    
    /**
     * Sets the visbility status for all items in a given data group matching
     * a given filter predicate.
     * @@param group the visual data group name
     * @@param p the filter predicate determining which items to modify
     * @@param value the visibility value to set
     */
    public void setVisible(String group, Predicate p, boolean value) {
        Iterator items = items(group, p);
        while ( items.hasNext() ) {
            VisualItem item = (VisualItem)items.next();
            item.setVisible(value);
        }
    }

    /**
     * Sets the interactivity status for all items in a given data group
     * matching a given filter predicate.
     * @@param group the visual data group name
     * @@param p the filter predicate determining which items to modify
     * @@param value the interactivity value to set
     */
    public void setInteractive(String group, Predicate p, boolean value) {
        Iterator items = items(group, p);
        while ( items.hasNext() ) {
            VisualItem item = (VisualItem)items.next();
            item.setInteractive(value);
        }
    }
    
    // ------------------------------------------------------------------------
    // Action Methods
    
    /**
     * Add a data processing Action to this Visualization. The Action will be
     * updated to use this Visualization in its data processing.
     * @@param name the name of the Action
     * @@param action the Action to add
     */
    public Action putAction(String name, Action action) {
        action.setVisualization(this);
        m_actions.put(name, action);
        return action;
    }
    
    /**
     * Get the data processing Action with the given name.
     * @@param name the name of the Action
     * @@return the requested Action, or null if the name was not found
     */
    public Action getAction(String name) {
        return (Action)m_actions.get(name);
    }
    
    /**
     * Remove a data processing Action registered with this visualization.
     * If the removed action is currently running, it will be canceled.
     * The visualization reference held by the removed Action will be set to
     * null.<br/>
     * <strong>NOTE:</strong> Errors may occur if the removed Action is 
     * included in an "always run after" relation with another registered
     * Action that has not been removed from this visualization. It is the
     * currently the responsibility of clients to avoid this situation. 
     * @@param name the name of the Action
     * @@return the removed Action, or null if no action was found
     */
    public Action removeAction(String name) {
        // TODO: create registry of always run after relations to automatically
        // resolve action references?
        Action a = getAction(name);
        if ( a != null ) {
            a.cancel();
            m_actions.remove(name);
            a.setVisualization(null);
        }
        return a;
    }
    
    /**
     * Schedule the Action with the given name to run immediately. The running
     * of all Actions is managed by the
     * {@@link prefuse.activity.ActivityManager}, which runs in a dedicated
     * thread.
     * @@param action the name of the Action to run
     * @@return the Action scheduled to run
     */
    public Activity run(String action) {
        return m_actions.run(action);
    }

    /**
     * Schedule the Action with the given name to run after the specified
     * delay. The running of all Actions is managed by the
     * {@@link prefuse.activity.ActivityManager}, which runs in a dedicated
     * thread.
     * @@param action the name of the Action to run
     * @@param delay the amount of time to wait, in milliseconds, before
     * running the Action
     * @@return the Action scheduled to run
     */
    public Activity runAfter(String action, long delay) {
        return m_actions.runAt(action, System.currentTimeMillis()+delay);
    }
    
    /**
     * Schedule the Action with the given name to run at the specified
     * time. The running of all Actions is managed by the
     * {@@link prefuse.activity.ActivityManager}, which runs in a dedicated
     * thread.
     * @@param action the name of the Action to run
     * @@param startTime the absolute system time, in milliseconds since the
     * epoch, at which to run the Action.
     * @@return the Action scheduled to run
     */
    public Activity runAt(String action, long startTime) {
        return m_actions.runAt(action, startTime);
    }
    
    /**
     * Schedule the Action with the given name to run after another Action
     * finishes running. This relationship will only hold for one round of
     * scheduling. If the "before" Action is run a second time, the "after"
     * action will not be run a second time. The running of all Actions is
     * managed by the {@@link prefuse.activity.ActivityManager}, which runs
     * in a dedicated thread.
     * @@param before the name of the Action to wait for
     * @@param after the name of the Action to run after the first one finishes
     * @@return the Action scheduled to run after the first one finishes
     */
    public Activity runAfter(String before, String after) {
        return m_actions.runAfter(before, after);
    }
    
    /**
     * Schedule the Action with the given name to always run after another Action
     * finishes running. The running of all Actions is managed by the
     * {@@link prefuse.activity.ActivityManager}, which runs in a dedicated
     * thread.
     * @@param before the name of the Action to wait for
     * @@param after the name of the Action to run after the first one finishes
     * @@return the Action scheduled to always run after the first one finishes
     */
    public Activity alwaysRunAfter(String before, String after) {
        return m_actions.alwaysRunAfter(before, after);
    }
    
    /**
     * Cancel the Action with the given name, if it has been scheduled.
     * @@param action the name of the Action to cancel
     * @@return the canceled Action
     */
    public Activity cancel(String action) {
        return m_actions.cancel(action);
    }
    
    // ------------------------------------------------------------------------
    // Renderers
    
    /**
     * Set the RendererFactory used by this Visualization. The RendererFactory
     * is responsible for providing the Renderer instances used to draw
     * the VisualItems.
     * @@param rf the RendererFactory to use.
     */
    public void setRendererFactory(RendererFactory rf) {
        invalidateAll();
        m_renderers = rf;
    }
    
    /**
     * Get the RendererFactory used by this Visualization.
     * @@return this Visualization's RendererFactory
     */
    public RendererFactory getRendererFactory() {
        return m_renderers;
    }
    
    /**
     * Get the renderer for the given item. Consults this visualization's
     * {@@link prefuse.render.RendererFactory} and returns the result.
     * @@param item the item to retreive the renderer for
     * @@return the {@@link prefuse.render.Renderer} for drawing the
     * given item
     */
    public Renderer getRenderer(VisualItem item) {
        if ( item.getVisualization() != this ) {
            throw new IllegalArgumentException(
                    "Input item not a member of this visualization.");
        }
        return m_renderers.getRenderer(item);
    }
    
    /**
     * Issue a repaint request, causing all displays associated with this
     * visualization to be repainted.
     */
    public synchronized void repaint() {
        Iterator items = items(ValidatedPredicate.FALSE);
        while ( items.hasNext() ) {
            ((VisualItem)items.next()).validateBounds();
        }
        for ( int i=0; i<m_displays.size(); ++i ) {
            getDisplay(i).repaint();
        }
    }
    
    /**
     * Get the bounding rectangle for all items in the given group.
     * @@param group the visual data group
     * @@return the bounding box of the items
     */
    public Rectangle2D getBounds(String group) {
        return getBounds(group, new Rectangle2D.Double());
    }
    
    /**
     * Get the bounding rectangle for all items in the given group.
     * @@param group the visual data group name
     * @@param r a rectangle in which to store the computed bounding box
     * @@return the input rectangle r, updated to hold the computed
     * bounding box
     */
    public Rectangle2D getBounds(String group, Rectangle2D r) {
        Iterator iter = visibleItems(group);
        if ( iter.hasNext() ) {
            VisualItem item = (VisualItem)iter.next();
            r.setRect(item.getBounds());
        }
        while ( iter.hasNext() ) {
            VisualItem item = (VisualItem)iter.next();
            Rectangle2D.union(item.getBounds(), r, r);
        }
        return r;
    }
    
    // ------------------------------------------------------------------------
    // Displays
    
    /**
     * Get the number of displays associated with this visualization.
     * @@return the number of displays
     */
    public int getDisplayCount() {
        return m_displays.size();
    }
    
    /**
     * Add a display to this visualization. Called automatically by the
     * {@@link prefuse.Display#setVisualization(Visualization)} method.
     * @@param display the Display to add
     */
    void addDisplay(Display display) {
        m_displays.add(display);
    }
    
    /**
     * Get the display at the given list index. Displays are numbered by the
     * order in which they are added to this visualization.
     * @@param idx the list index
     * @@return the Display at the given index
     */
    public Display getDisplay(int idx) {
        return (Display)m_displays.get(idx);
    }
    
    /**
     * Remove a display from this visualization.
     * @@param display the display to remove
     * @@return true if the display was removed, false if it was not found
     */
    boolean removeDisplay(Display display) {
        return m_displays.remove(display);
    }
    
    /**
     * Report damage to associated displays, indicating a region that will need
     * to be redrawn.
     * @@param item the item responsible for the damage
     * @@param region the damaged region, in item-space coordinates
     */
    public void damageReport(VisualItem item, Rectangle2D region) {
        for ( int i=0; i<m_displays.size(); ++i ) {
            Display d = getDisplay(i);
            if ( d.getPredicate().getBoolean(item) ) {
                d.damageReport(region);
            }
        }
    }
    
} // end of class Visualization
@


2.11
log
@Clarified use of addAggregates(String, Schema) in Javadoc; if Schema doesn't extend VisualItem.SCHEMA then missing column exceptions are generated when visualizing aggregates.
@
text
@d543 1
a543 1
     * @@param schema the data schema to use for the AggregateTable, should usually extend VisualItem.SCHEMA
@


2.10
log
@Added root node checks to TreeNodeIterator to avoid iteration errors
Updated IOLib to support relative file paths (Bug #1775875 from anonymous)
Updated JRangeSlider to support drags from arrow buttons (Bug #1747778 from colincombe)
Updated ExpressionParser to avoid long parse bug (Bug #1741759)
Updated TupleManager to expand tuple list in face of valid rows from CascadedTable instances (Bug #1741106)
Added checks for min==max condition in NumberRangeModel (Bug #1731911)
Added patch to Activity and ActivityManager to avoid deadlock on Activity.cancel() (Bug #1708926 fix from joperry)
Fixed javadoc example for DefaultRendererFactory (Bug #1674371 from cab938)
Fixed ENDPOLYGON field in VisualItem (Bug #1554408 from dimerman)
Fixed FisheyeMenu demo to avoid deadlock (Bug #1672798)
Updated Tree.getDepth to return -1 if node is valid (in the node table) but not in tree (fix from joperry)
Added Display.reset method to release used memory from an idle, unused Display instance
Added Graph.removeAllGraphListeners() method
Added Table.removeAllTableListeners() method
Added isAsynchronous / setAsynchronous methods to ImageFactory
Updated Visualization.invalidate to invalidate just the group specified (it incorrectly was invalidating all groups)
Updated ActivityManager._schedule to call notifyAll when an already scheduled item is re-scheduled
@
text
@d541 3
a543 3
     * used to visually represent groups of VisualItems.
     * @@param group the data group name for the aggregates.
     * @@param schema the data schema to use for the AggregateTable
@


2.10.4.1
log
@First import of a Java 1.5-targetted version of prefuse.
@
text
@a3 1
import java.lang.reflect.Array;
a8 1
import java.util.List;
a13 1
import prefuse.data.Edge;
d32 1
a32 1
import prefuse.util.collections.CompositeIterable;
a40 1
import prefuse.visual.tuple.TableAggregateItem;
a43 1
import prefuse.visual.tuple.TableVisualItem;
d54 1
a54 1
 *
d80 1
a80 1
 *
d95 1
a95 1
 *
d104 1
a104 1
 *
d115 1
a115 1
 * {@@link #SELECTED_ITEMS}, and {@@link #SEARCH_ITEMS} for the above
d122 1
a122 1
 *
d136 1
a136 1
 *
d155 1
a155 1
 *
d159 1
a159 1

d161 1
a161 1
    public static final String ALL_ITEMS
d172 1
a172 1

d175 4
a178 4
    private final Map<String, VisualTupleSet<? extends VisualItem<?>>> m_visual;
    private final Map<String, TupleSet<? extends Tuple<?>>> m_source;
    private final Map<String, TupleSet<? extends VisualItem<?>>> m_focus;

d180 2
a181 2
    private final ActivityMap m_actions;

d184 1
a184 1

d186 2
a187 2
    private final List<Display> m_displays;

d190 1
a190 1

d197 7
a203 7
        m_visual = new LinkedHashMap<String, VisualTupleSet<? extends VisualItem<?>>>();
        m_source = new HashMap<String, TupleSet<? extends Tuple<?>>>();
        m_focus = new HashMap<String, TupleSet<? extends VisualItem<?>>>();
        m_displays = new ArrayList<Display>();

        addFocusGroup(Visualization.FOCUS_ITEMS,    new DefaultTupleSet<VisualItem<?>>());
        addFocusGroup(Visualization.SELECTED_ITEMS, new DefaultTupleSet<VisualItem<?>>());
d205 1
a205 1

d208 1
a208 1

d219 1
a219 1
    public synchronized VisualTupleSet<? extends VisualItem<?>> add(String group, TupleSet<?> data) {
d235 2
a236 2
    public synchronized VisualTupleSet<? extends VisualItem<?>> add(
            String group, TupleSet<?> data, Predicate filter)
d239 1
a239 1
            return addTable(group, (Table<?>)data, filter);
d241 1
a241 1
            return addTree(group, (Tree<?,?,?>)data, filter);
d243 1
a243 1
            return addGraph(group, (Graph<?,?,?>)data, filter);
d248 1
a248 1

d255 2
a256 2

    protected void addDataGroup(String group, VisualTupleSet<? extends VisualItem<?>> ts, TupleSet<?> src) {
d259 2
a260 3
    	if ( src != null ) {
			m_source.put(group, src);
		}
d262 1
a262 1

d264 1
a264 1

d274 2
a275 2
    public synchronized VisualTable<TableVisualItem<?>,TableVisualItem<?>> addTable(String group) {
    	VisualTable<TableVisualItem<?>, TableVisualItem<?>> vt = VisualTable.createVisualTable(this, group);
d279 1
a279 1

d290 2
a291 2
    public synchronized VisualTable<TableVisualItem<?>, TableVisualItem<?>> addTable(String group, Schema schema) {
    	VisualTable<TableVisualItem<?>, TableVisualItem<?>> vt = VisualTable.createVisualTable(this, group, schema);
d295 1
a295 1

d304 1
a304 1
    public synchronized <T extends Tuple<?>> VisualTable<T, TableVisualItem<?>> addTable(String group, Table<T> table) {
d307 1
a307 1

d318 2
a319 2
    public synchronized <T extends Tuple<?>> VisualTable<T, TableVisualItem<?>> addTable(
            String group, Table<T> table, Predicate filter)
d321 1
a321 1
    	VisualTable<T, TableVisualItem<?>> vt = VisualTable.createVisualTable(table, this, group, filter);
d335 2
a336 2
    public synchronized <T extends Tuple<?>> VisualTable<T, TableVisualItem<?>> addTable(
            String group, Table<T> table, Schema schema)
d340 1
a340 43

    /**
     * Adds a data table to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized data
     * @@param table the data table to visualize
     * @@param filter a filter Predicate determining which data Tuples in the
     * input table are visualized
     * @@param schema the data schema to use for the created VisualTable
     */
    public synchronized <T extends Tuple<?>> VisualTable<T, TableVisualItem<?>> addTable(
            String group, Table<T> table, Predicate filter, Schema schema)
    {
        VisualTable<T, TableVisualItem<?>> vt = VisualTable.createVisualTable(table, this, group, filter, schema);
        addDataGroup(group, vt, table);
        return vt;
    }

    /**
     * Adds a data table to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized data
     * @@param table the data table to visualize
     * @@param filter a filter Predicate determining which data Tuples in the
     * input table are visualized
     * @@param schema the data schema to use for the created VisualTable
     */
    public synchronized <T extends Node<?,?>> VisualTable<T, TableNodeItem> addNodeTable(
            String group, Table<T> table, Predicate filter, Schema schema)
    {
        VisualTable<T, TableNodeItem> vt = new VisualTable<T, TableNodeItem>(table, this, group, filter, schema) {
			@@Override
			public TableNodeItem createTupleInstance() {
				return new TableNodeItem();
			}};
        addDataGroup(group, vt, table);
        return vt;
    }

d352 2
a353 2
    public synchronized <T extends Edge<?,?>> VisualTable<T, TableEdgeItem> addEdgeTable(
            String group, Table<T> table, Predicate filter, Schema schema)
d355 1
a355 5
        VisualTable<T, TableEdgeItem> vt = new VisualTable<T, TableEdgeItem>(table, this, group, filter, schema) {
			@@Override
			public TableEdgeItem createTupleInstance() {
				return new TableEdgeItem();
			}};
d359 1
a359 1

d371 1
a371 1
    public synchronized <S extends Tuple<?>, T extends VisualItem<?>> VisualTable<S,T> addTable(VisualTable<S,T> table) {
d376 1
a376 1

d378 1
a378 1

d389 1
a389 1
    public synchronized VisualGraph<TableVisualItem<?>, TableNodeItem, TableEdgeItem> addGraph(String group, Graph<?,?,?> graph) {
d392 1
a392 1

d405 2
a406 2
    public synchronized VisualGraph<TableVisualItem<?>, TableNodeItem, TableEdgeItem> addGraph(
            String group, Graph<?,?,?> graph, Predicate filter)
d410 1
a410 1

d425 1
a425 1
    public synchronized <N extends Node<N,E>, E extends Edge<N,E>> VisualGraph<TableVisualItem<?>, TableNodeItem, TableEdgeItem> addGraph(String group, Graph<?, N, E> graph,
d429 1
a429 1
        String ngroup = PrefuseLib.getGroupName(group, Graph.NODES);
d432 7
a438 14
        VisualTable<N, TableNodeItem> nt = addNodeTable(ngroup, graph.getNodeTable(), filter, nodeSchema);
        VisualTable<E, TableEdgeItem> et = addEdgeTable(egroup, graph.getEdgeTable(), filter, edgeSchema);

        /*
         *     public VisualGraph(VisualTable<? extends VisualItem<?>, N> nodes, VisualTable<? extends Tuple<?>, E> edges, boolean directed,
            String nodeKey, String sourceKey, String targetKey)
    {
        super(nodes, edges, directed, nodeKey, sourceKey, targetKey);
    }

         */

        VisualGraph<TableVisualItem<?>, TableNodeItem, TableEdgeItem> vg = new VisualGraph<TableVisualItem<?>, TableNodeItem, TableEdgeItem>(
        		nt, et, graph.isDirected(), graph.getNodeKeyField(), graph.getEdgeSourceField(), graph.getEdgeTargetField());
d441 1
a441 1

d443 3
a445 14

        TupleManager<TableNodeItem> ntm = new TupleManager<TableNodeItem>(nt, vg) {
			@@Override
			public TableNodeItem createTupleInstance() {
				return new TableNodeItem();
			}
        };
        TupleManager<TableEdgeItem> etm = new TupleManager<TableEdgeItem>(et, vg) {
			@@Override
			public TableEdgeItem createTupleInstance() {
				return new TableEdgeItem();
			}

        };
d449 1
a449 1

d452 1
a452 1

d463 1
a463 1
    public synchronized VisualTree<VisualItem<?>, TableNodeItem,TableEdgeItem> addTree(String group, Tree<?,?,?> tree) {
d466 1
a466 1

d479 2
a480 2
    public synchronized VisualTree<VisualItem<?>, TableNodeItem,TableEdgeItem> addTree(
            String group, Tree<?,?,?> tree, Predicate filter)
d484 1
a484 1

d499 1
a499 1
    public synchronized <N extends Node<N,E>, E extends Edge<N,E>> VisualTree<VisualItem<?>, TableNodeItem,TableEdgeItem> addTree(String group, Tree<?, N, E> tree,
d503 1
a503 1
        String ngroup = PrefuseLib.getGroupName(group, Graph.NODES);
d505 4
d510 1
a510 4
        VisualTable<N, TableNodeItem> nt = addNodeTable(ngroup, tree.getNodeTable(), filter, nodeSchema);
        VisualTable<E, TableEdgeItem> et = addEdgeTable(egroup, tree.getEdgeTable(), filter, edgeSchema);

        VisualTree<VisualItem<?>, TableNodeItem, TableEdgeItem> vt = new VisualTree<VisualItem<?>, TableNodeItem, TableEdgeItem>(nt, et, tree.getNodeKeyField(),
d514 1
a514 1

d516 3
a518 14

        TupleManager<TableNodeItem> ntm = new TupleManager<TableNodeItem>(nt, vt) {
			@@Override
			public TableNodeItem createTupleInstance() {
				return new TableNodeItem();
			}

        };
        TupleManager<TableEdgeItem> etm = new TupleManager<TableEdgeItem>(et, vt) {
			@@Override
			public TableEdgeItem createTupleInstance() {
				return new TableEdgeItem();
			}
        };
d522 1
a522 1

d525 1
a525 1

d527 1
a527 1

d535 1
a535 1
    public synchronized <V extends VisualItem<?>> AggregateTable<TableAggregateItem<V>,V> addAggregates(String group) {
d538 1
a538 1

d547 1
a547 1
    public synchronized <V extends VisualItem<?>> AggregateTable<TableAggregateItem<V>,V> addAggregates(String group,
d550 1
a550 1
        AggregateTable<TableAggregateItem<V>,V> vat = AggregateTable.createAggregateTable(this, group, schema);
d554 1
a554 1

d556 1
a556 1

d572 1
a572 1
    public synchronized VisualTable<? extends VisualItem<?>,? extends VisualItem<?>> addDerivedTable(
d575 3
a577 13
        final VisualTable<?,? extends VisualItem<?>> src = (VisualTable<?,? extends VisualItem<?>>) getGroup(source);
        return addDerivedTable(src, group, source, filter, override);
    }

    private synchronized <V extends VisualItem<?>> VisualTable<V,V> addDerivedTable(
            final VisualTable<?, V> src, String group, String source, Predicate filter, Schema override)
    {
        VisualTable<V,V> vt = new VisualTable<V,V>(src, this, group, filter, override){

			@@Override public V createTupleInstance(){
				return src.createTupleInstance();
			}
        };
d581 1
a581 1

d595 1
a595 1
    public synchronized VisualTable<? extends VisualItem<?>,TableDecoratorItem> addDecorators(String group,String source) {
d598 1
a598 1

d613 1
a613 1
    public synchronized VisualTable<? extends VisualItem<?>,TableDecoratorItem> addDecorators(
d618 1
a618 1

d623 1
a623 1
     * realized as {@@link prefuse.visual.DecoratorItem} instances that provide
d632 1
a632 1
    public synchronized VisualTable<? extends VisualItem<?>,TableDecoratorItem> addDecorators(
d635 3
a637 1
    	return addDecorators(group, source, filter, VisualItem.SCHEMA);
d639 1
a639 1

d656 1
a656 1
    public synchronized VisualTable<? extends VisualItem<?>,TableDecoratorItem> addDecorators(
d659 3
a661 4
        final VisualTable<? extends Tuple<?>,? extends VisualItem<?>> src = (VisualTable<? extends Tuple<?>,? extends VisualItem<?>>) getGroup(source);

        return addDecorators(src, group, source, filter, schema);

d663 1
a663 22

    private synchronized <T extends VisualItem<?>> VisualTable<T,TableDecoratorItem> addDecorators(
    		VisualTable<?,T> src, String group, String source, Predicate filter, Schema schema) {
        final VisualTable<T,TableDecoratorItem> vt = new VisualTable<T,TableDecoratorItem>(src, this, group, filter, schema){

			@@Override public TableDecoratorItem createTupleInstance(){
				return new TableDecoratorItem();
			}
        };
        addDataGroup(group, vt, getSourceData(source));

        vt.setTupleManager(new TupleManager<TableDecoratorItem>(vt, null) {

			@@Override
			public TableDecoratorItem createTupleInstance() {
				return vt.createTupleInstance();
			}});

        return vt;

    }

d665 1
a665 1

d678 1
a678 1
        TupleSet<? extends VisualItem<?>> ts = getFocusGroup(group);
d681 5
a685 3
        	for(VisualItem<?> item : ts.tuples(ValidatedPredicate.TRUE)) {
        		item.setValidated(false);
        	}
d690 1
a690 1

d698 1
a698 1
        TupleSet<? extends VisualItem<?>>[] focus = (TupleSet<? extends VisualItem<?>>[]) Array.newInstance(TupleSet.class, m_focus.size());
d700 2
a701 1
        for(VisualItem<?> item : ts.tuples()) {
d709 4
a712 3
            CompositeTupleSet<? extends VisualItem<?>> cts = (CompositeTupleSet<? extends VisualItem<?>>)ts;
            for ( String name : cts.setNames()) {
                String subgroup = PrefuseLib.getGroupName(group,name);
d721 1
a721 1

d725 1
a725 1
     * visualization. All registered focus groups added using the
d731 1
a731 1
        Iterator<Map.Entry<String, TupleSet<? extends VisualItem<?>>>> iter = m_focus.entrySet().iterator();
d733 2
a734 2
        	Map.Entry<String, TupleSet<? extends VisualItem<?>>> entry = iter.next();
            TupleSet<? extends VisualItem<?>> ts = entry.getValue();
d741 1
a741 1

d744 1
a744 1

d750 2
a751 2
    public TupleSet<? extends Tuple<?>> getSourceData(String group) {
        return m_source.get(group);
d753 1
a753 1

d759 2
a760 2
    public TupleSet<? extends Tuple<?>> getSourceData(VisualTupleSet<?> ts) {
        return m_source.get(ts.getGroup());
d762 1
a762 1

d766 1
a766 1
     * @@param item the VisualItem for which to retrieve the source tuple
d770 1
a770 1
    public Tuple<?> getSourceTuple(VisualItem<?> item) {
d773 3
a775 5
        TupleSet<? extends Tuple<?>> source = getSourceData(group);
        if ( source == null ) {
			return null;
		}

d778 1
a778 1
        Table<? extends Tuple<?>> t = item.getTable();
d780 1
a780 1
            VisualTable<?,?> vt = (VisualTable<?,?>) t;
d784 1
a784 1

d790 1
a790 1
            Graph<?,?,?> g = (Graph<?,?,?>)getSourceData(pgroup);
d800 1
a800 1

d809 3
a811 3
    public VisualItem<?> getVisualItem(String group, Tuple<?> t) {
        VisualTupleSet<?> ts = getVisualGroup(group);
        VisualTable<?,?> vt;
d813 1
a813 1
            vt = (VisualTable<?,?>)ts;
d815 2
a816 2
            Graph<?,?,?> g = (Graph<?,?,?>)ts;
            vt = (VisualTable<?,?>)(t instanceof Node ? g.getNodeTable()
d825 1
a825 1

d827 1
a827 1

d829 1
a829 1
     * Get the TupleSet associated with the given data group name.
d833 4
a836 5
    public <T extends VisualItem<?>> TupleSet<? extends VisualItem<?>> getGroup(String group) {
        TupleSet<T> ts = (TupleSet<T>) getVisualGroup(group);
        if ( ts == null ) {
			ts = getFocusGroup(group);
		}
d839 1
a839 1

d847 8
a854 10
    public boolean isInGroup(VisualItem<?> item, String group) {
        if ( ALL_ITEMS.equals(group) ) {
			return true;
		}
        if ( item.getGroup() == group ) {
			return true;
		}

        TupleSet<? extends VisualItem<?>> tset = getGroup(group);
        return tset==null ? false : tset.containsTuple(item);
d856 1
a856 1

d865 1
a865 1
        m_focus.put(group, new DefaultTupleSet<VisualItem<?>>());
d873 1
a873 1
    public void addFocusGroup(String group, TupleSet<? extends VisualItem<?>> tset) {
d877 1
a877 1

d880 1
a880 1

d887 2
a888 2
        TupleSet<? extends VisualItem<?>> tset = getGroup(group);
        return tset==null ? 0 : tset.getTupleCount();
d890 1
a890 1

d897 2
a898 2
    public <T extends VisualItem<?>> VisualTupleSet<? extends VisualItem<?>> getVisualGroup(String group) {
        return m_visual.get(group);
d900 1
a900 1

d907 2
a908 2
    public <T extends VisualItem<?>> TupleSet<T> getFocusGroup(String group) {
        return (TupleSet<T>) m_focus.get(group);
d910 1
a910 1

d918 3
a920 1
    	for(VisualItem<?> item : items(group, ValidatedPredicate.TRUE)) {
d924 1
a924 1

d933 1
a933 1

d938 1
a938 1
    public Iterable<? extends VisualItem<?>> visibleItems() {
d941 1
a941 1

d947 1
a947 1
    public Iterable<? extends VisualItem<?>> visibleItems(String group) {
d950 1
a950 1

d955 1
a955 1
    public Iterable<? extends VisualItem<?>> items() {
d958 1
a958 1

d966 1
a966 1
    public Iterable<? extends VisualItem<?>> items(Predicate filter) {
d969 1
a969 1
        	return Collections.emptyList();
d971 2
a972 2
            Iterator<String> it = m_visual.keySet().iterator();
            return items(it.next(), filter);
d974 2
a975 2
            CompositeIterable<VisualItem<?>> iter = new CompositeIterable<VisualItem<?>>(m_visual.size());
            Iterator<String> it = m_visual.keySet().iterator();
d977 3
a979 4
                String group = it.next();
                if ( !PrefuseLib.isChildGroup(group) ) {
					iter.setIterator(i++, items(group, filter));
				}
d984 1
a984 1

d990 1
a990 1
    public Iterable<? extends VisualItem<?>> items(String group) {
d993 1
a993 1

d1005 1
a1005 1
    public Iterable<? extends Tuple<?>> items(String group, String expr) {
d1007 2
a1008 3
        if ( !(e instanceof Predicate) || ExpressionParser.getError()!=null ) {
			return Collections.<VisualItem<?>>emptyList();
		}
d1011 1
a1011 1

d1020 7
a1026 8
    public Iterable<? extends VisualItem<?>> items(String group, Predicate filter) {
        if ( ALL_ITEMS.equals(group) ) {
			return items(filter);
		}

        TupleSet<? extends VisualItem<?>> t = getGroup(group);
        return t==null ? Collections.<VisualItem<?>>emptyList()
                         : t.tuples(filter);
d1028 1
a1028 1

d1031 1
a1031 1

d1041 3
a1043 1
    	for(VisualItem<?> item : items(group, p)) {
d1047 1
a1047 1

d1056 3
a1058 1
    	for(VisualItem<?> item : items(group, p)) {
d1071 3
a1073 1
    	for(VisualItem<?> item : items(group, p)) {
d1075 1
a1075 1
    	}
d1077 1
a1077 1

d1080 1
a1080 1

d1092 1
a1092 1

d1101 1
a1101 1

d1107 1
a1107 1
     * <strong>NOTE:</strong> Errors may occur if the removed Action is
d1110 1
a1110 1
     * currently the responsibility of clients to avoid this situation.
d1125 1
a1125 1

d1151 1
a1151 1

d1165 1
a1165 1

d1180 1
a1180 1

d1193 1
a1193 1

d1202 1
a1202 1

d1205 1
a1205 1

d1216 1
a1216 1

d1224 1
a1224 1

d1232 1
a1232 1
    public Renderer getRenderer(VisualItem<?> item) {
d1239 1
a1239 1

d1245 3
a1247 2
    	for(VisualItem<?> item : items(ValidatedPredicate.FALSE)) {
            item.validateBounds();
d1253 1
a1253 1

d1262 1
a1262 1

d1271 9
a1279 9
    	boolean first = true;
    	for(VisualItem<?> item : visibleItems(group)) {
    		if(first) {
                r.setRect(item.getBounds());
    			first = false;
    		} else {
                Rectangle2D.union(item.getBounds(), r, r);
    		}
    	}
d1282 1
a1282 1

d1285 1
a1285 1

d1293 1
a1293 1

d1302 1
a1302 1

d1310 1
a1310 1
        return m_displays.get(idx);
d1312 1
a1312 1

d1321 1
a1321 1

d1328 1
a1328 1
    public void damageReport(VisualItem<?> item, Rectangle2D region) {
d1336 1
a1336 1

@


2.10.4.2
log
@allowed all actions to be removed from the Visualization easily
@
text
@a1232 14
     * Remove all data processing Actions registered with this visualization.
     * If the removed action is currently running, it will be cancelled.
     * The visualization reference held by the removed Actions will be set to
     * null.
     * <p>
     * TODO: this will not handle "always run after" relations appropriately.
     */
    public void removeAllActions() {
    	for(String key : m_actions.allKeys()) {
    		removeAction(key);
    	}
    }

    /**
@


2.10.4.3
log
@Added some comments
@
text
@d623 1
a623 1
     * @@param schema the data schema to use for the AggregateTable, should usually extend PrefuseLib.getVisualItemSchema()
@


2.10.4.4
log
@Added abilty to remove aggregate tables
@
text
@d51 39
a89 35
 * <p>
 * Central data structure representing an interactive Visualization. This class is responsible for
 * managing the mappings between source data and onscreen VisualItems, maintaining a list of
 * {@@link Display} instances responsible for rendering of and interaction with the contents of this
 * visualization, and providing a collection of named Action instances for performing data
 * processing such as layout, animation, and size, shape, and color assignment.
 * </p>
 * 
 * <p>
 * The primary responsibility of the Visualization class is the creation of
 * <em>visual abstractions</em> of input data. Regardless of the data structure (i.e.,
 * {@@link prefuse.data.Table}, {@@link prefuse.data.Graph}, or {@@link prefuse.data.Tree}), this
 * class takes source data such as that loaded from a file (see {@@link prefuse.data.io}) or from a
 * relational database (see {@@link prefuse.data.io.sql}) and creates a visual representation of the
 * data. These visual representations of the data are data sets in their own right, providing access
 * to the underlying source data to be visualized while also adding addition data fields specific to
 * a visualization. These fields include spatial location (x, y coordinates and item bounds), color
 * (for stroke, fill, and text), size, shape, and font. For a given input data set of type
 * {@@link prefuse.data.Table}, {@@link prefuse.data.Graph}, or or {@@link prefuse.data.Tree}, a
 * corresponding instance of {@@link prefuse.visual.VisualTable}, {@@link prefuse.visual.VisualGraph},
 * or {@@link prefuse.visual.VisualTree} is created and stored in the visualization. These data types
 * inherit the data values of the source data (and indeed, manipulate it directly) while
 * additionally providing the aforementioned visual variables unique to that generated visual
 * abstraction. Similarly, all {@@link prefuse.data.Tuple}, {@@link prefuse.data.Node}, or
 * {@@link prefuse.data.Edge} instances used to represent an entry in the source data have a
 * corresponding {@@link prefuse.visual.VisualItem}, {@@link prefuse.visual.NodeItem}, or
 * {@@link prefuse.visual.EdgeItem} representing the interactive, visual realization of the backing
 * data.
 * </p>
 * 
 * <p>
 * The mapping of source data to a visual abstraction is accomplished using
 * {@@link #add(String, TupleSet)} and the other "add" methods. These methods will automatically
 * create the visual abstraction, and store it in this visualization, associating it with a provided
 * <em>data group name
d91 70
a160 63
 * consider only VisualItem instances from that particular group. This is quite useful when crafting
 * {@@link prefuse.action.Action} instances that process only a particular group of visual data. The
 * Visualization class provides mechanisms for querying any or all groups within the visualization,
 * using one or both of the group name or a filtering {@@link prefuse.data.expression.Predicate} to
 * determine the items to include (see {@@link #items(Predicate)} for an examples). Source data may
 * be added multiple times to a Visualization under different group names, allowing for multiple
 * representations of the same backing data.
 * </p>
 * 
 * <p>
 * Additionally, the Visualization class supports VisualItem instances that are not directly
 * grounded in backing source data. Examples include {@@link prefuse.visual.DecoratorItem} which
 * "decorates" another pre-existing VisualItem with a separate interactive visual object, and
 * {@@link prefuse.visual.AggregateItem} which provides an interactive visual representation of an
 * aggregated of other VisualItems. Methods for adding data groups of these kinds include
 * {@@link #addDecorators(String, String)} and {@@link #addAggregates(String)}.
 * </p>
 * 
 * <p>
 * All of the examples discussed above are examples of <em>primary, or
 * visual, data groups</em> of
 * VisualItems. Visualizations also support <em>secondary, or focus data groups</em> that maintain
 * additional collections of the VisualItems stored in the primary groups. Examples include a set of
 * focus items (such as those that have been clicked by the user), selected items (items selected by
 * a user), or search items (all matches to a search query). The exact semantics of these groups and
 * the mechanisms by which they are populated is determined by application creators, but some
 * defaults are provided. The Visualization class includes some default group names, namely
 * {@@link #FOCUS_ITEMS}, {@@link #SELECTED_ITEMS}, and {@@link #SEARCH_ITEMS} for the above
 * mentioned tasks. By default, both the {@@link #FOCUS_ITEMS}, {@@link #SELECTED_ITEMS} focus groups
 * are included in the Visualization, represented using {@@link prefuse.data.tuple.DefaultTupleSet}
 * instances. Also, some of the interactive controls provided by the {@@link prefuse.controls}
 * package populate these sets by default. See {@@link prefuse.controls.FocusControl} for an example.
 * </p>
 * 
 * <p>
 * Visualizations also maintain references to all the {@@link Display} instances providing
 * interactive views of the content of this visualization. {@@link Display} instances registers
 * themselves with the visualization either in their constructor or through the
 * {@@link Display#setVisualization(Visualization)} method, so they do not otherwise need to be added
 * manually. Displays can be configured to show all or only a subset of the data in the
 * Visualization. A filtering {@@link prefuse.data.expression.Predicate} can be used to control what
 * items are drawn by the displaying, including limiting the Display to particular data groups (for
 * example, using a {@@link prefuse.visual.expression.InGroupPredicate}). The Visualization's
 * {@@link #repaint()} method will trigger a repaint on all Displays associated with the
 * visualization.
 * </p>
 * 
 * <p>
 * Finally, the Visualization class provides a map of named {@@link prefuse.action.Action} instances
 * that can be invoked to perform processing on the VisualItems contained in the visualization.
 * Using the {@@link #putAction(String, Action)} will add a named Action to the visualization,
 * registering the Action such that a reference to this Visualization will be available within the
 * scope of the Action's {@@link prefuse.action.Action#run(double)} method. Processing Actions can
 * later be invoked by name using the {@@link #run(String)} method and other similar methods. This
 * functionality not only provides a convenient means of organizing a Visualization-specific
 * collection of processing Actions, it also allows for a layer of indirection between an Action and
 * its name. This allows Actions to be dynamically swapped at runtime. For example, an application
 * may make a call to invoke an Action named "layout", but the actual layout processing maybe be
 * dynamically swapped by changing the Action that corresponds to that name. For more information on
 * processing Actions, see the {@@link prefuse.action} packages and the top-level
 * {@@link prefuse.action.Action} class.
 * </p>
 * 
d165 101
a265 90
	/** Data group name for indicating all groups */
	public static final String ALL_ITEMS = PrefuseConfig.get("visualization.allItems");
	/** Default data group name for focus items */
	public static final String FOCUS_ITEMS = PrefuseConfig.get("visualization.focusItems");
	/** Default data group name for selected items */
	public static final String SELECTED_ITEMS = PrefuseConfig.get("visualization.selectedItems");
	/** Default data group name for search result items */
	public static final String SEARCH_ITEMS = PrefuseConfig.get("visualization.searchItems");

	// visual abstraction
	// filtered tables and groups
	private final Map<String, VisualTupleSet<? extends VisualItem<?>>> m_visual;
	private final Map<String, TupleSet<? extends Tuple<?>>> m_source;
	private final Map<String, TupleSet<? extends VisualItem<?>>> m_focus;

	// actions
	private final ActivityMap m_actions;

	// renderers
	private RendererFactory m_renderers;

	// displays
	private final List<Display> m_displays;

	// ------------------------------------------------------------------------
	// Constructor

	/**
	 * Create a new, empty Visualization. Uses a DefaultRendererFactory.
	 */
	public Visualization() {
		m_actions = new ActivityMap();
		m_renderers = new DefaultRendererFactory();
		m_visual = new LinkedHashMap<String, VisualTupleSet<? extends VisualItem<?>>>();
		m_source = new HashMap<String, TupleSet<? extends Tuple<?>>>();
		m_focus = new HashMap<String, TupleSet<? extends VisualItem<?>>>();
		m_displays = new ArrayList<Display>();

		addFocusGroup(Visualization.FOCUS_ITEMS, new DefaultTupleSet<VisualItem<?>>());
		addFocusGroup(Visualization.SELECTED_ITEMS, new DefaultTupleSet<VisualItem<?>>());
	}

	// ------------------------------------------------------------------------
	// Data Methods

	/**
	 * Add a data set to this visualization, using the given data group name. A visual abstraction
	 * of the data will be created and registered with the visualization. An exception will be
	 * thrown if the group name is already in use.
	 * 
	 * @@param group
	 *            the data group name for the visualized data
	 * @@param data
	 *            the data to visualize
	 * @@return a visual abstraction of the input data, a VisualTupleSet instance
	 */
	public synchronized VisualTupleSet<? extends VisualItem<?>> add(final String group, final TupleSet<?> data) {
		return add(group, data, null);
	}

	/**
	 * Add a data set to this visualization, using the given data group name. A visual abstraction
	 * of the data will be created and registered with the visualization. An exception will be
	 * thrown if the group name is already in use.
	 * 
	 * @@param group
	 *            the data group name for the visualized data
	 * @@param data
	 *            the data to visualize
	 * @@param filter
	 *            a filter Predicate determining which data Tuples in the input data set are
	 *            visualized
	 * @@return a visual abstraction of the input data, a VisualTupleSet instance
	 */
	public synchronized VisualTupleSet<? extends VisualItem<?>> add(final String group, final TupleSet<?> data,
			final Predicate filter) {
		if (data instanceof Table) {
			return addTable(group, (Table<?>) data, filter);
		} else if (data instanceof Tree) {
			return addTree(group, (Tree<?, ?, ?>) data, filter);
		} else if (data instanceof Graph) {
			return addGraph(group, (Graph<?, ?, ?>) data, filter);
		} else {
			throw new IllegalArgumentException("Unsupported TupleSet type.");
		}
	}

	protected void checkGroupExists(final String group) {
		if (m_visual.containsKey(group) || m_focus.containsKey(group)) {
			throw new IllegalArgumentException("Group name \'" + group + "\' already in use");
d267 1
a267 1
	}
d269 1
a269 7
	protected void addDataGroup(final String group, final VisualTupleSet<? extends VisualItem<?>> ts, final TupleSet<?> src) {
		checkGroupExists(group);
		m_visual.put(group, ts);
		if (src != null) {
			m_source.put(group, src);
		}
	}
d271 110
a380 129
	protected void removeDataGroup(final String group) {
		m_visual.remove(group);
		m_source.remove(group);
	}

	// -- Tables --------------------------------------------------------------

	/**
	 * Add an empty VisualTable to this visualization, using the given data group name. This adds a
	 * group of VisualItems that do not have a backing data set, useful for creating interactive
	 * visual objects that do not represent data. An exception will be thrown if the group name is
	 * already in use.
	 * 
	 * @@param group
	 *            the data group name for the visualized data
	 * @@return the added VisualTable
	 */
	public synchronized VisualTable<TableVisualItem<?>, TableVisualItem<?>> addTable(final String group) {
		final VisualTable<TableVisualItem<?>, TableVisualItem<?>> vt = VisualTable.createVisualTable(this, group);
		addDataGroup(group, vt, null);
		return vt;
	}

	/**
	 * Add an empty VisualTable to this visualization, using the given data group name and table
	 * schema. This adds a group of VisualItems that do not have a backing data set, useful for
	 * creating interactive visual objects that do not represent data. An exception will be thrown
	 * if the group name is already in use.
	 * 
	 * @@param group
	 *            the data group name for the visualized data
	 * @@param schema
	 *            the data schema to use for the VisualTable
	 * @@return the added VisualTable
	 */
	public synchronized VisualTable<TableVisualItem<?>, TableVisualItem<?>> addTable(final String group, final Schema schema) {
		final VisualTable<TableVisualItem<?>, TableVisualItem<?>> vt = VisualTable.createVisualTable(this, group, schema);
		addDataGroup(group, vt, null);
		return vt;
	}

	/**
	 * Adds a data table to this visualization, using the given data group name. A visual
	 * abstraction of the data will be created and registered with the visualization. An exception
	 * will be thrown if the group name is already in use.
	 * 
	 * @@param group
	 *            the data group name for the visualized data
	 * @@param table
	 *            the data table to visualize
	 */
	public synchronized <T extends Tuple<?>> VisualTable<T, TableVisualItem<?>> addTable(final String group, final Table<T> table) {
		return addTable(group, table, (Predicate) null);
	}

	/**
	 * Adds a data table to this visualization, using the given data group name. A visual
	 * abstraction of the data will be created and registered with the visualization. An exception
	 * will be thrown if the group name is already in use.
	 * 
	 * @@param group
	 *            the data group name for the visualized data
	 * @@param table
	 *            the data table to visualize
	 * @@param filter
	 *            a filter Predicate determining which data Tuples in the input table are visualized
	 */
	public synchronized <T extends Tuple<?>> VisualTable<T, TableVisualItem<?>> addTable(final String group,
			final Table<T> table, final Predicate filter) {
		final VisualTable<T, TableVisualItem<?>> vt = VisualTable.createVisualTable(table, this, group, filter);
		addDataGroup(group, vt, table);
		return vt;
	}

	/**
	 * Adds a data table to this visualization, using the given data group name. A visual
	 * abstraction of the data will be created and registered with the visualization. An exception
	 * will be thrown if the group name is already in use.
	 * 
	 * @@param group
	 *            the data group name for the visualized data
	 * @@param table
	 *            the data table to visualize
	 * @@param schema
	 *            the data schema to use for the created VisualTable
	 */
	public synchronized <T extends Tuple<?>> VisualTable<T, TableVisualItem<?>> addTable(final String group,
			final Table<T> table, final Schema schema) {
		return addTable(group, table, null, schema);
	}

	/**
	 * Adds a data table to this visualization, using the given data group name. A visual
	 * abstraction of the data will be created and registered with the visualization. An exception
	 * will be thrown if the group name is already in use.
	 * 
	 * @@param group
	 *            the data group name for the visualized data
	 * @@param table
	 *            the data table to visualize
	 * @@param filter
	 *            a filter Predicate determining which data Tuples in the input table are visualized
	 * @@param schema
	 *            the data schema to use for the created VisualTable
	 */
	public synchronized <T extends Tuple<?>> VisualTable<T, TableVisualItem<?>> addTable(final String group,
			final Table<T> table, final Predicate filter, final Schema schema) {
		final VisualTable<T, TableVisualItem<?>> vt = VisualTable.createVisualTable(table, this, group, filter, schema);
		addDataGroup(group, vt, table);
		return vt;
	}

	/**
	 * Adds a data table to this visualization, using the given data group name. A visual
	 * abstraction of the data will be created and registered with the visualization. An exception
	 * will be thrown if the group name is already in use.
	 * 
	 * @@param group
	 *            the data group name for the visualized data
	 * @@param table
	 *            the data table to visualize
	 * @@param filter
	 *            a filter Predicate determining which data Tuples in the input table are visualized
	 * @@param schema
	 *            the data schema to use for the created VisualTable
	 */
	public synchronized <T extends Node<?, ?>> VisualTable<T, TableNodeItem> addNodeTable(final String group,
			final Table<T> table, final Predicate filter, final Schema schema) {
		final VisualTable<T, TableNodeItem> vt = new VisualTable<T, TableNodeItem>(table, this, group, filter, schema) {
d384 20
a403 23
			}
		};
		addDataGroup(group, vt, table);
		return vt;
	}

	/**
	 * Adds a data table to this visualization, using the given data group name. A visual
	 * abstraction of the data will be created and registered with the visualization. An exception
	 * will be thrown if the group name is already in use.
	 * 
	 * @@param group
	 *            the data group name for the visualized data
	 * @@param table
	 *            the data table to visualize
	 * @@param filter
	 *            a filter Predicate determining which data Tuples in the input table are visualized
	 * @@param schema
	 *            the data schema to use for the created VisualTable
	 */
	public synchronized <T extends Edge<?, ?>> VisualTable<T, TableEdgeItem> addEdgeTable(final String group,
			final Table<T> table, final Predicate filter, final Schema schema) {
		final VisualTable<T, TableEdgeItem> vt = new VisualTable<T, TableEdgeItem>(table, this, group, filter, schema) {
d407 93
a499 96
			}
		};
		addDataGroup(group, vt, table);
		return vt;
	}

	/**
	 * Add a VisualTable to this visualization, using the table's pre-set group name. An exception
	 * will be thrown if the group name is already in use. This method allows you to insert custom
	 * implementations of VisualTable into a Visualization. It is intended for advanced users and
	 * should <b>NOT</b> be used if you do not know what you are doing. In almost all cases, one of
	 * the other add methods is preferred.
	 * 
	 * @@param table
	 *            the pre-built VisualTable to add
	 * @@return the added VisualTable
	 */
	public synchronized <S extends Tuple<?>, T extends VisualItem<?>> VisualTable<S, T> addTable(final VisualTable<S, T> table) {
		addDataGroup(table.getGroup(), table, table.getParentTable());
		table.setVisualization(this);
		return table;
	}

	// -- Graphs and Trees ----------------------------------------------------

	/**
	 * Adds a graph to this visualization, using the given data group name. A visual abstraction of
	 * the data will be created and registered with the visualization. An exception will be thrown
	 * if the group name is already in use.
	 * 
	 * @@param group
	 *            the data group name for the visualized graph. The nodes and edges will be
	 *            available in the "group.nodes" and "group.edges" subgroups.
	 * @@param graph
	 *            the graph to visualize
	 */
	public synchronized VisualGraph<TableVisualItem<?>, TableNodeItem, TableEdgeItem> addGraph(final String group,
			final Graph<?, ?, ?> graph) {
		return addGraph(group, graph, null);
	}

	/**
	 * Adds a graph to this visualization, using the given data group name. A visual abstraction of
	 * the data will be created and registered with the visualization. An exception will be thrown
	 * if the group name is already in use.
	 * 
	 * @@param group
	 *            the data group name for the visualized graph. The nodes and edges will be
	 *            available in the "group.nodes" and "group.edges" subgroups.
	 * @@param graph
	 *            the graph to visualize
	 * @@param filter
	 *            a filter Predicate determining which data Tuples in the input graph are visualized
	 */
	public synchronized VisualGraph<TableVisualItem<?>, TableNodeItem, TableEdgeItem> addGraph(final String group,
			final Graph<?, ?, ?> graph, final Predicate filter) {
		return addGraph(group, graph, filter, VisualItem.SCHEMA, VisualItem.SCHEMA);
	}

	/**
	 * Adds a graph to this visualization, using the given data group name. A visual abstraction of
	 * the data will be created and registered with the visualization. An exception will be thrown
	 * if the group name is already in use.
	 * 
	 * @@param group
	 *            the data group name for the visualized graph. The nodes and edges will be
	 *            available in the "group.nodes" and "group.edges" subgroups.
	 * @@param graph
	 *            the graph to visualize
	 * @@param filter
	 *            a filter Predicate determining which data Tuples in the input graph are visualized
	 * @@param nodeSchema
	 *            the data schema to use for the visual node table
	 * @@param edgeSchema
	 *            the data schema to use for the visual edge table
	 */
	public synchronized <N extends Node<N, E>, E extends Edge<N, E>> VisualGraph<TableVisualItem<?>, TableNodeItem, TableEdgeItem> addGraph(
			final String group, final Graph<?, N, E> graph, final Predicate filter, final Schema nodeSchema,
			final Schema edgeSchema) {
		checkGroupExists(group); // check before adding sub-tables
		final String ngroup = PrefuseLib.getGroupName(group, Graph.NODES);
		final String egroup = PrefuseLib.getGroupName(group, Graph.EDGES);

		final VisualTable<N, TableNodeItem> nt = addNodeTable(ngroup, graph.getNodeTable(), filter, nodeSchema);
		final VisualTable<E, TableEdgeItem> et = addEdgeTable(egroup, graph.getEdgeTable(), filter, edgeSchema);

		/*
		 * public VisualGraph(VisualTable<? extends VisualItem<?>, N> nodes, VisualTable<?
		 * extends Tuple<?>, E> edges, boolean directed, String nodeKey, String sourceKey, String
		 * targetKey) { super(nodes, edges, directed, nodeKey, sourceKey, targetKey); }
		 * 
		 */

		final VisualGraph<TableVisualItem<?>, TableNodeItem, TableEdgeItem> vg = new VisualGraph<TableVisualItem<?>, TableNodeItem, TableEdgeItem>(nt, et, graph.isDirected(), graph.getNodeKeyField(), graph.getEdgeSourceField(), graph.getEdgeTargetField());
		vg.setVisualization(this);
		vg.setGroup(group);
d501 1
a501 1
		addDataGroup(group, vg, graph);
d503 1
a503 1
		final TupleManager<TableNodeItem> ntm = new TupleManager<TableNodeItem>(nt, vg) {
d508 2
a509 2
		};
		final TupleManager<TableEdgeItem> etm = new TupleManager<TableEdgeItem>(et, vg) {
d515 68
a582 71
		};
		nt.setTupleManager(ntm);
		et.setTupleManager(etm);
		vg.setTupleManagers(ntm, etm);

		return vg;
	}

	/**
	 * Adds a tree to this visualization, using the given data group name. A visual abstraction of
	 * the data will be created and registered with the visualization. An exception will be thrown
	 * if the group name is already in use.
	 * 
	 * @@param group
	 *            the data group name for the visualized tree. The nodes and edges will be available
	 *            in the "group.nodes" and "group.edges" subgroups.
	 * @@param tree
	 *            the tree to visualize
	 */
	public synchronized VisualTree<VisualItem<?>, TableNodeItem, TableEdgeItem> addTree(final String group,
			final Tree<?, ?, ?> tree) {
		return addTree(group, tree, null);
	}

	/**
	 * Adds a tree to this visualization, using the given data group name. A visual abstraction of
	 * the data will be created and registered with the visualization. An exception will be thrown
	 * if the group name is already in use.
	 * 
	 * @@param group
	 *            the data group name for the visualized tree. The nodes and edges will be available
	 *            in the "group.nodes" and "group.edges" subgroups.
	 * @@param tree
	 *            the tree to visualize
	 * @@param filter
	 *            a filter Predicate determining which data Tuples in the input graph are visualized
	 */
	public synchronized VisualTree<VisualItem<?>, TableNodeItem, TableEdgeItem> addTree(final String group,
			final Tree<?, ?, ?> tree, final Predicate filter) {
		return addTree(group, tree, filter, VisualItem.SCHEMA, VisualItem.SCHEMA);
	}

	/**
	 * Adds a tree to this visualization, using the given data group name. A visual abstraction of
	 * the data will be created and registered with the visualization. An exception will be thrown
	 * if the group name is already in use.
	 * 
	 * @@param group
	 *            the data group name for the visualized tree. The nodes and edges will be available
	 *            in the "group.nodes" and "group.edges" subgroups.
	 * @@param tree
	 *            the tree to visualize
	 * @@param filter
	 *            a filter Predicate determining which data Tuples in the input graph are visualized
	 * @@param nodeSchema
	 *            the data schema to use for the visual node table
	 * @@param edgeSchema
	 *            the data schema to use for the visual edge table
	 */
	public synchronized <N extends Node<N, E>, E extends Edge<N, E>> VisualTree<VisualItem<?>, TableNodeItem, TableEdgeItem> addTree(
			final String group, final Tree<?, N, E> tree, final Predicate filter, final Schema nodeSchema, final Schema edgeSchema) {
		checkGroupExists(group); // check before adding sub-tables
		final String ngroup = PrefuseLib.getGroupName(group, Graph.NODES);
		final String egroup = PrefuseLib.getGroupName(group, Graph.EDGES);

		final VisualTable<N, TableNodeItem> nt = addNodeTable(ngroup, tree.getNodeTable(), filter, nodeSchema);
		final VisualTable<E, TableEdgeItem> et = addEdgeTable(egroup, tree.getEdgeTable(), filter, edgeSchema);

		final VisualTree<VisualItem<?>, TableNodeItem, TableEdgeItem> vt = new VisualTree<VisualItem<?>, TableNodeItem, TableEdgeItem>(nt, et, tree.getNodeKeyField(), tree.getEdgeSourceField(), tree.getEdgeTargetField());
		vt.setVisualization(this);
		vt.setGroup(group);
d584 1
a584 1
		addDataGroup(group, vt, tree);
d586 1
a586 1
		final TupleManager<TableNodeItem> ntm = new TupleManager<TableNodeItem>(nt, vt) {
d592 2
a593 2
		};
		final TupleManager<TableEdgeItem> etm = new TupleManager<TableEdgeItem>(et, vt) {
d598 65
a662 75
		};
		nt.setTupleManager(ntm);
		et.setTupleManager(etm);
		vt.setTupleManagers(ntm, etm);

		return vt;
	}

	// -- Aggregates ----------------------------------------------------------

	/**
	 * Add a group of aggregates to this visualization. Aggregates are used to visually represent
	 * groups of VisualItems.
	 * 
	 * @@param group
	 *            the data group name for the aggregates.
	 * @@return the generated AggregateTable
	 * @@see prefuse.visual.AggregateTable
	 */
	public synchronized <V extends VisualItem<?>> AggregateTable<TableAggregateItem<V>, V> addAggregates(final String group) {
		return addAggregates(group, VisualItem.SCHEMA);
	}

	/**
	 * Add a group of aggregates to this visualization. Aggregates are used to visually represent
	 * groups of VisualItems.
	 * 
	 * @@param group
	 *            the data group name for the aggregates.
	 * @@param schema
	 *            the data schema to use for the AggregateTable, should usually extend
	 *            PrefuseLib.getVisualItemSchema()
	 * @@return the generated AggregateTable
	 * @@see prefuse.visual.AggregateTable
	 */
	public synchronized <V extends VisualItem<?>> AggregateTable<TableAggregateItem<V>, V> addAggregates(final String group,
			final Schema schema) {
		final AggregateTable<TableAggregateItem<V>, V> vat = AggregateTable.createAggregateTable(this, group, schema);
		addDataGroup(group, vat, null);
		return vat;
	}

	public synchronized void removeAggregateTable(final String group) {
		removeDataGroup(group);
	}

	// -- Derived Tables and Decorators ---------------------------------------

	/**
	 * Add a derived table, a VisualTable that is cascaded from an existing VisualTable. This is
	 * useful for creating VisualItems that inherit a set of visual properties from another group of
	 * VisualItems. This might be used, for example, in the creation of small multiples where only a
	 * few visual attributes vary across the multiples.
	 * 
	 * @@param group
	 *            the data group to use for the derived table
	 * @@param source
	 *            the source data group to derive from
	 * @@param filter
	 *            a Predicate filter indicating which tuples of the source group should be
	 *            inheritable by the new group
	 * @@param override
	 *            a data schema indicating which data fields should not be inherited, but managed
	 *            locally by the derived group
	 * @@return the derived VisualTable
	 */
	public synchronized VisualTable<? extends VisualItem<?>, ? extends VisualItem<?>> addDerivedTable(final String group,
			final String source, final Predicate filter, final Schema override) {
		final VisualTable<?, ? extends VisualItem<?>> src = (VisualTable<?, ? extends VisualItem<?>>) getGroup(source);
		return addDerivedTable(src, group, source, filter, override);
	}

	private synchronized <V extends VisualItem<?>> VisualTable<V, V> addDerivedTable(final VisualTable<?, V> src,
			final String group, final String source, final Predicate filter, final Schema override) {
		final VisualTable<V, V> vt = new VisualTable<V, V>(src, this, group, filter, override) {
d664 1
a664 2
			@@Override
			public V createTupleInstance() {
d667 89
a755 94
		};
		addDataGroup(group, vt, getSourceData(source));
		return vt;
	}

	/**
	 * Add a group of decorators to an existing visual data group. Decorators are VisualItem
	 * instances intended to "decorate" another VisualItem, such as providing a label or dedicated
	 * interactive control, and are realizeed as {@@link prefuse.visual.DecoratorItem} instances that
	 * provide access to the decorated item in addition to the standard VisualItem properties. The
	 * generated table is created using the
	 * {@@link #addDerivedTable(String, String, Predicate, Schema)} method, but with no VisualItem
	 * properties inherited from the source group.
	 * 
	 * @@param group
	 *            the data group to use for the decorators
	 * @@param source
	 *            the source data group to decorate
	 * @@return the generated VisualTable of DecoratorItem instances
	 */
	public synchronized VisualTable<? extends VisualItem<?>, TableDecoratorItem> addDecorators(final String group,
			final String source) {
		return addDecorators(group, source, (Predicate) null);
	}

	/**
	 * Add a group of decorators to an existing visual data group. Decorators are VisualItem
	 * instances intended to "decorate" another VisualItem, such as providing a label or dedicated
	 * interactive control, and are realizeed as {@@link prefuse.visual.DecoratorItem} instances that
	 * provide access to the decorated item in addition to the standard VisualItem properties.
	 * 
	 * @@param group
	 *            the data group to use for the decorators
	 * @@param source
	 *            the source data group to decorate
	 * @@param schema
	 *            schema indicating which variables should <b>not</b> be inherited from the source
	 *            data group and instead be managed locally by the generated VisualTable
	 * @@return the generated VisualTable of DecoratorItem instances
	 */
	public synchronized VisualTable<? extends VisualItem<?>, TableDecoratorItem> addDecorators(final String group,
			final String source, final Schema schema) {
		return addDecorators(group, source, null, schema);
	}

	/**
	 * Add a group of decorators to an existing visual data group. Decorators are VisualItem
	 * instances intended to "decorate" another VisualItem, such as providing a label or dedicated
	 * interactive control, and are realized as {@@link prefuse.visual.DecoratorItem} instances that
	 * provide access to the decorated item in addition to the standard VisualItem properties.
	 * 
	 * @@param group
	 *            the data group to use for the decorators
	 * @@param source
	 *            the source data group to decorate
	 * @@param filter
	 *            a Predicate filter indicating which tuples of the source group should be
	 *            inheritable by the new group
	 * @@return the generated VisualTable of DecoratorItem instances
	 */
	public synchronized VisualTable<? extends VisualItem<?>, TableDecoratorItem> addDecorators(final String group,
			final String source, final Predicate filter) {
		return addDecorators(group, source, filter, VisualItem.SCHEMA);
	}

	/**
	 * Add a group of decorators to an existing visual data group. Decorators are VisualItem
	 * instances intended to "decorate" another VisualItem, such as providing a label or dedicated
	 * interactive control, and are realizeed as {@@link prefuse.visual.DecoratorItem} instances that
	 * provide access to the decorated item in addition to the standard VisualItem properties.
	 * 
	 * @@param group
	 *            the data group to use for the decorators
	 * @@param source
	 *            the source data group to decorate
	 * @@param filter
	 *            a Predicate filter indicating which tuples of the source group should be
	 *            inheritable by the new group
	 * @@param schema
	 *            schema indicating which variables should <b>not</b> be inherited from the source
	 *            data group and instead be managed locally by the generated VisualTable
	 * @@return the generated VisualTable of DecoratorItem instances
	 */
	public synchronized VisualTable<? extends VisualItem<?>, TableDecoratorItem> addDecorators(final String group,
			final String source, final Predicate filter, final Schema schema) {
		final VisualTable<? extends Tuple<?>, ? extends VisualItem<?>> src = (VisualTable<? extends Tuple<?>, ? extends VisualItem<?>>) getGroup(source);

		return addDecorators(src, group, source, filter, schema);

	}

	private synchronized <T extends VisualItem<?>> VisualTable<T, TableDecoratorItem> addDecorators(final VisualTable<?, T> src,
			final String group, final String source, final Predicate filter, final Schema schema) {
		final VisualTable<T, TableDecoratorItem> vt = new VisualTable<T, TableDecoratorItem>(src, this, group, filter, schema) {
d757 1
a757 2
			@@Override
			public TableDecoratorItem createTupleInstance() {
d760 2
a761 2
		};
		addDataGroup(group, vt, getSourceData(source));
d763 1
a763 1
		vt.setTupleManager(new TupleManager<TableDecoratorItem>(vt, null) {
d768 1
a768 4
			}
		});

		return vt;
d770 1
a770 1
	}
d772 1
a772 1
	// -- Data Removal --------------------------------------------------------
d774 1
a774 23
	/**
	 * Removes a data group from this Visualization. If the group is a focus group, the group will
	 * simply be removed, and any subsequent attempts to retrieve the group will return null. If the
	 * group is a primary group, it will be removed, and any members of the group will also be
	 * removed from any registered focus groups.
	 * 
	 * @@param group
	 *            the data group to remove
	 * @@return true if the group was found and removed, false if the group was not found in this
	 *         visualization.
	 */
	public synchronized boolean removeGroup(final String group) {
		// check for focus group first
		TupleSet<? extends VisualItem<?>> ts = getFocusGroup(group);
		if (ts != null) {
			// invalidate the item to reflect group membership change
			for (final VisualItem<?> item : ts.tuples(ValidatedPredicate.TRUE)) {
				item.setValidated(false);
			}
			ts.clear(); // trigger group removal callback
			m_focus.remove(group);
			return true;
		}
d776 105
a880 82
		// focus group not found, check for primary group
		ts = getVisualGroup(group);
		if (ts == null) {
			// exit with false if group not found
			return false;
		}
		// remove group members from focus sets and invalidate them
		final TupleSet<? extends VisualItem<?>>[] focus = (TupleSet<? extends VisualItem<?>>[]) Array.newInstance(TupleSet.class,
				m_focus.size());
		m_focus.values().toArray(focus);
		for (final VisualItem<?> item : ts.tuples()) {
			for (int j = 0; j < focus.length; ++j) {
				focus[j].removeTuple(item);
			}
			item.setValidated(false);
		}
		// remove data
		if (ts instanceof CompositeTupleSet) {
			final CompositeTupleSet<? extends VisualItem<?>> cts = (CompositeTupleSet<? extends VisualItem<?>>) ts;
			for (final String name : cts.setNames()) {
				final String subgroup = PrefuseLib.getGroupName(group, name);
				m_visual.remove(subgroup);
				m_source.remove(subgroup);
			}
		}
		m_visual.remove(group);
		m_source.remove(group);
		return true;
	}

	/**
	 * Reset this visualization, clearing out all visualization tuples. All data sets added using
	 * the "addXXX" methods will be removed from the visualization. All registered focus groups
	 * added using the addFocusGroup() methods will be retained, but will be cleared of all tuples.
	 */
	public synchronized void reset() {
		// first clear out all the focus groups
		final Iterator<Map.Entry<String, TupleSet<? extends VisualItem<?>>>> iter = m_focus.entrySet().iterator();
		while (iter.hasNext()) {
			final Map.Entry<String, TupleSet<? extends VisualItem<?>>> entry = iter.next();
			final TupleSet<? extends VisualItem<?>> ts = entry.getValue();
			ts.clear();
		}
		// finally clear out all map entries
		m_visual.clear();
		m_source.clear();
	}

	// ------------------------------------------------------------------------
	// Groups

	/**
	 * Get the source data TupleSet backing the given visual data group.
	 * 
	 * @@return the backing source data set, or null if there is no such data set
	 */
	public TupleSet<? extends Tuple<?>> getSourceData(final String group) {
		return m_source.get(group);
	}

	/**
	 * Get the source data TupleSet backing the given visual tuple set.
	 * 
	 * @@return the backing source data set, or null if there is no such data set
	 */
	public TupleSet<? extends Tuple<?>> getSourceData(final VisualTupleSet<?> ts) {
		return m_source.get(ts.getGroup());
	}

	/**
	 * Get the Tuple from a backing source data set that corresponds most closely to the given
	 * VisualItem.
	 * 
	 * @@param item
	 *            the VisualItem for which to retrieve the source tuple
	 * @@return the data source tuple, or null if no such tuple could be found
	 */
	public Tuple<?> getSourceTuple(final VisualItem<?> item) {
		// get the source group and tuple set, exit if none
		final String group = item.getGroup();
		final TupleSet<? extends Tuple<?>> source = getSourceData(group);
		if (source == null) {
d884 60
a943 64
		// first get the source table and row value
		int row = item.getRow();
		Table<? extends Tuple<?>> t = item.getTable();
		while (t instanceof VisualTable) {
			final VisualTable<?, ?> vt = (VisualTable<?, ?>) t;
			row = vt.getParentRow(row);
			t = vt.getParentTable();
		}

		// now get the appropriate source tuple
		// graphs maintain their own tuple managers so treat them specially
		final String cgroup = PrefuseLib.getChildGroup(group);
		if (cgroup != null) {
			final String pgroup = PrefuseLib.getParentGroup(group);
			final Graph<?, ?, ?> g = (Graph<?, ?, ?>) getSourceData(pgroup);
			if (t == g.getNodeTable()) {
				return g.getNode(row);
			} else {
				return g.getEdge(row);
			}
		} else {
			return t.getTuple(row);
		}
	}

	/**
	 * Get the VisualItem associated with a source data tuple, if it exists.
	 * 
	 * @@param group
	 *            the data group from which to lookup the source tuple, only primary visual groups
	 *            are valid, focus groups will not work
	 * @@param t
	 *            the source data tuple
	 * @@return the associated VisualItem from the given data group, or null if no such VisualItem
	 *         exists
	 */
	public VisualItem<?> getVisualItem(final String group, final Tuple<?> t) {
		final VisualTupleSet<?> ts = getVisualGroup(group);
		VisualTable<?, ?> vt;
		if (ts instanceof VisualTable) {
			vt = (VisualTable<?, ?>) ts;
		} else if (ts instanceof Graph) {
			final Graph<?, ?, ?> g = (Graph<?, ?, ?>) ts;
			vt = (VisualTable<?, ?>) (t instanceof Node ? g.getNodeTable() : g.getEdgeTable());
		} else {
			return null;
		}
		final int pr = t.getRow();
		final int cr = vt.getChildRow(pr);
		return cr < 0 ? null : vt.getItem(cr);
	}

	// ------------------------------------------------------------------------

	/**
	 * Get the TupleSet associated with the given data group name.
	 * 
	 * @@param group
	 *            a visual data group name
	 * @@return the data group TupleSet
	 */
	public <T extends VisualItem<?>> TupleSet<? extends VisualItem<?>> getGroup(final String group) {
		TupleSet<T> ts = (TupleSet<T>) getVisualGroup(group);
		if (ts == null) {
d946 2
a947 2
		return ts;
	}
d949 9
a957 11
	/**
	 * Indicates if a given VisualItem is contained in the given visual data group.
	 * 
	 * @@param item
	 *            the VisualItem instance
	 * @@param group
	 *            the data group to check for containment
	 * @@return true if the VisualItem is in the group, false otherwise
	 */
	public boolean isInGroup(final VisualItem<?> item, final String group) {
		if (ALL_ITEMS.equals(group)) {
d960 1
a960 1
		if (item.getGroup() == group) {
d964 124
a1087 138
		final TupleSet<? extends VisualItem<?>> tset = getGroup(group);
		return tset == null ? false : tset.containsTuple(item);
	}

	/**
	 * Add a new secondary, or focus, group to this visualization. By default the added group is an
	 * instance of {@@link prefuse.data.tuple.DefaultTupleSet}.
	 * 
	 * @@param group
	 *            the name of the focus group to add
	 */
	public void addFocusGroup(final String group) {
		checkGroupExists(group);
		m_focus.put(group, new DefaultTupleSet<VisualItem<?>>());
	}

	/**
	 * Add a new secondary, or focus, group to this visualization.
	 * 
	 * @@param group
	 *            the name of the focus group to add
	 * @@param tset
	 *            the TupleSet for the focus group
	 */
	public void addFocusGroup(final String group, final TupleSet<? extends VisualItem<?>> tset) {
		checkGroupExists(group);
		m_focus.put(group, tset);
	}

	// ------------------------------------------------------------------------
	// VisualItems

	/**
	 * Get the size of the given visual data group.
	 * 
	 * @@param group
	 *            the visual data group
	 * @@return the size (number of tuples) of the group
	 */
	public int size(final String group) {
		final TupleSet<? extends VisualItem<?>> tset = getGroup(group);
		return tset == null ? 0 : tset.getTupleCount();
	}

	/**
	 * Retrieve the visual data group of the given group name. Only primary visual groups will be
	 * considered.
	 * 
	 * @@param group
	 *            the visual data group
	 * @@return the requested data group, or null if not found
	 */
	public <T extends VisualItem<?>> VisualTupleSet<? extends VisualItem<?>> getVisualGroup(final String group) {
		return m_visual.get(group);
	}

	/**
	 * Retrieve the focus data group of the given group name. Only secondary, or focus, groups will
	 * be considered.
	 * 
	 * @@param group
	 *            the focus data group
	 * @@return the requested data group, or null if not found
	 */
	public <T extends VisualItem<?>> TupleSet<T> getFocusGroup(final String group) {
		return (TupleSet<T>) m_focus.get(group);
	}

	/**
	 * Invalidate the bounds of all VisualItems in the given group. This will cause the bounds to be
	 * recomputed for all items upon the next redraw.
	 * 
	 * @@param group
	 *            the visual data group to invalidate
	 */
	public void invalidate(final String group) {
		for (final VisualItem<?> item : items(group, ValidatedPredicate.TRUE)) {
			item.setValidated(false);
		}
	}

	/**
	 * Invalidate the bounds of all VisualItems in this visualization. This will cause the bounds to
	 * be recomputed for all items upon the next redraw.
	 */
	public void invalidateAll() {
		invalidate(ALL_ITEMS);
	}

	/**
	 * Get an iterator over all visible items.
	 * 
	 * @@return an iterator over all visible items.
	 */
	public Iterable<? extends VisualItem<?>> visibleItems() {
		return items(VisiblePredicate.TRUE);
	}

	/**
	 * Get an iterator over all visible items in the specified group.
	 * 
	 * @@param group
	 *            the visual data group name
	 * @@return an iterator over all visible items in the specified group
	 */
	public Iterable<? extends VisualItem<?>> visibleItems(final String group) {
		return items(group, VisiblePredicate.TRUE);
	}

	/**
	 * Get an iterator over all items, visible or not.
	 * 
	 * @@return an iterator over all items, visible or not.
	 */
	public Iterable<? extends VisualItem<?>> items() {
		return items((Predicate) null);
	}

	/**
	 * Get an iterator over all items which match the given Predicate filter.
	 * 
	 * @@param filter
	 *            a Predicate indicating which items should be included in the iteration
	 * @@return a filtered iterator over VisualItems
	 */
	public Iterable<? extends VisualItem<?>> items(final Predicate filter) {
		final int size = m_visual.size();
		if (size == 0) {
			return Collections.emptyList();
		} else if (size == 1) {
			final Iterator<String> it = m_visual.keySet().iterator();
			return items(it.next(), filter);
		} else {
			final CompositeIterable<VisualItem<?>> iter = new CompositeIterable<VisualItem<?>>(m_visual.size());
			final Iterator<String> it = m_visual.keySet().iterator();
			for (int i = 0; it.hasNext();) {
				final String group = it.next();
				if (!PrefuseLib.isChildGroup(group)) {
d1090 43
a1132 47
			}
			return iter;
		}
	}

	/**
	 * Get an iterator over all items in the specified group.
	 * 
	 * @@param group
	 *            the visual data group name
	 * @@return an iterator over all items in the specified group.
	 */
	public Iterable<? extends VisualItem<?>> items(final String group) {
		return items(group, (Predicate) null);
	}

	/**
	 * Get an iterator over all items in the given group which match the given filter expression.
	 * 
	 * @@param group
	 *            the visual data group to iterate over
	 * @@param expr
	 *            an expression string that should parse to a Predicate indicating which items
	 *            should be included in the iteration. The input string will be parsed using the
	 *            {@@link prefuse.data.expression.parser.ExpressionParser} class. If a parse error
	 *            occurs, an empty iterator is returned.
	 * @@return a filtered iterator over VisualItems
	 */
	public Iterable<? extends Tuple<?>> items(final String group, final String expr) {
		final Expression e = ExpressionParser.parse(expr);
		if (!(e instanceof Predicate) || ExpressionParser.getError() != null) {
			return Collections.<VisualItem<?>> emptyList();
		}
		return items(group, (Predicate) e);
	}

	/**
	 * Get an iterator over all items in the given group which match the given Predicate filter.
	 * 
	 * @@param group
	 *            the visual data group to iterate over
	 * @@param filter
	 *            a Predicate indicating which items should be included in the iteration.
	 * @@return a filtered iterator over VisualItems
	 */
	public Iterable<? extends VisualItem<?>> items(final String group, final Predicate filter) {
		if (ALL_ITEMS.equals(group)) {
d1136 319
a1454 357
		final TupleSet<? extends VisualItem<?>> t = getGroup(group);
		return t == null ? Collections.<VisualItem<?>> emptyList() : t.tuples(filter);
	}

	// ------------------------------------------------------------------------
	// Batch Methods

	/**
	 * Set a data field value for all items in a given data group matching a given filter predicate.
	 * 
	 * @@param group
	 *            the visual data group name
	 * @@param p
	 *            the filter predicate determining which items to modify
	 * @@param field
	 *            the data field / column name to set
	 * @@param val
	 *            the value to set
	 */
	public void setValue(final String group, final Predicate p, final String field, final Object val) {
		for (final VisualItem<?> item : items(group, p)) {
			item.set(field, val);
		}
	}

	/**
	 * Sets the visbility status for all items in a given data group matching a given filter
	 * predicate.
	 * 
	 * @@param group
	 *            the visual data group name
	 * @@param p
	 *            the filter predicate determining which items to modify
	 * @@param value
	 *            the visibility value to set
	 */
	public void setVisible(final String group, final Predicate p, final boolean value) {
		for (final VisualItem<?> item : items(group, p)) {
			item.setVisible(value);
		}
	}

	/**
	 * Sets the interactivity status for all items in a given data group matching a given filter
	 * predicate.
	 * 
	 * @@param group
	 *            the visual data group name
	 * @@param p
	 *            the filter predicate determining which items to modify
	 * @@param value
	 *            the interactivity value to set
	 */
	public void setInteractive(final String group, final Predicate p, final boolean value) {
		for (final VisualItem<?> item : items(group, p)) {
			item.setInteractive(value);
		}
	}

	// ------------------------------------------------------------------------
	// Action Methods

	/**
	 * Add a data processing Action to this Visualization. The Action will be updated to use this
	 * Visualization in its data processing.
	 * 
	 * @@param name
	 *            the name of the Action
	 * @@param action
	 *            the Action to add
	 */
	public Action putAction(final String name, final Action action) {
		action.setVisualization(this);
		m_actions.put(name, action);
		return action;
	}

	/**
	 * Get the data processing Action with the given name.
	 * 
	 * @@param name
	 *            the name of the Action
	 * @@return the requested Action, or null if the name was not found
	 */
	public Action getAction(final String name) {
		return (Action) m_actions.get(name);
	}

	/**
	 * Remove a data processing Action registered with this visualization. If the removed action is
	 * currently running, it will be canceled. The visualization reference held by the removed
	 * Action will be set to null.<br/> <strong>NOTE:</strong> Errors may occur if the removed
	 * Action is included in an "always run after" relation with another registered Action that has
	 * not been removed from this visualization. It is the currently the responsibility of clients
	 * to avoid this situation.
	 * 
	 * @@param name
	 *            the name of the Action
	 * @@return the removed Action, or null if no action was found
	 */
	public Action removeAction(final String name) {
		// TODO: create registry of always run after relations to automatically
		// resolve action references?
		final Action a = getAction(name);
		if (a != null) {
			a.cancel();
			m_actions.remove(name);
			a.setVisualization(null);
		}
		return a;
	}

	/**
	 * Remove all data processing Actions registered with this visualization. If the removed action
	 * is currently running, it will be cancelled. The visualization reference held by the removed
	 * Actions will be set to null.
	 * <p>
	 * TODO: this will not handle "always run after" relations appropriately.
	 */
	public void removeAllActions() {
		for (final String key : m_actions.allKeys()) {
			removeAction(key);
		}
	}

	/**
	 * Schedule the Action with the given name to run immediately. The running of all Actions is
	 * managed by the {@@link prefuse.activity.ActivityManager}, which runs in a dedicated thread.
	 * 
	 * @@param action
	 *            the name of the Action to run
	 * @@return the Action scheduled to run
	 */
	public Activity run(final String action) {
		return m_actions.run(action);
	}

	/**
	 * Schedule the Action with the given name to run after the specified delay. The running of all
	 * Actions is managed by the {@@link prefuse.activity.ActivityManager}, which runs in a
	 * dedicated thread.
	 * 
	 * @@param action
	 *            the name of the Action to run
	 * @@param delay
	 *            the amount of time to wait, in milliseconds, before running the Action
	 * @@return the Action scheduled to run
	 */
	public Activity runAfter(final String action, final long delay) {
		return m_actions.runAt(action, System.currentTimeMillis() + delay);
	}

	/**
	 * Schedule the Action with the given name to run at the specified time. The running of all
	 * Actions is managed by the {@@link prefuse.activity.ActivityManager}, which runs in a
	 * dedicated thread.
	 * 
	 * @@param action
	 *            the name of the Action to run
	 * @@param startTime
	 *            the absolute system time, in milliseconds since the epoch, at which to run the
	 *            Action.
	 * @@return the Action scheduled to run
	 */
	public Activity runAt(final String action, final long startTime) {
		return m_actions.runAt(action, startTime);
	}

	/**
	 * Schedule the Action with the given name to run after another Action finishes running. This
	 * relationship will only hold for one round of scheduling. If the "before" Action is run a
	 * second time, the "after" action will not be run a second time. The running of all Actions is
	 * managed by the {@@link prefuse.activity.ActivityManager}, which runs in a dedicated thread.
	 * 
	 * @@param before
	 *            the name of the Action to wait for
	 * @@param after
	 *            the name of the Action to run after the first one finishes
	 * @@return the Action scheduled to run after the first one finishes
	 */
	public Activity runAfter(final String before, final String after) {
		return m_actions.runAfter(before, after);
	}

	/**
	 * Schedule the Action with the given name to always run after another Action finishes running.
	 * The running of all Actions is managed by the {@@link prefuse.activity.ActivityManager}, which
	 * runs in a dedicated thread.
	 * 
	 * @@param before
	 *            the name of the Action to wait for
	 * @@param after
	 *            the name of the Action to run after the first one finishes
	 * @@return the Action scheduled to always run after the first one finishes
	 */
	public Activity alwaysRunAfter(final String before, final String after) {
		return m_actions.alwaysRunAfter(before, after);
	}

	/**
	 * Cancel the Action with the given name, if it has been scheduled.
	 * 
	 * @@param action
	 *            the name of the Action to cancel
	 * @@return the canceled Action
	 */
	public Activity cancel(final String action) {
		return m_actions.cancel(action);
	}

	// ------------------------------------------------------------------------
	// Renderers

	/**
	 * Set the RendererFactory used by this Visualization. The RendererFactory is responsible for
	 * providing the Renderer instances used to draw the VisualItems.
	 * 
	 * @@param rf
	 *            the RendererFactory to use.
	 */
	public void setRendererFactory(final RendererFactory rf) {
		invalidateAll();
		m_renderers = rf;
	}

	/**
	 * Get the RendererFactory used by this Visualization.
	 * 
	 * @@return this Visualization's RendererFactory
	 */
	public RendererFactory getRendererFactory() {
		return m_renderers;
	}

	/**
	 * Get the renderer for the given item. Consults this visualization's
	 * {@@link prefuse.render.RendererFactory} and returns the result.
	 * 
	 * @@param item
	 *            the item to retreive the renderer for
	 * @@return the {@@link prefuse.render.Renderer} for drawing the given item
	 */
	public Renderer getRenderer(final VisualItem<?> item) {
		if (item.getVisualization() != this) {
			throw new IllegalArgumentException("Input item not a member of this visualization.");
		}
		return m_renderers.getRenderer(item);
	}

	/**
	 * Issue a repaint request, causing all displays associated with this visualization to be
	 * repainted.
	 */
	public synchronized void repaint() {
		for (final VisualItem<?> item : items(ValidatedPredicate.FALSE)) {
			item.validateBounds();
		}
		for (int i = 0; i < m_displays.size(); ++i) {
			getDisplay(i).repaint();
		}
	}

	/**
	 * Get the bounding rectangle for all items in the given group.
	 * 
	 * @@param group
	 *            the visual data group
	 * @@return the bounding box of the items
	 */
	public Rectangle2D getBounds(final String group) {
		return getBounds(group, new Rectangle2D.Double());
	}

	/**
	 * Get the bounding rectangle for all items in the given group.
	 * 
	 * @@param group
	 *            the visual data group name
	 * @@param r
	 *            a rectangle in which to store the computed bounding box
	 * @@return the input rectangle r, updated to hold the computed bounding box
	 */
	public Rectangle2D getBounds(final String group, final Rectangle2D r) {
		boolean first = true;
		for (final VisualItem<?> item : visibleItems(group)) {
			if (first) {
				r.setRect(item.getBounds());
				first = false;
			} else {
				Rectangle2D.union(item.getBounds(), r, r);
			}
		}
		return r;
	}

	// ------------------------------------------------------------------------
	// Displays

	/**
	 * Get the number of displays associated with this visualization.
	 * 
	 * @@return the number of displays
	 */
	public int getDisplayCount() {
		return m_displays.size();
	}

	/**
	 * Add a display to this visualization. Called automatically by the
	 * {@@link prefuse.Display#setVisualization(Visualization)} method.
	 * 
	 * @@param display
	 *            the Display to add
	 */
	void addDisplay(final Display display) {
		m_displays.add(display);
	}

	/**
	 * Get the display at the given list index. Displays are numbered by the order in which they are
	 * added to this visualization.
	 * 
	 * @@param idx
	 *            the list index
	 * @@return the Display at the given index
	 */
	public Display getDisplay(final int idx) {
		return m_displays.get(idx);
	}

	/**
	 * Remove a display from this visualization.
	 * 
	 * @@param display
	 *            the display to remove
	 * @@return true if the display was removed, false if it was not found
	 */
	boolean removeDisplay(final Display display) {
		return m_displays.remove(display);
	}

	/**
	 * Report damage to associated displays, indicating a region that will need to be redrawn.
	 * 
	 * @@param item
	 *            the item responsible for the damage
	 * @@param region
	 *            the damaged region, in item-space coordinates
	 */
	public void damageReport(final VisualItem<?> item, final Rectangle2D region) {
		for (int i = 0; i < m_displays.size(); ++i) {
			final Display d = getDisplay(i);
			if (d.getPredicate().getBoolean(item)) {
				d.damageReport(region);
			}
		}
	}
@


2.9
log
@Added a removeAction method
@
text
@d918 1
a918 1
        Iterator items = items(ValidatedPredicate.TRUE);
@


2.8
log
@Added error-checking for existing group names
Added source data assignment for derived tables and decorators
Added new expert-level addTable method for custom VisualTables
Added new test case for duplicate group names
@
text
@d1103 24
@


2.7
log
@Added visual item lookup by source data tuple
@
text
@d249 16
d275 2
a276 2
        VisualTable vt = new VisualTable(this, group);
        m_visual.put(group, vt);
d291 2
a292 2
        VisualTable vt = new VisualTable(this, group, schema);
        m_visual.put(group, vt);
d321 2
a322 3
        VisualTable vt = new VisualTable(table, this, group, filter);
        m_visual.put(group, vt);
        m_source.put(group, table);
d356 1
a356 2
        m_visual.put(group, vt);
        m_source.put(group, table);
d360 18
a377 1
    // ------------------------------------------------------------------------
d428 1
d441 2
a442 3
        
        m_visual.put(group, vg);
        m_source.put(group, graph);
d502 1
d515 1
a515 2
        m_visual.put(group, vt);
        m_source.put(group, tree);
d526 2
d551 1
a551 1
        m_visual.put(group, vat);
d555 2
d577 2
a578 2
        
        m_visual.put(group, vt);
d664 2
d864 1
d874 2
a875 1
        m_focus.put(group, tset);
@


2.6
log
@Visual data groups now stored in a linked hash map to retain order of entry
@
text
@d15 1
d765 27
@


2.5
log
@Changed visibility of Display add/remove to reduce chance of errors
@
text
@d8 1
d196 1
a196 1
        m_visual = new HashMap();
@


2.4
log
@Fixes and test cases for Visualizations and VisualItems.
Revisited reset, removeGroup, getSourceData, and getSourceTuple.
Added getSourceXXX methods to VisualItem
Added new test cases
@
text
@d1207 1
a1207 1
    public void addDisplay(Display display) {
d1226 1
a1226 1
    public boolean removeDisplay(Display display) {
@


2.3
log
@Commented out potentially unnecessay code in reset() method. Will address this more thoroughly later.
@
text
@d673 3
a675 1
                m_visual.remove(PrefuseLib.getGroupName(group,name));
d679 1
a697 9
        // TODO is all this clearing completely unnecessary?
        // comment out for now, add test cases for this
//        // now clear out all the visual data groups
//        iter = m_visual.entrySet().iterator();
//        while ( iter.hasNext() ) {
//            Map.Entry entry = (Map.Entry)iter.next();
//            TupleSet ts = (TupleSet)entry.getValue();
//            ts.clear();
//        }
a700 1
        
d716 9
d732 1
d734 1
a734 1
        Table source = (Table)getSourceData(group);
d736 24
a759 2
        VisualTable table = (VisualTable)item.getTable();
        return source.getTuple(table.getParentRow(item.getRow()));
d820 1
a820 1
        return ( tset==null ? -1 : tset.getTupleCount() );
@


2.2
log
@Added removeGroup method.
Synchronized add methods.
@
text
@d695 9
a703 7
        // now clear out all the visual data groups
        iter = m_visual.entrySet().iterator();
        while ( iter.hasNext() ) {
            Map.Entry entry = (Map.Entry)iter.next();
            TupleSet ts = (TupleSet)entry.getValue();
            ts.clear();
        }
@


2.1
log
@Fixed batch invalidation routine
@
text
@d21 1
d217 1
a217 1
    public VisualTupleSet add(String group, TupleSet data) {
d233 3
a235 1
    public VisualTupleSet add(String group, TupleSet data, Predicate filter) {
d256 1
a256 1
    public VisualTable addTable(String group) {
d272 1
a272 1
    public VisualTable addTable(String group, Schema schema) {
d286 1
a286 1
    public VisualTable addTable(String group, Table table) {
d300 3
a302 1
    public VisualTable addTable(String group, Table table, Predicate filter) {
d318 3
a320 1
    public VisualTable addTable(String group, Table table, Schema schema) {
d335 2
a336 2
    public VisualTable addTable(String group, Table table, 
                                Predicate filter, Schema schema)
d356 1
a356 1
    public VisualGraph addGraph(String group, Graph graph) {
d372 3
a374 1
    public VisualGraph addGraph(String group, Graph graph, Predicate filter) {
d392 2
a393 2
    public VisualGraph addGraph(String group, Graph graph, Predicate filter,
                                Schema nodeSchema, Schema edgeSchema)
d430 1
a430 1
    public VisualTree addTree(String group, Tree tree) {
d446 3
a448 1
    public VisualTree addTree(String group, Tree tree, Predicate filter) {
d466 2
a467 2
    public VisualTree addTree(String group, Tree tree, Predicate filter,
            Schema nodeSchema, Schema edgeSchema)
d500 1
a500 1
    public AggregateTable addAggregates(String group) {
d512 3
a514 1
    public AggregateTable addAggregates(String group, Schema schema) {
d535 2
a536 2
    public VisualTable addDerivedTable(String group, String source,
            Predicate filter, Schema override)
d558 1
a558 1
    public VisualTable addDecorators(String group, String source) {
d576 3
a578 1
    public VisualTable addDecorators(String group, String source, Schema schema) {
d595 2
a596 2
    public VisualTable addDecorators(String group, String source, 
                                     Predicate filter)
d619 2
a620 2
    public VisualTable addDecorators(String group, String source, 
                                     Predicate filter, Schema schema)
d628 53
@


2.0
log
@Merge beta branch back onto main trunk
@
text
@d755 3
a757 8
        TupleSet ts = getGroup(group);
        if ( ts == null ) {
            // TODO exception here, or log warning?
            return;
        }
        Iterator tuples = ts.tuples();
        while ( tuples.hasNext() ) {
            VisualItem item = (VisualItem)tuples.next();
@


1.1
log
@file Visualization.java was initially added on branch beta.
@
text
@d1 1155
@


1.1.2.1
log
@Initial commit of prefuse beta
@
text
@a0 539
package prefuse;

import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import prefuse.action.Action;
import prefuse.activity.Activity;
import prefuse.activity.ActivityMap;
import prefuse.data.Graph;
import prefuse.data.Schema;
import prefuse.data.Table;
import prefuse.data.Tree;
import prefuse.data.expression.Predicate;
import prefuse.data.tuple.DefaultTupleSet;
import prefuse.data.tuple.EdgeTupleManager;
import prefuse.data.tuple.NodeTupleManager;
import prefuse.data.tuple.Tuple;
import prefuse.data.tuple.TupleSet;
import prefuse.render.DefaultRendererFactory;
import prefuse.render.Renderer;
import prefuse.render.RendererFactory;
import prefuse.util.PrefuseConfig;
import prefuse.util.PrefuseLib;
import prefuse.util.collections.CompositeIterator;
import prefuse.visual.DecoratorItemTupleManager;
import prefuse.visual.EdgeItemTupleManager;
import prefuse.visual.NodeItemTupleManager;
import prefuse.visual.VisualGraph;
import prefuse.visual.VisualItem;
import prefuse.visual.VisualTable;
import prefuse.visual.VisualTree;
import prefuse.visual.expression.ValidatedPredicate;
import prefuse.visual.expression.VisiblePredicate;

public class Visualization {
    
    public static final String ALL_ITEMS 
        = PrefuseConfig.get("visualization.allItems");
    public static final String FOCUS_ITEMS
        = PrefuseConfig.get("visualization.focusItems");
    public static final String SELECTED_ITEMS
        = PrefuseConfig.get("visualization.selectedItems");
    public static final String SEARCH_ITEMS
        = PrefuseConfig.get("visualization.searchItems");
    
    // filters
    
    // visual abstraction
    // filtered tables and groups
    private Map m_visual;
    private Map m_source;
    private Map m_focus;
    
    // actions
    private ActivityMap m_actions;
    
    // renderers
    private RendererFactory m_renderers;
    
    // displays
    private ArrayList m_displays;
    
    // ------------------------------------------------------------------------
    // Constructor
    
    public Visualization() {
        m_actions = new ActivityMap();
        m_renderers = new DefaultRendererFactory();
        m_visual = new HashMap();
        m_source = new HashMap();
        m_focus = new HashMap();
        m_displays = new ArrayList();
        
        addFocusGroup(Visualization.FOCUS_ITEMS,    new DefaultTupleSet());
        addFocusGroup(Visualization.SELECTED_ITEMS, new DefaultTupleSet());
    }
    
    // ------------------------------------------------------------------------
    // Data Methods
    
    public TupleSet add(String group, TupleSet data) {
        return add(group, data, null);
    }
    
    public TupleSet add(String group, TupleSet data, Predicate filter) {
        if ( data instanceof Table ) {
            return addTable(group, (Table)data, filter);
        } else if ( data instanceof Tree ) {
            // TODO: allow tree filter
            return addTree(group, (Tree)data /*, filter*/);
        } else if ( data instanceof Graph ) {
            return addGraph(group, (Graph)data, filter);
        } else {
            throw new IllegalArgumentException();
        }
    }
    
    public VisualTable addTable(String group) {
        VisualTable vt = new VisualTable(this, group);
        m_visual.put(group, vt);
        return vt;
    }
    
    public VisualTable addTable(String group, Schema schema) {
        VisualTable vt = new VisualTable(this, group, schema);
        m_visual.put(group, vt);
        return vt;
    }
    
    /**
     * Adds the given table to this visualization, using the provided group
     * name. This will be the <em>primary group</em> designation for
     * VisualItems representing data for this table. An exception will be
     * thrown if the group name is already in use.
     * @@param table
     * @@param group
     */
    public VisualTable addTable(String group, Table table) {
        return addTable(group, table, (Predicate)null);
    }
    
    public VisualTable addTable(String group, Table table, Predicate filter) {
        VisualTable vt = new VisualTable(table, this, group, filter);
        m_visual.put(group, vt);
        m_source.put(group, table);
        return vt;
    }
    
    public VisualTable addTable(String group, Table table, Schema schema) {
        return addTable(group, table, null, schema);
    }
    
    public VisualTable addTable(String group, Table table, 
                                Predicate filter, Schema schema)
    {
        VisualTable vt = new VisualTable(table, this, group, filter, schema);
        m_visual.put(group, vt);
        m_source.put(group, table);
        return vt;
    }
    
    // ------------------------------------------------------------------------
    
    public VisualGraph addGraph(String group, Graph graph) {
        return addGraph(group, graph, null);
    }
    
    public VisualGraph addGraph(String group, Graph graph, Predicate filter)
    {
        String ngroup = PrefuseLib.getGroupName(group, Graph.NODE_TABLE); 
        String egroup = PrefuseLib.getGroupName(group, Graph.EDGE_TABLE);
        
        VisualTable nt = new VisualTable(graph.getNodeTable(), this, ngroup, filter);
        VisualTable et = new VisualTable(graph.getEdgeTable(), this, egroup, filter);
        
        VisualGraph vg = new VisualGraph(nt, et, graph.getNodeKeyField(),
                graph.getEdgeSourceField(), graph.getEdgeTargetField());
        vg.setVisualization(this);
        vg.setGroup(group);
        
        m_visual.put(group, vg);
        m_visual.put(ngroup, nt);
        m_visual.put(egroup, et);
        m_source.put(group, graph);
        m_source.put(ngroup, graph.getNodeTable());
        m_source.put(egroup, graph.getEdgeTable());
        
        NodeTupleManager ntm = new NodeItemTupleManager();
        EdgeTupleManager etm = new EdgeItemTupleManager();
        nt.setTupleManager(ntm);
        et.setTupleManager(etm);
        vg.setTupleManagers(ntm, etm);
        
        return vg;
    }
    
    public VisualTree addTree(String group, Tree tree) {
        String ngroup = PrefuseLib.getGroupName(group, Graph.NODE_TABLE); 
        String egroup = PrefuseLib.getGroupName(group, Graph.EDGE_TABLE);
        
        VisualTable nt = new VisualTable(tree.getNodeTable(), this, ngroup);
        VisualTable et = new VisualTable(tree.getEdgeTable(), this, egroup);

        VisualTree vt = new VisualTree(nt, et, tree.getNodeKeyField(),
                tree.getEdgeSourceField(), tree.getEdgeTargetField());
        vt.setVisualization(this);
        vt.setGroup(group);
        
        m_visual.put(group, vt);
        m_visual.put(ngroup, nt);
        m_visual.put(egroup, et);
        m_source.put(group, tree);
        m_source.put(ngroup, tree.getNodeTable());
        m_source.put(egroup, tree.getEdgeTable());
        
        NodeTupleManager ntm = new NodeItemTupleManager();
        EdgeTupleManager etm = new EdgeItemTupleManager();
        nt.setTupleManager(ntm);
        et.setTupleManager(etm);
        vt.setTupleManagers(ntm, etm);
        
        return vt;
    }
    
    public VisualTable addDerivedTable(String group, String source,
            Predicate filter, Schema override)
    {
        VisualTable src = (VisualTable)getGroup(source);
        VisualTable vt = new VisualTable(src, this, group, filter, override);
        
        m_visual.put(group, vt);
        return vt;
    }
    
    public VisualTable addDecorators(String group, String source, 
                                     Predicate filter)
    {
        VisualTable t = addDerivedTable(group,source,filter,VisualItem.SCHEMA);
        t.setTupleManager(new DecoratorItemTupleManager());
        return t;
    }
    
    public VisualTable addDecorators(String group, String source, 
                                     Predicate filter, Schema schema)
    {
        VisualTable t = addDerivedTable(group, source, filter, schema);
        t.setTupleManager(new DecoratorItemTupleManager());
        return t;
    }
    
    
    // ------------------------------------------------------------------------
    // Groups
    
    public TupleSet getSourceData(String group) {
        return (TupleSet)m_source.get(group);
    }
    
    public Tuple getSourceTuple(VisualItem item) {
        String group = item.getGroup();
        Table source = (Table)getSourceData(group);
        VisualTable table = (VisualTable)item.getTable();
        return source.getTuple(table.getParentRow(item.getRow()));
    }
    
    public TupleSet getGroup(String group) {
        TupleSet ts = getVisualGroup(group);
        if ( ts == null )
            ts = getFocusGroup(group);
        return ts;
    }
    
    public boolean isInGroup(VisualItem item, String group) {
        if ( ALL_ITEMS.equals(group) )
            return true;
        if ( item.getGroup() == group )
            return true;
        
        TupleSet tset = getGroup(group);
        return ( tset==null ? false : tset.containsTuple(item) );
    }
    
    public void addFocusGroup(String group) {
        m_focus.put(group, new DefaultTupleSet());
    }
    
    public void addFocusGroup(String group, TupleSet tset) {
        m_focus.put(group, tset);
    }
    
    public void addSubGroup(String group, String subgroup, Predicate filter) {
        // do nothing
    }
    
    // ------------------------------------------------------------------------
    // VisualItems
    
    public int size() {
        return -1;
    }
    
    public int size(String group) {
        TupleSet tset = getGroup(group);
        return ( tset==null ? -1 : tset.getTupleCount() );
    }
    
    public TupleSet getVisualGroup(String group) {
        return (TupleSet)m_visual.get(group);
    }
    
    public TupleSet getFocusGroup(String group) {
        return (TupleSet)m_focus.get(group);
    }
    
    public void invalidate(String group) {
        TupleSet ts = getGroup(group);
        if ( ts == null ) {
            // TODO exception here, or log warning?
            return;
        }
        Iterator tuples = ts.tuples();
        while ( tuples.hasNext() ) {
            VisualItem item = (VisualItem)tuples.next();
            item.setValidated(false);
        }
    }
    
    public void invalidateAll() {
        invalidate(ALL_ITEMS);
    }
    
    /**
     * Return an iterator over all visible items.
     * @@return
     */
    public Iterator visibleItems() {
        return items(VisiblePredicate.TRUE);
    }
    
    /**
     * Return an iterator over all visible items in the specified group.
     * @@param group the group name
     * @@return
     */
    public Iterator visibleItems(String group) {
        return items(group, VisiblePredicate.TRUE);
    }
    
    /**
     * Return an iterator over all items.
     * @@return
     */
    public Iterator items() {
        return items((Predicate)null);
    }
    
    /**
     * Return a filtered iterator over all items.
     * @@return
     */
    public Iterator items(Predicate filter) {
        int size = m_visual.size();
        if ( size == 0 ) {
            return Collections.EMPTY_LIST.iterator();
        } else if ( size == 1 ) {
            Iterator it = m_visual.keySet().iterator();
            return items((String)it.next(), filter);
        } else {
            CompositeIterator iter = new CompositeIterator(m_visual.size());
            Iterator it = m_visual.keySet().iterator();
            for ( int i=0; it.hasNext(); ) {
                String group = (String)it.next();
                if ( !PrefuseLib.isChildGroup(group) )
                    iter.setIterator(i++, items(group, filter));
            }
            return iter;
        }
    }
    
    /**
     * Return an iterator over all items in the specified group.
     * @@param group the group name
     * @@return
     */
    public Iterator items(String group) {
        return items(group, null);
    }
    
    /**
     * Return an iterator over all items in the specified group.
     * @@param group the group name
     * @@return
     */
    public Iterator items(String group, Predicate filter) {
        if ( ALL_ITEMS.equals(group) )
            return items(filter);
        
        String parent = PrefuseLib.getParentGroup(group);
        if ( parent == null )
        {
            TupleSet t = getGroup(group);
            return ( t==null ? Collections.EMPTY_LIST.iterator() 
                             : t.tuples(filter) );
        }
        else
        {
            String child = PrefuseLib.getChildGroup(group); 
            Graph g = (Graph)getVisualGroup(parent);
            if ( Graph.NODE_TABLE.equals(child) ) {
                return g.getNodeTable().tuples(filter);
            } else {
                return g.getEdgeTable().tuples(filter);
            }
        }
    }
    
    // ------------------------------------------------------------------------
    // Batch Methods
    
    public void setValue(String group, Predicate p, String field, Object val) {
        Iterator items = items(group, p);
        while ( items.hasNext() ) {
            VisualItem item = (VisualItem)items.next();
            item.set(val, field);
        }
    }
    
    public void setVisible(String group, Predicate p, boolean value) {
        Iterator items = items(group, p);
        while ( items.hasNext() ) {
            VisualItem item = (VisualItem)items.next();
            item.setVisible(value);
        }
    }
    
    public void setInteractive(String group, Predicate p, boolean value) {
        Iterator items = items(group, p);
        while ( items.hasNext() ) {
            VisualItem item = (VisualItem)items.next();
            item.setInteractive(value);
        }
    }
    
    // ------------------------------------------------------------------------
    // Action Methods
    
    public Action putAction(String name, Action action) {
        action.setVisualization(this);
        return (Action)m_actions.put(name, action);
    }
    
    public Action getAction(String name) {
        return (Action)m_actions.get(name);
    }
    
    public Activity run(String action) {
        return m_actions.run(action);
    }
    
    public Activity runAfter(String action, long delay) {
        return m_actions.runAt(action, System.currentTimeMillis()+delay);
    }
    
    public Activity runAt(String action, long startTime) {
        return m_actions.runAt(action, startTime);
    }
    
    public Activity runAfter(String before, String after) {
        return m_actions.runAfter(before, after);
    }
    
    public Activity alwaysRunAfter(String before, String after) {
        return m_actions.alwaysRunAfter(before, after);
    }
    
    public Activity cancel(String action) {
        return m_actions.cancel(action);
    }
    
    // ------------------------------------------------------------------------
    // Renderers
    
    public void setRendererFactory(RendererFactory rf) {
        invalidateAll();
        m_renderers = rf;
    }
    
    public RendererFactory getRendererFactory() {
        return m_renderers;
    }
    
    public Renderer getRenderer(VisualItem item) {
        if ( item.getVisualization() != this ) {
            throw new IllegalArgumentException(
                    "Input item not a member of this visualization.");
        }
        return m_renderers.getRenderer(item);
    }
    
    public synchronized void repaint() {
        Iterator items = items(ValidatedPredicate.FALSE);
        while ( items.hasNext() ) {
            ((VisualItem)items.next()).validateBounds();
        }
        for ( int i=0; i<m_displays.size(); ++i ) {
            getDisplay(i).repaint();
        }
    }
    
    public Rectangle2D getBounds(String group) {
        return getBounds(group, new Rectangle2D.Double());
    }
    
    public Rectangle2D getBounds(String group, Rectangle2D r) {
        Iterator iter = visibleItems(group);
        if ( iter.hasNext() ) {
            VisualItem item = (VisualItem)iter.next();
            r.setRect(item.getBounds());
        }
        while ( iter.hasNext() ) {
            VisualItem item = (VisualItem)iter.next();
            Rectangle2D.union(item.getBounds(), r, r);
        }
        return r;
    }
    
    // ------------------------------------------------------------------------
    // Displays
    
    public int getDisplayCount() {
        return m_displays.size();
    }
    
    public void addDisplay(Display display) {
        m_displays.add(display);
    }
    
    public Display getDisplay(int idx) {
        return (Display)m_displays.get(idx);
    }
    
    public boolean removeDisplay(Display display) {
        return m_displays.remove(display);
    }
    
    public void damageReport(VisualItem item, Rectangle2D region) {
        for ( int i=0; i<m_displays.size(); ++i ) {
            Display d = getDisplay(i);
            if ( d.getPredicate().getBoolean(item) ) {
                d.damageReport(region);
            }
        }
    }
    
} // end of class Visualization
@


1.1.2.2
log
@Table method refactoring. Added PredicateChain, included in ColorFunction, SizeFunction, and RendererFactory. Added ItemBoundsListener, included in GraphView demo. Updated ColorMap to use int representation, moved palette creators to ColorLib. Added minExtent to JRangeSlider. Fixed round-off rendering glitches int optimized rendering, added RenderingAccuracy test class. Updated PrefuseConfig to support logging output to file system. Added DelmitedTextTableWriter. Added CompositeTupleSet. Added directionality to edges, increased support to EdgeRenderer, including reversed directionality.
@
text
@d160 1
a160 2
        VisualGraph vg = new VisualGraph(nt, et, 
        		graph.isDirected(), graph.getNodeKeyField(),
d408 1
a408 1
            item.set(field, val);
@


1.1.2.3
log
@Added support for aggregates as a visual data type (AggregateItem, AggregateTable).
Added listener callback to DataSourceWorker.
Reworked graph representation to use an internal table of adjacency lists (the "links" table).
Added spanning tree functionality for all graph instances.
Reworked RadialTreeLayout. Updated PolarLocationAnimator to use an externally defined set for linear Cartesian interpolation cases.
Fixed out-of-order row manager indexing bug in CascadedTable -- all row indexing is now complete once a table insert event is fired.
Made filterRows() public in CascadedTable.
Reorganized visual data support classes to prefuse.visual.tuple package.
@
text
@a16 1
import prefuse.data.expression.Expression;
a17 1
import prefuse.data.expression.parser.ExpressionParser;
d29 3
a31 1
import prefuse.visual.AggregateTable;
a37 3
import prefuse.visual.tuple.DecoratorItemTupleManager;
import prefuse.visual.tuple.EdgeItemTupleManager;
import prefuse.visual.tuple.NodeItemTupleManager;
d152 1
a152 6
    public VisualGraph addGraph(String group, Graph graph, Predicate filter) {
        return addGraph(group, graph, filter, VisualItem.SCHEMA, VisualItem.SCHEMA);
    }
    
    public VisualGraph addGraph(String group, Graph graph, Predicate filter,
    							Schema nodeSchema, Schema edgeSchema)
d154 5
a158 6
        String ngroup = PrefuseLib.getGroupName(group, Graph.NODES); 
        String egroup = PrefuseLib.getGroupName(group, Graph.EDGES);

        VisualTable nt, et;
        nt = addTable(ngroup, graph.getNodeTable(), filter, nodeSchema);
        et = addTable(egroup, graph.getEdgeTable(), filter, edgeSchema);
d167 2
d170 2
d173 2
a174 2
        NodeTupleManager ntm = new NodeItemTupleManager(vg);
        EdgeTupleManager etm = new EdgeItemTupleManager(vg);
d183 2
a184 12
    	return addTree(group, tree, null);
    }
    
    public VisualTree addTree(String group, Tree tree, Predicate filter) {
    	return addTree(group, tree, filter, VisualItem.SCHEMA, VisualItem.SCHEMA);
    }
    
    public VisualTree addTree(String group, Tree tree, Predicate filter,
    		Schema nodeSchema, Schema edgeSchema)
    {
        String ngroup = PrefuseLib.getGroupName(group, Graph.NODES); 
        String egroup = PrefuseLib.getGroupName(group, Graph.EDGES);
d186 2
a187 3
        VisualTable nt, et;
        nt = addTable(ngroup, tree.getNodeTable(), filter, nodeSchema);
        et = addTable(egroup, tree.getEdgeTable(), filter, edgeSchema);
d195 2
d198 2
d201 2
a202 2
        NodeTupleManager ntm = new NodeItemTupleManager(vt);
        EdgeTupleManager etm = new EdgeItemTupleManager(vt);
a209 10
    public AggregateTable addAggregates(String group) {
    	return addAggregates(group, VisualItem.SCHEMA);
    }
    
    public AggregateTable addAggregates(String group, Schema schema) {
    	AggregateTable vat = new AggregateTable(this, group, schema);
    	m_visual.put(group, vat);
    	return vat;
    }
    
a219 8
    public VisualTable addDecorators(String group, String source) {
    	return addDecorators(group, source, (Predicate)null);
    }
    
    public VisualTable addDecorators(String group, String source, Schema schema) {
    	return addDecorators(group, source, null, schema);
    }
    
a235 27
    /**
     * Reset this visualization, clearing out all visualization tuples. All
     * data sets added using the "addXXX" methods will be removed from the
     * visualization. All registered focus groups added using the 
     * addFocusGroup() methods will be retained, but will be cleared of all
     * tuples.
     */
    public synchronized void reset() {
    	// first clear out all the focus groups
    	Iterator iter = m_focus.entrySet().iterator();
    	while ( iter.hasNext() ) {
    		Map.Entry entry = (Map.Entry)iter.next();
    		TupleSet ts = (TupleSet)entry.getValue();
    		ts.clear();
    	}
    	// now clear out all the visual data groups
    	iter = m_visual.entrySet().iterator();
    	while ( iter.hasNext() ) {
    		Map.Entry entry = (Map.Entry)iter.next();
    		TupleSet ts = (TupleSet)entry.getValue();
    		ts.clear();
    	}
    	// finally clear out all map entries
    	m_visual.clear();
    	m_source.clear();
    	
    }
d371 1
a371 8
        return items(group, (Predicate)null);
    }
    
    public Iterator items(String group, String expr) {
    	Expression e = ExpressionParser.parse(expr);
    	if ( !(e instanceof Predicate) || ExpressionParser.getError()!=null )
    		return Collections.EMPTY_LIST.iterator();
    	return items(group, (Predicate)e);
d382 18
a399 4

        TupleSet t = getGroup(group);
        return ( t==null ? Collections.EMPTY_LIST.iterator() 
                         : t.tuples(filter) );
d434 1
a434 2
        m_actions.put(name, action);
        return action;
@


1.1.2.4
log
@Replaced all tab characters with 4 spaces.
Ensured UNIX style line endings.
@
text
@d160 1
a160 1
                                Schema nodeSchema, Schema edgeSchema)
d170 1
a170 1
                graph.isDirected(), graph.getNodeKeyField(),
d188 1
a188 1
        return addTree(group, tree, null);
d192 1
a192 1
        return addTree(group, tree, filter, VisualItem.SCHEMA, VisualItem.SCHEMA);
d196 1
a196 1
            Schema nodeSchema, Schema edgeSchema)
d223 1
a223 1
        return addAggregates(group, VisualItem.SCHEMA);
d227 3
a229 3
        AggregateTable vat = new AggregateTable(this, group, schema);
        m_visual.put(group, vat);
        return vat;
d243 1
a243 1
        return addDecorators(group, source, (Predicate)null);
d247 1
a247 1
        return addDecorators(group, source, null, schema);
d274 18
a291 18
        // first clear out all the focus groups
        Iterator iter = m_focus.entrySet().iterator();
        while ( iter.hasNext() ) {
            Map.Entry entry = (Map.Entry)iter.next();
            TupleSet ts = (TupleSet)entry.getValue();
            ts.clear();
        }
        // now clear out all the visual data groups
        iter = m_visual.entrySet().iterator();
        while ( iter.hasNext() ) {
            Map.Entry entry = (Map.Entry)iter.next();
            TupleSet ts = (TupleSet)entry.getValue();
            ts.clear();
        }
        // finally clear out all map entries
        m_visual.clear();
        m_source.clear();
        
d432 4
a435 4
        Expression e = ExpressionParser.parse(expr);
        if ( !(e instanceof Predicate) || ExpressionParser.getError()!=null )
            return Collections.EMPTY_LIST.iterator();
        return items(group, (Predicate)e);
@


1.1.2.5
log
@Javadoc'd.
@
text
@a35 1
import prefuse.visual.VisualTupleSet;
a41 113
/**
 * <p>Central data structure representing an interactive Visualization.
 * This class is responsible for
 * managing the mappings between source data and onscreen VisualItems,
 * maintaining a list of {@@link Display} instances responsible for rendering
 * of and interaction with the contents of this visualization, and
 * providing a collection of named Action instances for performing
 * data processing such as layout, animation, and size, shape, and color
 * assignment.</p>
 * 
 * <p>The primary responsibility of the Visualization class is the creation
 * of <em>visual abstractions</em> of input data. Regardless of the data
 * structure (i.e., {@@link prefuse.data.Table}, {@@link prefuse.data.Graph},
 * or {@@link prefuse.data.Tree}), this class takes source data such as that
 * loaded from a file (see {@@link prefuse.data.io}) or from a relational
 * database (see {@@link prefuse.data.io.sql}) and creates a visual
 * representation of the data. These visual representations of the data are
 * data sets in their own right, providing access to the underlying source
 * data to be visualized while also adding addition data fields specific to a
 * visualization. These fields include spatial location (x, y
 * coordinates and item bounds), color (for stroke, fill, and text), size,
 * shape, and font. For a given input data set of type
 * {@@link prefuse.data.Table}, {@@link prefuse.data.Graph}, or
 * or {@@link prefuse.data.Tree}, a corresponding instance of
 * {@@link prefuse.visual.VisualTable}, {@@link prefuse.visual.VisualGraph}, or
 * {@@link prefuse.visual.VisualTree} is created and stored in the
 * visualization. These data types inherit the data values of the source
 * data (and indeed, manipulate it directly) while additionally providing
 * the aforementioned visual variables unique to that generated
 * visual abstraction. Similarly, all {@@link prefuse.data.tuple.Tuple},
 * {@@link prefuse.data.tuple.Node}, or {@@link prefuse.data.tuple.Edge}
 * instances used to represent an entry in the source data have a
 * corresponding {@@link prefuse.visual.VisualItem},
 * {@@link prefuse.visual.NodeItem}, or {@@link prefuse.visual.EdgeItem}
 * representing the interactive, visual realization of the backing data.</p>
 * 
 * <p>The mapping of source data to a visual abstraction is accomplished
 * using {@@link #add(String, TupleSet)} and the other "add" methods. These
 * methods will automatically create the visual abstraction, and store it
 * in this visualization, associating it with a provided <em>data group name
 * </em>. This group name allows for queries to this visualization that
 * consider only VisualItem instances from that particular group. This is
 * quite useful when crafting {@@link prefuse.action.Action} instances that
 * process only a particular group of visual data. The Visualization class
 * provides mechanisms for querying any or all groups within the visualization,
 * using one or both of the group name or a filtering
 * {@@link prefuse.data.expression.Predicate} to determine the items to
 * include (see {@@link #items(Predicate)} for an examples). Source data
 * may be added multiple times to a Visualization under different group
 * names, allowing for multiple representations of the same backing data.</p>
 * 
 * <p>Additionally, the Visualization class supports VisualItem instances
 * that are not directly grounded in backing source data. Examples include
 * {@@link prefuse.visual.DecoratorItem} which "decorates" another pre-existing
 * VisualItem with a separate interactive visual object, and
 * {@@link prefuse.visual.AggregateItem} which provides an interactive visual
 * representation of an aggregated of other VisualItems. Methods for adding
 * data groups of these kinds include {@@link #addDecorators(String, String)}
 * and {@@link #addAggregates(String)}.</p>
 * 
 * <p>All of the examples discussed above are examples of <em>primary, or
 * visual, data groups</em> of VisualItems. Visualizations also support
 * <em>secondary, or focus data groups</em> that maintain additional
 * collections of the VisualItems stored in the primary groups. Examples
 * include a set of focus items (such as those that have been clicked
 * by the user), selected items (items selected by a user), or search
 * items (all matches to a search query). The exact semantics of these
 * groups and the mechanisms by which they are populated is determined by
 * application creators, but some defaults are provided. The Visualization
 * class includes some default group names, namely {@@link #FOCUS_ITEMS},
 * {@@link #SELECTED_ITEMS}, and {@@link #SEARCH_ITEMS} for the above 
 * mentioned tasks. By default, both the {@@link #FOCUS_ITEMS},
 * {@@link #SELECTED_ITEMS} focus groups are included in the Visualization,
 * represented using {@@link prefuse.data.tuple.DefaultTupleSet} instances.
 * Also, some of the interactive controls provided by the
 * {@@link prefuse.controls} package populate these sets by default. See
 * {@@link prefuse.controls.FocusControl} for an example.</p>
 * 
 * <p>Visualizations also maintain references to all the {@@link Display}
 * instances providing interactive views of the content of this
 * visualization. {@@link Display} instances registers themselves with
 * the visualization either in their constructor or through
 * the {@@link Display#setVisualization(Visualization)} method, so they
 * do not otherwise need to be added manually. Displays can be configured
 * to show all or only a subset of the data in the Visualization. A
 * filtering {@@link prefuse.data.expression.Predicate} can be used to
 * control what items are drawn by the displaying, including limiting
 * the Display to particular data groups (for example, using a
 * {@@link prefuse.visual.expression.InGroupPredicate}). The Visualization's
 * {@@link #repaint()} method will trigger a repaint on all Displays
 * associated with the visualization.</p>
 * 
 * <p>Finally, the Visualization class provides a map of named
 * {@@link prefuse.action.Action} instances that can be invoked to perform
 * processing on the VisualItems contained in the visualization.
 * Using the {@@link #putAction(String, Action)} will add a named Action
 * to the visualization, registering the Action such that a reference
 * to this Visualization will be available within the scope of the
 * Action's {@@link prefuse.action.Action#run(double)} method. Processing
 * Actions can later be invoked by name using the {@@link #run(String)}
 * method and other similar methods. This functionality not only
 * provides a convenient means of organizing a Visualization-specific
 * collection of processing Actions, it also allows for a layer of indirection
 * between an Action and its name. This allows Actions to be dynamically
 * swapped at runtime. For example, an application may make a call to
 * invoke an Action named "layout", but the actual layout processing maybe
 * be dynamically swapped by changing the Action that corresponds to that
 * name. For more information on processing Actions, see the
 * {@@link prefuse.action} packages and the top-level
 * {@@link prefuse.action.Action} class.</p>
 * 
 * @@author <a href="http://jheer.org">jeffrey heer</a>
 */
a43 1
    /** Data group name for indicating all groups */
a45 1
    /** Default data group name for focus items */
a47 1
    /** Default data group name for selected items */
a49 1
    /** Default data group name for search result items */
d53 2
a72 3
    /**
     * Create a new, empty Visualization. Uses a DefaultRendererFactory.
     */
d88 1
a88 11
    /**
     * Add a data set to this visualization, using the given data group name.
     * A visual abstraction of the data will be created and registered with
     * the visualization. An exception will be thrown if the group name is
     * already in use.
     * @@param group the data group name for the visualized data
     * @@param data the data to visualize
     * @@return a visual abstraction of the input data, a VisualTupleSet
     * instance
     */
    public VisualTupleSet add(String group, TupleSet data) {
d91 2
a92 14

    /**
     * Add a data set to this visualization, using the given data group name.
     * A visual abstraction of the data will be created and registered with
     * the visualization. An exception will be thrown if the group name is
     * already in use.
     * @@param group the data group name for the visualized data
     * @@param data the data to visualize
     * @@param filter a filter Predicate determining which data Tuples in the
     * input data set are visualized
     * @@return a visual abstraction of the input data, a VisualTupleSet
     * instance
     */
    public VisualTupleSet add(String group, TupleSet data, Predicate filter) {
d96 2
a97 1
            return addTree(group, (Tree)data, filter);
d101 1
a101 1
            throw new IllegalArgumentException("Unsupported TupleSet type.");
a104 9
    /**
     * Add an empty VisualTable to this visualization, using the given data
     * group name. This adds a group of VisualItems that do not have a
     * backing data set, useful for creating interactive visual objects
     * that do not represent data. An exception will be thrown if the group
     * name is already in use.
     * @@param group the data group name for the visualized data
     * @@return the added VisualTable
     */
a110 10
    /**
     * Add an empty VisualTable to this visualization, using the given data
     * group name and table schema. This adds a group of VisualItems that do
     * not have a backing data set, useful for creating interactive visual
     * objects that do not represent data. An exception will be thrown if the
     * group name is already in use.
     * @@param group the data group name for the visualized data
     * @@param schema the data schema to use for the VisualTable
     * @@return the added VisualTable
     */
d118 6
a123 6
     * Adds a data table to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized data
     * @@param table the data table to visualize
a128 10
    /**
     * Adds a data table to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized data
     * @@param table the data table to visualize
     * @@param filter a filter Predicate determining which data Tuples in the
     * input table are visualized
     */
d135 1
a135 10

    /**
     * Adds a data table to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized data
     * @@param table the data table to visualize
     * @@param schema the data schema to use for the created VisualTable
     */
a139 11
    /**
     * Adds a data table to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized data
     * @@param table the data table to visualize
     * @@param filter a filter Predicate determining which data Tuples in the
     * input table are visualized
     * @@param schema the data schema to use for the created VisualTable
     */
a150 10
    /**
     * Adds a graph to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized graph. The nodes
     * and edges will be available in the "group.nodes" and "group.edges"
     * subgroups.
     * @@param graph the graph to visualize
     */
a154 12
    /**
     * Adds a graph to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized graph. The nodes
     * and edges will be available in the "group.nodes" and "group.edges"
     * subgroups.
     * @@param graph the graph to visualize
     * @@param filter a filter Predicate determining which data Tuples in the
     * input graph are visualized
     */
a158 14
    /**
     * Adds a graph to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized graph. The nodes
     * and edges will be available in the "group.nodes" and "group.edges"
     * subgroups.
     * @@param graph the graph to visualize
     * @@param filter a filter Predicate determining which data Tuples in the
     * input graph are visualized
     * @@param nodeSchema the data schema to use for the visual node table
     * @@param edgeSchema the data schema to use for the visual edge table
     */
a186 10
    /**
     * Adds a tree to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized tree. The nodes
     * and edges will be available in the "group.nodes" and "group.edges"
     * subgroups.
     * @@param tree the tree to visualize
     */
a190 12
    /**
     * Adds a tree to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized tree. The nodes
     * and edges will be available in the "group.nodes" and "group.edges"
     * subgroups.
     * @@param tree the tree to visualize
     * @@param filter a filter Predicate determining which data Tuples in the
     * input graph are visualized
     */
a194 14
    /**
     * Adds a tree to this visualization, using the given data group
     * name. A visual abstraction of the data will be created and registered
     * with the visualization. An exception will be thrown if the group name
     * is already in use.
     * @@param group the data group name for the visualized tree. The nodes
     * and edges will be available in the "group.nodes" and "group.edges"
     * subgroups.
     * @@param tree the tree to visualize
     * @@param filter a filter Predicate determining which data Tuples in the
     * input graph are visualized
     * @@param nodeSchema the data schema to use for the visual node table
     * @@param edgeSchema the data schema to use for the visual edge table
     */
a221 7
    /**
     * Add a group of aggregates to this visualization. Aggregates are
     * used to visually represent groups of VisualItems.
     * @@param group the data group name for the aggregates.
     * @@return the generated AggregateTable
     * @@see prefuse.visual.AggregateTable
     */
a225 8
    /**
     * Add a group of aggregates to this visualization. Aggregates are
     * used to visually represent groups of VisualItems.
     * @@param group the data group name for the aggregates.
     * @@param schema the data schema to use for the AggregateTable
     * @@return the generated AggregateTable
     * @@see prefuse.visual.AggregateTable
     */
a231 15
    /**
     * Add a derived table, a VisualTable that is cascaded from an
     * existing VisualTable. This is useful for creating VisualItems
     * that inherit a set of visual properties from another group of
     * VisualItems. This might be used, for example, in the creation
     * of small multiples where only a few visual attributes vary
     * across the multiples.
     * @@param group the data group to use for the derived table
     * @@param source the source data group to derive from
     * @@param filter a Predicate filter indicating which tuples of the
     * source group should be inheritable by the new group
     * @@param override a data schema indicating which data fields
     * should not be inherited, but managed locally by the derived group
     * @@return the derived VisualTable
     */
a241 13
    /**
     * Add a group of decorators to an existing visual data group. Decorators
     * are VisualItem instances intended to "decorate" another VisualItem,
     * such as providing a label or dedicated interactive control, and are
     * realizeed as {@@link prefuse.visual.DecoratorItem} instances that provide
     * access to the decorated item in addition to the standard VisualItem
     * properties. The generated table is created using the
     * {@@link #addDerivedTable(String, String, Predicate, Schema)} method,
     * but with no VisualItem properties inherited from the source group.
     * @@param group the data group to use for the decorators
     * @@param source the source data group to decorate
     * @@return the generated VisualTable of DecoratorItem instances
     */
a245 14
    /**
     * Add a group of decorators to an existing visual data group. Decorators
     * are VisualItem instances intended to "decorate" another VisualItem,
     * such as providing a label or dedicated interactive control, and are
     * realizeed as {@@link prefuse.visual.DecoratorItem} instances that provide
     * access to the decorated item in addition to the standard VisualItem
     * properties.
     * @@param group the data group to use for the decorators
     * @@param source the source data group to decorate
     * @@param schema schema indicating which variables should <b>not</b> be
     * inherited from the source data group and instead be managed locally
     * by the generated VisualTable
     * @@return the generated VisualTable of DecoratorItem instances
     */
a249 13
    /**
     * Add a group of decorators to an existing visual data group. Decorators
     * are VisualItem instances intended to "decorate" another VisualItem,
     * such as providing a label or dedicated interactive control, and are
     * realizeed as {@@link prefuse.visual.DecoratorItem} instances that provide
     * access to the decorated item in addition to the standard VisualItem
     * properties.
     * @@param group the data group to use for the decorators
     * @@param source the source data group to decorate
     * @@param filter a Predicate filter indicating which tuples of the
     * source group should be inheritable by the new group
     * @@return the generated VisualTable of DecoratorItem instances
     */
a257 16
    /**
     * Add a group of decorators to an existing visual data group. Decorators
     * are VisualItem instances intended to "decorate" another VisualItem,
     * such as providing a label or dedicated interactive control, and are
     * realizeed as {@@link prefuse.visual.DecoratorItem} instances that provide
     * access to the decorated item in addition to the standard VisualItem
     * properties.
     * @@param group the data group to use for the decorators
     * @@param source the source data group to decorate
     * @@param filter a Predicate filter indicating which tuples of the
     * source group should be inheritable by the new group
     * @@param schema schema indicating which variables should <b>not</b> be
     * inherited from the source data group and instead be managed locally
     * by the generated VisualTable
     * @@return the generated VisualTable of DecoratorItem instances
     */
a296 5
    /**
     * Get the source data TupleSet backing the given visual data group.
     * @@return the backing source data set, or null if there is no such
     * data set
     */
a300 7
    /**
     * Get the Tuple from a backing source data set that corresponds most
     * closely to the given VisualItem.
     * @@param item the VisualItem for which to retreive the source tuple
     * @@return the data source tuple, or null if no such tuple could
     * be found
     */
a303 1
        if ( source == null ) return null;
a307 5
    /**
     * Get the TupleSet associated with the given data group name. 
     * @@param group a visual data group name
     * @@return the data group TupleSet
     */
a314 7
    /**
     * Indicates if a given VisualItem is contained in the given visual
     * data group.
     * @@param item the VisualItem instance
     * @@param group the data group to check for containment
     * @@return true if the VisualItem is in the group, false otherwise
     */
a324 6
    /**
     * Add a new secondary, or focus, group to this visualization. By
     * default the added group is an instance of
     * {@@link prefuse.data.tuple.DefaultTupleSet}.
     * @@param group the name of the focus group to add
     */
d328 1
a328 6

    /**
     * Add a new secondary, or focus, group to this visualization.
     * @@param group the name of the focus group to add
     * @@param tset the TupleSet for the focus group
     */
d333 4
d340 4
a343 5
    /**
     * Get the size of the given visual data group.
     * @@param group the visual data group
     * @@return the size (number of tuples) of the group
     */
a348 6
    /**
     * Retrieve the visual data group of the given group name. Only primary
     * visual groups will be considered.
     * @@param group the visual data group
     * @@return the requested data group, or null if not found
     */
a352 6
    /**
     * Retrieve the focus data group of the given group name. Only secondary,
     * or focus, groups will be considered.
     * @@param group the focus data group
     * @@return the requested data group, or null if not found
     */
a356 6
    /**
     * Invalidate the bounds of all VisualItems in the given group. This
     * will cause the bounds to be recomputed for all items upon the next
     * redraw.
     * @@param group the visual data group to invalidate
     */
a369 5
    /**
     * Invalidate the bounds of all VisualItems in this visualization. This
     * will cause the bounds to be recomputed for all items upon the next
     * redraw.
     */
d375 2
a376 2
     * Get an iterator over all visible items.
     * @@return an iterator over all visible items.
d383 3
a385 3
     * Get an iterator over all visible items in the specified group.
     * @@param group the visual data group name
     * @@return an iterator over all visible items in the specified group
d392 2
a393 2
     * Get an iterator over all items, visible or not.
     * @@return an iterator over all items, visible or not.
d400 2
a401 5
     * Get an iterator over all items which match the given
     * Predicate filter.
     * @@param filter a Predicate indicating which items should be included
     * in the iteration
     * @@return a filtered iterator over VisualItems
d423 3
a425 3
     * Get an iterator over all items in the specified group.
     * @@param group the visual data group name
     * @@return an iterator over all items in the specified group.
a430 11
    /**
     * Get an iterator over all items in the given group which match the given
     * filter expression.
     * @@param group the visual data group to iterate over
     * @@param expr an expression string that should parse to a Predicate
     * indicating which items should be included in the iteration. The input
     * string will be parsed using the
     * {@@link prefuse.data.expression.parser.ExpressionParser} class. If a
     * parse error occurs, an empty iterator is returned.
     * @@return a filtered iterator over VisualItems
     */
d439 3
a441 6
     * Get an iterator over all items in the given group which match the given
     * Predicate filter.
     * @@param group the visual data group to iterate over
     * @@param filter a Predicate indicating which items should be included in
     * the iteration.
     * @@return a filtered iterator over VisualItems
a454 8
    /**
     * Set a data field value for all items in a given data group matching a
     * given filter predicate.
     * @@param group the visual data group name
     * @@param p the filter predicate determining which items to modify
     * @@param field the data field / column name to set
     * @@param val the value to set
     */
a462 7
    /**
     * Sets the visbility status for all items in a given data group matching
     * a given filter predicate.
     * @@param group the visual data group name
     * @@param p the filter predicate determining which items to modify
     * @@param value the visibility value to set
     */
d470 1
a470 8

    /**
     * Sets the interactivity status for all items in a given data group
     * matching a given filter predicate.
     * @@param group the visual data group name
     * @@param p the filter predicate determining which items to modify
     * @@param value the interactivity value to set
     */
a481 6
    /**
     * Add a data processing Action to this Visualization. The Action will be
     * updated to use this Visualization in its data processing.
     * @@param name the name of the Action
     * @@param action the Action to add
     */
a487 5
    /**
     * Get the data processing Action with the given name.
     * @@param name the name of the Action
     * @@return the requested Action, or null if the name was not found
     */
a491 8
    /**
     * Schedule the Action with the given name to run immediately. The running
     * of all Actions is managed by the
     * {@@link prefuse.activity.ActivityManager}, which runs in a dedicated
     * thread.
     * @@param action the name of the Action to run
     * @@return the Action scheduled to run
     */
d495 1
a495 11

    /**
     * Schedule the Action with the given name to run after the specified
     * delay. The running of all Actions is managed by the
     * {@@link prefuse.activity.ActivityManager}, which runs in a dedicated
     * thread.
     * @@param action the name of the Action to run
     * @@param delay the amount of time to wait, in milliseconds, before
     * running the Action
     * @@return the Action scheduled to run
     */
a499 10
    /**
     * Schedule the Action with the given name to run at the specified
     * time. The running of all Actions is managed by the
     * {@@link prefuse.activity.ActivityManager}, which runs in a dedicated
     * thread.
     * @@param action the name of the Action to run
     * @@param startTime the absolute system time, in milliseconds since the
     * epoch, at which to run the Action.
     * @@return the Action scheduled to run
     */
a503 11
    /**
     * Schedule the Action with the given name to run after another Action
     * finishes running. This relationship will only hold for one round of
     * scheduling. If the "before" Action is run a second time, the "after"
     * action will not be run a second time. The running of all Actions is
     * managed by the {@@link prefuse.activity.ActivityManager}, which runs
     * in a dedicated thread.
     * @@param before the name of the Action to wait for
     * @@param after the name of the Action to run after the first one finishes
     * @@return the Action scheduled to run after the first one finishes
     */
a507 9
    /**
     * Schedule the Action with the given name to always run after another Action
     * finishes running. The running of all Actions is managed by the
     * {@@link prefuse.activity.ActivityManager}, which runs in a dedicated
     * thread.
     * @@param before the name of the Action to wait for
     * @@param after the name of the Action to run after the first one finishes
     * @@return the Action scheduled to always run after the first one finishes
     */
a511 5
    /**
     * Cancel the Action with the given name, if it has been scheduled.
     * @@param action the name of the Action to cancel
     * @@return the canceled Action
     */
a518 6
    /**
     * Set the RendererFactory used by this Visualization. The RendererFactory
     * is responsible for providing the Renderer instances used to draw
     * the VisualItems.
     * @@param rf the RendererFactory to use.
     */
a523 4
    /**
     * Get the RendererFactory used by this Visualization.
     * @@return this Visualization's RendererFactory
     */
a527 7
    /**
     * Get the renderer for the given item. Consults this visualization's
     * {@@link prefuse.render.RendererFactory} and returns the result.
     * @@param item the item to retreive the renderer for
     * @@return the {@@link prefuse.render.Renderer} for drawing the
     * given item
     */
a535 4
    /**
     * Issue a repaint request, causing all displays associated with this
     * visualization to be repainted.
     */
a545 5
    /**
     * Get the bounding rectangle for all items in the given group.
     * @@param group the visual data group
     * @@return the bounding box of the items
     */
a549 7
    /**
     * Get the bounding rectangle for all items in the given group.
     * @@param group the visual data group name
     * @@param r a rectangle in which to store the computed bounding box
     * @@return the input rectangle r, updated to hold the computed
     * bounding box
     */
a565 4
    /**
     * Get the number of displays associated with this visualization.
     * @@return the number of displays
     */
a569 5
    /**
     * Add a display to this visualization. Called automatically by the
     * {@@link prefuse.Display#setVisualization(Visualization)} method.
     * @@param display the Display to add
     */
a573 6
    /**
     * Get the display at the given list index. Displays are numbered by the
     * order in which they are added to this visualization.
     * @@param idx the list index
     * @@return the Display at the given index
     */
a577 5
    /**
     * Remove a display from this visualization.
     * @@param display the display to remove
     * @@return true if the display was removed, false if it was not found
     */
a581 6
    /**
     * Report damage to associated displays, indicating a region that will need
     * to be redrawn.
     * @@param item the item responsible for the damage
     * @@param region the damaged region, in item-space coordinates
     */
@


1.1.2.6
log
@Standardized @@author tag contents
Added toggle for enabling/disabling damage/redraw
EdgeRenderer now cleanly pulls edge widths from the size field
Refactored TupleManager to a single reusable class
@
text
@d21 2
a23 1
import prefuse.data.tuple.TupleManager;
d39 3
a41 3
import prefuse.visual.tuple.TableDecoratorItem;
import prefuse.visual.tuple.TableEdgeItem;
import prefuse.visual.tuple.TableNodeItem;
d403 2
a404 2
        TupleManager ntm = new TupleManager(nt, vg, TableNodeItem.class);
        TupleManager etm = new TupleManager(et, vg, TableEdgeItem.class);
d474 2
a475 2
        TupleManager ntm = new TupleManager(nt, vt, TableNodeItem.class);
        TupleManager etm = new TupleManager(et, vt, TableEdgeItem.class);
d585 1
a585 1
        t.setTupleManager(new TupleManager(t, null, TableDecoratorItem.class));
d609 1
a609 1
        t.setTupleManager(new TupleManager(t, null, TableDecoratorItem.class));
@


1.1.2.7
log
@Intermediate commit in run-up to release.
Upgraded Tuple, Node, and Edge to the data package.
Renamed "Function" classes to "Action" classes.
Added Shape to VisualItem Schema.
Added ShapeActions, moved Shape constants to Constants interface.
Added Background image handling to the Display class.
Added social network data file.
@
text
@a16 1
import prefuse.data.Tuple;
d21 1
d71 2
a72 2
 * visual abstraction. Similarly, all {@@link prefuse.data.Tuple},
 * {@@link prefuse.data.Node}, or {@@link prefuse.data.Edge}
@


