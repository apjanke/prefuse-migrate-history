head	2.1;
access;
symbols
	java_1_5:2.1.0.4
	Root_java_1_5:2.1
	beta:2.1.0.2
	beta-20080113:2.1
	beta-20071021:2.1
	beta-20060220:2.1
	beta-20060209:2.0;
locks; strict;
comment	@# @;


2.1
date	2006.02.17.18.08.28;	author jheer;	state Exp;
branches
	2.1.4.1;
next	2.0;

2.0
date	2006.02.12.18.23.45;	author jheer;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.30.09.13.30;	author jheer;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2005.12.30.09.13.30;	author jheer;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2006.01.16.20.07.41;	author jheer;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2006.01.23.22.08.47;	author jheer;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2006.01.23.23.07.17;	author jheer;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2006.01.30.09.08.04;	author jheer;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2006.02.01.19.22.43;	author jheer;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2006.02.02.19.01.50;	author jheer;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2006.02.09.05.12.45;	author jheer;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2006.02.09.10.33.59;	author jheer;	state Exp;
branches;
next	;

2.1.4.1
date	2008.01.23.23.55.43;	author jogiles;	state Exp;
branches;
next	2.1.4.2;

2.1.4.2
date	2008.02.23.21.21.02;	author amarsden;	state Exp;
branches;
next	2.1.4.3;

2.1.4.3
date	2008.02.26.05.02.53;	author amarsden;	state Exp;
branches;
next	2.1.4.4;

2.1.4.4
date	2008.02.28.01.09.32;	author amarsden;	state Exp;
branches;
next	2.1.4.5;

2.1.4.5
date	2008.03.03.05.19.17;	author amarsden;	state Exp;
branches;
next	2.1.4.6;

2.1.4.6
date	2008.03.10.09.20.31;	author amarsden;	state Exp;
branches;
next	2.1.4.7;

2.1.4.7
date	2008.03.11.04.14.47;	author amarsden;	state Exp;
branches;
next	2.1.4.8;

2.1.4.8
date	2008.04.14.05.06.09;	author amarsden;	state Exp;
branches;
next	2.1.4.9;

2.1.4.9
date	2008.04.15.04.57.28;	author amarsden;	state Exp;
branches;
next	2.1.4.10;

2.1.4.10
date	2009.06.24.03.32.53;	author jogiles;	state Exp;
branches;
next	;


desc
@@


2.1
log
@Added "stroke" visual property for configuring line drawing.
EdgeRenderer now draws directed edges (more) correctly, and allow parameterization of the arrow head size.
@
text
@package prefuse.render;

import java.awt.BasicStroke;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.CubicCurve2D;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import prefuse.Constants;
import prefuse.util.ColorLib;
import prefuse.util.GraphicsLib;
import prefuse.util.StrokeLib;
import prefuse.visual.EdgeItem;
import prefuse.visual.VisualItem;


/**
 * <p>Renderer that draws edges as lines connecting nodes. Both
 * straight and curved lines are supported. Curved lines are drawn using
 * cubic Bezier curves. Subclasses can override the
 * {@@link #getCurveControlPoints(EdgeItem, Point2D[], double, double, double, double)}
 * method to provide custom control point assignment for such curves.</p>
 * 
 * <p>This class also supports arrows for directed edges. See the
 * {@@link #setArrowType(int)} method for more.</p>
 * 
 * @@version 1.0
 * @@author <a href="http://jheer.org">jeffrey heer</a>
 */
public class EdgeRenderer extends AbstractShapeRenderer {
    
    public static final String EDGE_TYPE = "edgeType";
    
    protected static final double HALF_PI = Math.PI / 2;
    
    protected Line2D       m_line  = new Line2D.Float();
    protected CubicCurve2D m_cubic = new CubicCurve2D.Float();

    protected int     m_edgeType  = Constants.EDGE_TYPE_LINE;
    protected int     m_xAlign1   = Constants.CENTER;
    protected int     m_yAlign1   = Constants.CENTER;
    protected int     m_xAlign2   = Constants.CENTER;
    protected int     m_yAlign2   = Constants.CENTER;
    protected double  m_width     = 1;
    protected float   m_curWidth  = 1;
    protected Point2D m_tmpPoints[]  = new Point2D[2];
    protected Point2D m_ctrlPoints[] = new Point2D[2];
    protected Point2D m_isctPoints[] = new Point2D[2];
    
    // arrow head handling
    protected int     m_edgeArrow   = Constants.EDGE_ARROW_FORWARD;
    protected int     m_arrowWidth  = 8;
    protected int     m_arrowHeight = 12;
    protected Polygon m_arrowHead   = updateArrowHead(
                                        m_arrowWidth, m_arrowHeight);
    protected AffineTransform m_arrowTrans = new AffineTransform();
    protected Shape   m_curArrow;

    /**
     * Create a new EdgeRenderer.
     */
    public EdgeRenderer() {
        m_tmpPoints[0]  = new Point2D.Float();
        m_tmpPoints[1]  = new Point2D.Float();
        m_ctrlPoints[0] = new Point2D.Float();
        m_ctrlPoints[1] = new Point2D.Float();      
        m_isctPoints[0] = new Point2D.Float();
        m_isctPoints[1] = new Point2D.Float();      
    }

    /**
     * Create a new EdgeRenderer with the given edge type.
     * @@param edgeType the edge type, one of
     * {@@link prefuse.Constants#EDGE_TYPE_LINE} or
     * {@@link prefuse.Constants#EDGE_TYPE_CURVE}.
     */
    public EdgeRenderer(int edgeType) {
        this(edgeType, Constants.EDGE_ARROW_FORWARD);
    }
    
    /**
     * Create a new EdgeRenderer with the given edge and arrow types.
     * @@param edgeType the edge type, one of
     * {@@link prefuse.Constants#EDGE_TYPE_LINE} or
     * {@@link prefuse.Constants#EDGE_TYPE_CURVE}.
     * @@param arrowType the arrow type, one of
     * {@@link prefuse.Constants#EDGE_ARROW_FORWARD},
     * {@@link prefuse.Constants#EDGE_ARROW_REVERSE}, or
     * {@@link prefuse.Constants#EDGE_ARROW_NONE}.
     * @@see #setArrowType(int)
     */
    public EdgeRenderer(int edgeType, int arrowType) {
        this();
        setEdgeType(edgeType);
        setArrowType(arrowType);
    }
    
    /**
     * @@see prefuse.render.AbstractShapeRenderer#getRenderType(prefuse.visual.VisualItem)
     */
    public int getRenderType(VisualItem item) {
        return RENDER_TYPE_DRAW;
    }
    
    /**
     * @@see prefuse.render.AbstractShapeRenderer#getRawShape(prefuse.visual.VisualItem)
     */
    protected Shape getRawShape(VisualItem item) {
        EdgeItem   edge = (EdgeItem)item;
        VisualItem item1 = edge.getSourceItem();
        VisualItem item2 = edge.getTargetItem();
        
        int type = m_edgeType;
        
        getAlignedPoint(m_tmpPoints[0], item1.getBounds(),
                        m_xAlign1, m_yAlign1);
        getAlignedPoint(m_tmpPoints[1], item2.getBounds(),
                        m_xAlign2, m_yAlign2);
        m_curWidth = (float)(m_width * getLineWidth(item));
        
        // create the arrow head, if needed
        EdgeItem e = (EdgeItem)item;
        if ( e.isDirected() && m_edgeArrow != Constants.EDGE_ARROW_NONE ) {
            // get starting and ending edge endpoints
            boolean forward = (m_edgeArrow == Constants.EDGE_ARROW_FORWARD);
            Point2D start = null, end = null;
            start = m_tmpPoints[forward?0:1];
            end   = m_tmpPoints[forward?1:0];
            
            // compute the intersection with the target bounding box
            VisualItem dest = forward ? e.getTargetItem() : e.getSourceItem();
            int i = GraphicsLib.intersectLineRectangle(start, end,
                    dest.getBounds(), m_isctPoints);
            if ( i > 0 ) end = m_isctPoints[0];
            
            // create the arrow head shape
            AffineTransform at = getArrowTrans(start, end, m_curWidth);
            m_curArrow = at.createTransformedShape(m_arrowHead);
            
            // update the endpoints for the edge shape
            // need to bias this by arrow head size
            Point2D lineEnd = m_tmpPoints[forward?1:0]; 
            lineEnd.setLocation(0, -m_arrowHeight);
            at.transform(lineEnd, lineEnd);
        } else {
            m_curArrow = null;
        }
        
        // create the edge shape
        Shape shape = null;
        double n1x = m_tmpPoints[0].getX();
        double n1y = m_tmpPoints[0].getY();
        double n2x = m_tmpPoints[1].getX();
        double n2y = m_tmpPoints[1].getY();
        switch ( type ) {
            case Constants.EDGE_TYPE_LINE:          
                m_line.setLine(n1x, n1y, n2x, n2y);
                shape = m_line;
                break;
            case Constants.EDGE_TYPE_CURVE:
                getCurveControlPoints(edge, m_ctrlPoints,n1x,n1y,n2x,n2y);
                m_cubic.setCurve(n1x, n1y,
                                m_ctrlPoints[0].getX(), m_ctrlPoints[0].getY(),
                                m_ctrlPoints[1].getX(), m_ctrlPoints[1].getY(),
                                n2x, n2y);
                shape = m_cubic;
                break;
            default:
                throw new IllegalStateException("Unknown edge type");
        }
        
        // return the edge shape
        return shape;
    }

    /**
     * @@see prefuse.render.Renderer#render(java.awt.Graphics2D, prefuse.visual.VisualItem)
     */
    public void render(Graphics2D g, VisualItem item) {
        // render the edge line
        super.render(g, item);
        // render the edge arrow head, if appropriate
        if ( m_curArrow != null ) {
            g.setPaint(ColorLib.getColor(item.getFillColor()));
            g.fill(m_curArrow);
        }
    }

    /**
     * Returns an affine transformation that maps the arrowhead shape
     * to the position and orientation specified by the provided
     * line segment end points.
     */
    protected AffineTransform getArrowTrans(Point2D p1, Point2D p2, 
                                            double width)
    {
        m_arrowTrans.setToTranslation(p2.getX(), p2.getY());
        m_arrowTrans.rotate(-HALF_PI + 
            Math.atan2(p2.getY()-p1.getY(), p2.getX()-p1.getX()));
        if ( width > 1 ) {
            double scalar = width/4;
            m_arrowTrans.scale(scalar, scalar);
        }
        return m_arrowTrans;
    }
    
    /**
     * Update the dimensions of the arrow head, creating a new
     * arrow head if necessary. The return value is also set
     * as the member variable <code>m_arrowHead</code>
     * @@param w the width of the untransformed arrow head base, in pixels
     * @@param h the height of the untransformed arrow head, in pixels
     * @@return the untransformed arrow head shape
     */
    protected Polygon updateArrowHead(int w, int h) {
        if ( m_arrowHead == null ) {
            m_arrowHead = new Polygon();
        } else {
            m_arrowHead.reset();
        }
        m_arrowHead.addPoint(0, 0);
        m_arrowHead.addPoint(-w/2, -h);
        m_arrowHead.addPoint( w/2, -h);
        m_arrowHead.addPoint(0, 0);
        return m_arrowHead;
    }
        
    

    /**
     * @@see prefuse.render.AbstractShapeRenderer#getTransform(prefuse.visual.VisualItem)
     */
    protected AffineTransform getTransform(VisualItem item) {
        return null;
    }
    
    /**
     * @@see prefuse.render.Renderer#locatePoint(java.awt.geom.Point2D, prefuse.visual.VisualItem)
     */
    public boolean locatePoint(Point2D p, VisualItem item) {
        Shape s = getShape(item);
        if ( s == null ) {
            return false;
        } else {
            double width = Math.max(2, getLineWidth(item));
            double halfWidth = width/2.0;
            return s.intersects(p.getX()-halfWidth,
                                p.getY()-halfWidth,
                                width,width);
        }
    }
    
    /**
     * @@see prefuse.render.Renderer#setBounds(prefuse.visual.VisualItem)
     */
    public void setBounds(VisualItem item) {
        if ( !m_manageBounds ) return;
        Shape shape = getShape(item);
        if ( shape == null ) {
            item.setBounds(item.getX(), item.getY(), 0, 0);
            return;
        }
        GraphicsLib.setBounds(item, shape, getStroke(item));
        if ( m_curArrow != null ) {
            Rectangle2D bbox = (Rectangle2D)item.get(VisualItem.BOUNDS);
            Rectangle2D.union(bbox, m_curArrow.getBounds2D(), bbox);
        }
    }

    /**
     * Returns the line width to be used for this VisualItem. By default,
     * returns the base width value set using the {@@link #setDefaultLineWidth(double)}
     * method, scaled by the item size returned by
     * {@@link VisualItem#getSize()}. Subclasses can override this method to
     * perform custom line width determination, however, the preferred
     * method is to change the item size value itself.
     * @@param item the VisualItem for which to determine the line width
     * @@return the desired line width, in pixels
     */
    protected double getLineWidth(VisualItem item) {
        return item.getSize();
    }
    
    /**
     * Returns the stroke value returned by {@@link VisualItem#getStroke()},
     * scaled by the current line width
     * determined by the {@@link #getLineWidth(VisualItem)} method. Subclasses
     * may override this method to perform custom stroke assignment, but should
     * respect the line width paremeter stored in the {@@link #m_curWidth}
     * member variable, which caches the result of <code>getLineWidth</code>.
     * @@see prefuse.render.AbstractShapeRenderer#getStroke(prefuse.visual.VisualItem)
     */
    protected BasicStroke getStroke(VisualItem item) {
        return StrokeLib.getDerivedStroke(item.getStroke(), m_curWidth);
    }

    /**
     * Determines the control points to use for cubic (Bezier) curve edges. 
     * Override this method to provide custom curve specifications.
     * To reduce object initialization, the entries of the Point2D array are
     * already initialized, so use the <tt>Point2D.setLocation()</tt> method rather than
     * <tt>new Point2D.Double()</tt> to more efficiently set custom control points.
     * @@param eitem the EdgeItem we are determining the control points for
     * @@param cp array of Point2D's (length >= 2) in which to return the control points
     * @@param x1 the x co-ordinate of the first node this edge connects to
     * @@param y1 the y co-ordinate of the first node this edge connects to
     * @@param x2 the x co-ordinate of the second node this edge connects to
     * @@param y2 the y co-ordinate of the second node this edge connects to
     */
    protected void getCurveControlPoints(EdgeItem eitem, Point2D[] cp, 
                    double x1, double y1, double x2, double y2) 
    {
        double dx = x2-x1, dy = y2-y1;      
        cp[0].setLocation(x1+2*dx/3,y1);
        cp[1].setLocation(x2-dx/8,y2-dy/8);
    }

    /**
     * Helper method, which calculates the top-left co-ordinate of a rectangle
     * given the rectangle's alignment.
     */
    protected static void getAlignedPoint(Point2D p, Rectangle2D r, int xAlign, int yAlign) {
        double x = r.getX(), y = r.getY(), w = r.getWidth(), h = r.getHeight();
        if ( xAlign == Constants.CENTER ) {
            x = x+(w/2);
        } else if ( xAlign == Constants.RIGHT ) {
            x = x+w;
        }
        if ( yAlign == Constants.CENTER ) {
            y = y+(h/2);
        } else if ( yAlign == Constants.BOTTOM ) {
            y = y+h;
        }
        p.setLocation(x,y);
    }

    /**
     * Returns the type of the drawn edge. This is one of
     * {@@link prefuse.Constants#EDGE_TYPE_LINE} or
     * {@@link prefuse.Constants#EDGE_TYPE_CURVE}.
     * @@return the edge type
     */
    public int getEdgeType() {
        return m_edgeType;
    }
    
    /**
     * Sets the type of the drawn edge. This must be one of
    * {@@link prefuse.Constants#EDGE_TYPE_LINE} or
    * {@@link prefuse.Constants#EDGE_TYPE_CURVE}.
     * @@param type the new edge type
     */
    public void setEdgeType(int type) {
        if ( type < 0 || type >= Constants.EDGE_TYPE_COUNT )
            throw new IllegalArgumentException(
                    "Unrecognized edge curve type: "+type);
        m_edgeType = type;
    }
    
    /**
     * Returns the type of the drawn edge. This is one of
     * {@@link prefuse.Constants#EDGE_ARROW_FORWARD},
     * {@@link prefuse.Constants#EDGE_ARROW_REVERSE}, or
     * {@@link prefuse.Constants#EDGE_ARROW_NONE}.
     * @@return the edge type
     */
    public int getArrowType() {
        return m_edgeArrow;
    }
    
    /**
     * Sets the type of the drawn edge. This is either
     * {@@link prefuse.Constants#EDGE_ARROW_NONE} for no edge arrows,
     * {@@link prefuse.Constants#EDGE_ARROW_FORWARD} for arrows from source to
     *  target on directed edges, or
     * {@@link prefuse.Constants#EDGE_ARROW_REVERSE} for arrows from target to
     *  source on directed edges.
     * @@param type the new arrow type
     */
    public void setArrowType(int type) {
        if ( type < 0 || type >= Constants.EDGE_ARROW_COUNT )
            throw new IllegalArgumentException(
                    "Unrecognized edge arrow type: "+type);
        m_edgeArrow = type;
    }
    
    /**
     * Sets the dimensions of an arrow head for a directed edge. This specifies
     * the pixel dimensions when both the zoom level and the size factor
     * (a combination of item size value and default stroke width) are 1.0.
     * @@param width the untransformed arrow head width, in pixels. This
     * specifies the span of the base of the arrow head.
     * @@param height the untransformed arrow head height, in pixels. This
     * specifies the distance from the point of the arrow to its base.
     */
    public void setArrowHeadSize(int width, int height) {
        m_arrowWidth = width;
        m_arrowHeight = height;
        m_arrowHead = updateArrowHead(width, height);
    }
    
    /**
     * Get the height of the untransformed arrow head. This is the distance,
     * in pixels, from the tip of the arrow to its base.
     * @@return the default arrow head height
     */
    public int getArrowHeadHeight() {
        return m_arrowHeight;
    }

    /**
     * Get the width of the untransformed arrow head. This is the length,
     * in pixels, of the base of the arrow head.
     * @@return the default arrow head width
     */
    public int getArrowHeadWidth() {
        return m_arrowWidth;
    }
    
    /**
     * Get the horizontal aligment of the edge mount point with the first node.
     * @@return the horizontal alignment, one of {@@link prefuse.Constants#LEFT},
     * {@@link prefuse.Constants#RIGHT}, or {@@link prefuse.Constants#CENTER}.
     */
    public int getHorizontalAlignment1() {
        return m_xAlign1;
    }
    
    /**
     * Get the vertical aligment of the edge mount point with the first node.
     * @@return the vertical alignment, one of {@@link prefuse.Constants#TOP},
     * {@@link prefuse.Constants#BOTTOM}, or {@@link prefuse.Constants#CENTER}.
     */
    public int getVerticalAlignment1() {
        return m_yAlign1;
    }

    /**
     * Get the horizontal aligment of the edge mount point with the second
     * node.
     * @@return the horizontal alignment, one of {@@link prefuse.Constants#LEFT},
     * {@@link prefuse.Constants#RIGHT}, or {@@link prefuse.Constants#CENTER}.
     */
    public int getHorizontalAlignment2() {
        return m_xAlign2;
    }
    
    /**
     * Get the vertical aligment of the edge mount point with the second node.
     * @@return the vertical alignment, one of {@@link prefuse.Constants#TOP},
     * {@@link prefuse.Constants#BOTTOM}, or {@@link prefuse.Constants#CENTER}.
     */
    public int getVerticalAlignment2() {
        return m_yAlign2;
    }
    
    /**
     * Set the horizontal aligment of the edge mount point with the first node.
     * @@param align the horizontal alignment, one of 
     * {@@link prefuse.Constants#LEFT}, {@@link prefuse.Constants#RIGHT}, or
     * {@@link prefuse.Constants#CENTER}.
     */
    public void setHorizontalAlignment1(int align) {
        m_xAlign1 = align;
    }
    
    /**
     * Set the vertical aligment of the edge mount point with the first node.
     * @@param align the vertical alignment, one of
     * {@@link prefuse.Constants#TOP}, {@@link prefuse.Constants#BOTTOM}, or
     * {@@link prefuse.Constants#CENTER}.
     */
    public void setVerticalAlignment1(int align) {
        m_yAlign1 = align;
    }

    /**
     * Set the horizontal aligment of the edge mount point with the second
     * node.
     * @@param align the horizontal alignment, one of
     * {@@link prefuse.Constants#LEFT}, {@@link prefuse.Constants#RIGHT}, or
     * {@@link prefuse.Constants#CENTER}.
     */
    public void setHorizontalAlignment2(int align) {
        m_xAlign2 = align;
    }
    
    /**
     * Set the vertical aligment of the edge mount point with the second node.
     * @@param align the vertical alignment, one of
     * {@@link prefuse.Constants#TOP}, {@@link prefuse.Constants#BOTTOM}, or
     * {@@link prefuse.Constants#CENTER}.
     */
    public void setVerticalAlignment2(int align) {
        m_yAlign2 = align;
    }
    
    /**
     * Sets the default width of lines. This width value will
     * be scaled by the value of an item's size data field. The default
     * base width is 1.
     * @@param w the desired default line width, in pixels
     */
    public void setDefaultLineWidth(double w) {
        m_width = w;
    }
    
    /**
     * Gets the default width of lines. This width value that will
     * be scaled by the value of an item's size data field. The default
     * base width is 1.
     * @@return the default line width, in pixels
     */
    public double getDefaultLineWidth() {
        return m_width;
    }

} // end of class EdgeRenderer
@


2.1.4.1
log
@First import of a Java 1.5-targetted version of prefuse.
@
text
@a8 2
import java.awt.geom.Ellipse2D;
import java.awt.geom.GeneralPath;
a11 2
import java.util.ArrayList;
import java.util.List;
d13 1
a13 1
import prefuse.Alignment;
d27 1
a27 1
 *
d29 2
a30 2
 * {@@link #setArrowType(EdgeArrowType)} method for more.</p>
 *
d35 3
a37 15

	public static enum EdgeType {
		LINE, CURVE, CURVE_VIA_EDGE;
	}

	public static enum EdgeArrowType {
	    /** No arrows on edges */
	    NONE,
	    /** Arrows on edges pointing from source to target */
	    FORWARD,
	    /** Arrows on edges pointing from target to source */
	    REVERSE

	}

d39 1
a39 1

d43 5
a47 5
    protected EdgeType m_edgeType = EdgeType.LINE;
    protected Alignment     m_xAlign1   = Alignment.CENTER;
    protected Alignment     m_yAlign1   = Alignment.CENTER;
    protected Alignment     m_xAlign2   = Alignment.CENTER;
    protected Alignment     m_yAlign2   = Alignment.CENTER;
d53 1
a53 1

d55 1
a55 1
    protected EdgeArrowType m_edgeArrow   = EdgeArrowType.FORWARD;
d63 1
a63 3
    protected float splineSlack = 0.2f;

	/**
d70 1
a70 1
        m_ctrlPoints[1] = new Point2D.Float();
d72 1
a72 1
        m_isctPoints[1] = new Point2D.Float();
d77 3
a79 1
     * @@param edgeType the edge type
d81 2
a82 2
    public EdgeRenderer(EdgeType edgeType) {
        this(edgeType, EdgeArrowType.FORWARD);
d84 1
a84 1

d87 8
a94 3
     * @@param edgeType the edge type
     * @@param arrowType the arrow type
     * @@see #setArrowType(EdgeArrowType)
d96 1
a96 1
    public EdgeRenderer(EdgeType edgeType, EdgeArrowType arrowType) {
d101 1
a101 1

d105 2
a106 3
    @@Override
	public RenderType getRenderType(VisualItem<?> item) {
        return AbstractShapeRenderer.RenderType.DRAW;
d108 1
a108 1

d112 8
a119 8
    @@Override
	protected Shape getRawShape(VisualItem<?> item) {
        EdgeItem<?,?>   edge = (EdgeItem<?,?>)item;
        VisualItem<?> item1 = edge.getSourceItem();
        VisualItem<?> item2 = edge.getTargetItem();

        if(item1 != item2) {
        	GraphicsLib.getAlignedPoint(m_tmpPoints[0], item1.getBounds(),
d121 1
a121 1
        	GraphicsLib.getAlignedPoint(m_tmpPoints[1], item2.getBounds(),
a122 8
        } else {
        	// use the center of the item when the items are the same
        	GraphicsLib.getAlignedPoint(m_tmpPoints[0], item1.getBounds(),
                    Alignment.CENTER, Alignment.CENTER);
        	GraphicsLib.getAlignedPoint(m_tmpPoints[1], item2.getBounds(),
        			Alignment.CENTER, Alignment.CENTER);
        }

d124 1
a124 1

d126 2
a127 3
        EdgeItem<?,?> e = (EdgeItem<?,?>)item;

        if ( e.isDirected() && m_edgeArrow != EdgeArrowType.NONE ) {
d129 5
a133 4
            boolean forward = m_edgeArrow == EdgeArrowType.FORWARD;
            Point2D start = m_edgeType == EdgeType.CURVE_VIA_EDGE ? new Point2D.Double(e.getX(), e.getY()) : m_tmpPoints[forward?0:1];
            Point2D end   = m_tmpPoints[forward?1:0];

d135 1
a135 1
            VisualItem<?> dest = forward ? e.getTargetItem() : e.getSourceItem();
d138 2
a139 4
            if ( i > 0 ) {
				end = m_isctPoints[0];
			}

d143 1
a143 1

d146 1
a146 1
            Point2D lineEnd = m_tmpPoints[forward?1:0];
d152 1
a152 8

        // draw self-referencing edges
        if(item1 == item2) {
			Ellipse2D m_ellipse = new Ellipse2D.Double();
		    m_ellipse.setFrame(m_tmpPoints[0].getX(), m_tmpPoints[0].getY(), 40, 30);
		    return m_ellipse;
        }

d159 2
a160 3

		switch ( m_edgeType) {
            case LINE:
d164 1
a164 1
            case CURVE:
a171 38
            case CURVE_VIA_EDGE:

            	Point2D eLoc = new Point2D.Double(e.getX(), e.getY());

            	List<Float> splinePoints = new ArrayList<Float>();

            	splinePoints.add((float)n1x);
            	splinePoints.add((float)n1y);

            	Point2D[] intersect = new Point2D[2];
                if(GraphicsLib.intersectLineRectangle(eLoc, m_tmpPoints[0],
                        item1.getBounds(), intersect) > 0) {
                	splinePoints.add((float)intersect[0].getX());
                	splinePoints.add((float)intersect[0].getY());
                }

                splinePoints.add((float) e.getX());
                splinePoints.add((float) e.getY());

                if(GraphicsLib.intersectLineRectangle(eLoc, m_tmpPoints[1],
                        item2.getBounds(), intersect) > 0) {
                	splinePoints.add((float)intersect[0].getX());
                	splinePoints.add((float)intersect[0].getY());
                }

            	splinePoints.add((float)n2x);
            	splinePoints.add((float)n2y);

                float[] pts = new float[splinePoints.size()];

                int i = 0;
                for(float pt : splinePoints) {
                	pts[i++] = pt;
                }

            	GeneralPath gp = GraphicsLib.cardinalSpline(pts, splineSlack, false);
            	shape = gp;
            	break;
d175 1
a175 1

d183 1
a183 2
    @@Override
	public void render(Graphics2D g, VisualItem<?> item) {
d188 1
a188 1
            g.setPaint(ColorLib.getColor(item.getStrokeColor()));
d198 1
a198 1
    protected AffineTransform getArrowTrans(Point2D p1, Point2D p2,
d202 1
a202 1
        m_arrowTrans.rotate(-HALF_PI +
d210 1
a210 1

d231 2
a232 2


d237 1
a237 2
    @@Override
	protected AffineTransform getTransform(VisualItem<?> item) {
d240 1
a240 1

d244 1
a244 2
    @@Override
	public boolean locatePoint(Point2D p, VisualItem<?> item) {
d256 1
a256 1

d260 2
a261 6
    @@Override
	public void calculateBounds(VisualItem<?> item, Rectangle2D bounds) {
        if ( !m_manageBounds ) {
        	bounds.setRect(item.getX(), item.getY(), 0, 0);
			return;
		}
d264 2
a265 2
        	bounds.setRect(item.getX(), item.getY(), 0, 0);
			return;
d267 1
a267 1
        GraphicsLib.calculateBounds(item, shape, getStroke(item), bounds);
d269 2
a270 1
            Rectangle2D.union(bounds, m_curArrow.getBounds2D(), bounds);
d284 1
a284 1
    protected double getLineWidth(VisualItem<?> item) {
d287 1
a287 1

d297 1
a297 2
    @@Override
	protected BasicStroke getStroke(VisualItem<?> item) {
d302 1
a302 1
     * Determines the control points to use for cubic (Bezier) curve edges.
d314 2
a315 2
    protected void getCurveControlPoints(EdgeItem<?,?> eitem, Point2D[] cp,
                    double x1, double y1, double x2, double y2)
d317 1
a317 1
        double dx = x2-x1, dy = y2-y1;
d323 22
a344 1
     * Returns the type of the drawn edge.
d347 1
a347 1
    public EdgeType getEdgeType() {
d350 1
a350 1

d352 3
a354 2
     * Sets the type of the drawn edge.
     *
d357 4
a360 1
    public void setEdgeType(EdgeType type) {
d363 1
a363 1

d365 5
a369 1
     * Returns the type of the drawn edge.
d371 1
a371 1
    public EdgeArrowType getArrowType() {
d374 1
a374 1

d376 6
a381 2
     * Sets the type of the drawn edge.
     *
d384 4
a387 1
    public void setArrowType(EdgeArrowType type) {
d390 1
a390 1

d405 1
a405 1

d423 1
a423 1

d426 2
a427 1
     * @@return the horizontal alignment
d429 1
a429 1
    public Alignment getHorizontalAlignment1() {
d432 1
a432 1

d435 2
a436 1
     * @@return the vertical alignment
d438 1
a438 1
    public Alignment getVerticalAlignment1() {
d445 2
a446 1
     * @@return the horizontal alignment
d448 1
a448 1
    public Alignment getHorizontalAlignment2() {
d451 1
a451 1

d454 2
a455 1
     * @@return the vertical alignment
d457 1
a457 1
    public Alignment getVerticalAlignment2() {
d460 1
a460 1

d463 3
a465 1
     * @@param align the horizontal alignment
d467 1
a467 1
    public void setHorizontalAlignment1(Alignment align) {
d470 1
a470 1

d473 3
a475 1
     * @@param align the vertical alignment
d477 1
a477 1
    public void setVerticalAlignment1(Alignment align) {
d484 3
a486 1
     * @@param align the horizontal alignment
d488 1
a488 1
    public void setHorizontalAlignment2(Alignment align) {
d491 1
a491 1

d494 3
a496 1
     * @@param align the vertical alignment
d498 1
a498 1
    public void setVerticalAlignment2(Alignment align) {
d501 1
a501 1

d511 1
a511 1

a521 9
    public float getSplineSlack() {
		return splineSlack;
	}

	public void setSplineSlack(float splineSlack) {
		this.splineSlack = splineSlack;
	}


@


2.1.4.2
log
@Eliminated unnecessary methods from the EdgeItem interface
@
text
@d127 2
a128 2
        VisualItem<?> item1 = edge.getSourceNode();
        VisualItem<?> item2 = edge.getTargetNode();
d155 1
a155 1
            VisualItem<?> dest = forward ? e.getTargetNode() : e.getSourceNode();
@


2.1.4.3
log
@Moved RenderType outside of AbstractShapeRenderer (it is now a top level enum)
@
text
@d118 1
a118 1
        return RenderType.DRAW;
@


2.1.4.4
log
@Documentation improvements
@
text
@d329 1
a329 1
     * @@see prefuse.render.Renderer#calculateBounds(VisualItem,Rectangle2D)
@


2.1.4.5
log
@GraphicsLib is no longer aware of VisualItem. The Renderers now provide the necessary information to GraphicsLib
@
text
@d342 1
a342 1
        GraphicsLib.calculateBounds(shape, getStroke(item), bounds);
@


2.1.4.6
log
@Minor tweaks to edge layouts
@
text
@a19 1
import prefuse.util.MathLib;
d54 2
d271 1
a271 1
        m_arrowTrans.rotate(-MathLib.PI_DIV_2 +
@


2.1.4.7
log
@fixed typos
@
text
@d463 1
a463 1
     * Get the horizontal alignment of the edge mount point with the first node.
d471 1
a471 1
     * Get the vertical alignment of the edge mount point with the first node.
d479 1
a479 1
     * Get the horizontal alignment of the edge mount point with the second
d488 1
a488 1
     * Get the vertical alignment of the edge mount point with the second node.
d496 1
a496 1
     * Set the horizontal alignment of the edge mount point with the first node.
d504 1
a504 1
     * Set the vertical alignment of the edge mount point with the first node.
d512 1
a512 1
     * Set the horizontal alignment of the edge mount point with the second
d521 1
a521 1
     * Set the vertical alignment of the edge mount point with the second node.
@


2.1.4.8
log
@Added more flexible rendering of curved edges which pass through the edge's position. Allowed curve segments to be hidden if they are within a node's bounds
@
text
@d25 1
d27 3
a29 4
 * <p>
 * Renderer that draws edges as lines connecting nodes. Both straight and curved
 * lines are supported. Curved lines are drawn using cubic Bezier curves.
 * Subclasses can override the
d31 1
a31 2
 * method to provide custom control point assignment for such curves.
 * </p>
d33 2
a34 4
 * <p>
 * This class also supports arrows for directed edges. See the
 * {@@link #setArrowType(EdgeArrowType)} method for more.
 * </p>
d46 70
a115 77
		/** No arrows on edges */
		NONE,
		/** Arrows on edges pointing from source to target */
		FORWARD,
		/** Arrows on edges pointing from target to source */
		REVERSE

	}

	protected Line2D m_line = new Line2D.Float();
	protected CubicCurve2D m_cubic = new CubicCurve2D.Float();

	protected EdgeType m_edgeType = EdgeType.LINE;
	protected Alignment m_xAlign1 = Alignment.CENTER;
	protected Alignment m_yAlign1 = Alignment.CENTER;
	protected Alignment m_xAlign2 = Alignment.CENTER;
	protected Alignment m_yAlign2 = Alignment.CENTER;
	protected double m_width = 1;
	protected float m_curWidth = 1;
	protected Point2D m_tmpPoints[] = new Point2D[2];
	protected Point2D m_ctrlPoints[] = new Point2D[2];
	protected Point2D m_isctPoints[] = new Point2D[2];
	protected Point2D m_intersectSourcePoints[] = new Point2D[2];
	protected Point2D m_intersectTargetPoints[] = new Point2D[2];
	protected boolean hideNodeInternalSegments;

	// arrow head handling
	protected EdgeArrowType m_edgeArrow = EdgeArrowType.FORWARD;
	protected int m_arrowWidth = 8;
	protected int m_arrowHeight = 12;
	protected Polygon m_arrowHead = updateArrowHead(m_arrowWidth, m_arrowHeight);
	protected AffineTransform m_arrowTrans = new AffineTransform();
	protected Shape m_curArrow;

	protected float splineSlack = 0.1f;

	/**
	 * Create a new EdgeRenderer.
	 */
	public EdgeRenderer() {
		m_tmpPoints[0] = new Point2D.Float();
		m_tmpPoints[1] = new Point2D.Float();
		m_ctrlPoints[0] = new Point2D.Float();
		m_ctrlPoints[1] = new Point2D.Float();
		m_isctPoints[0] = new Point2D.Float();
		m_isctPoints[1] = new Point2D.Float();
	}

	/**
	 * Create a new EdgeRenderer with the given edge type.
	 *
	 * @@param edgeType
	 *            the edge type
	 */
	public EdgeRenderer(EdgeType edgeType) {
		this(edgeType, EdgeArrowType.FORWARD);
	}

	/**
	 * Create a new EdgeRenderer with the given edge and arrow types.
	 *
	 * @@param edgeType
	 *            the edge type
	 * @@param arrowType
	 *            the arrow type
	 * @@see #setArrowType(EdgeArrowType)
	 */
	public EdgeRenderer(EdgeType edgeType, EdgeArrowType arrowType) {
		this();
		setEdgeType(edgeType);
		setArrowType(arrowType);
	}

	/**
	 * @@see prefuse.render.AbstractShapeRenderer#getRenderType(prefuse.visual.VisualItem)
	 */
	@@Override
d117 2
a118 2
		return RenderType.DRAW;
	}
d120 4
a123 4
	/**
	 * @@see prefuse.render.AbstractShapeRenderer#getRawShape(prefuse.visual.VisualItem)
	 */
	@@Override
d125 34
a158 63
		EdgeItem<?, ?> edge = (EdgeItem<?, ?>) item;
		VisualItem<?> item1 = edge.getSourceNode();
		VisualItem<?> item2 = edge.getTargetNode();

		if (item1 != item2) {
			GraphicsLib.getAlignedPoint(m_tmpPoints[0], item1.getBounds(),
					m_xAlign1, m_yAlign1);
			GraphicsLib.getAlignedPoint(m_tmpPoints[1], item2.getBounds(),
					m_xAlign2, m_yAlign2);
		} else {
			// use the center of the item when the items are the same
			GraphicsLib.getAlignedPoint(m_tmpPoints[0], item1.getBounds(),
					Alignment.CENTER, Alignment.CENTER);
			GraphicsLib.getAlignedPoint(m_tmpPoints[1], item2.getBounds(),
					Alignment.CENTER, Alignment.CENTER);
		}

		m_curWidth = (float) (m_width * getLineWidth(item));

		// create the arrow head, if needed
		EdgeItem<?, ?> e = (EdgeItem<?, ?>) item;

		final Point2D edgePos = new Point2D.Double(e.getX(), e.getY());
		// Calculate edge to source node intersection points

		int srcIntersection = GraphicsLib.intersectLineRectangle(
				m_edgeType == EdgeType.CURVE_VIA_EDGE ? edgePos
						: m_tmpPoints[1], m_tmpPoints[0], item1.getBounds(),
				m_intersectSourcePoints);
		if (srcIntersection <= 0 && m_edgeType == EdgeType.CURVE_VIA_EDGE) {
			srcIntersection = GraphicsLib.intersectLineRectangle(edgePos,
					m_tmpPoints[1], item1.getBounds(), m_intersectSourcePoints);
		}
		int tgtIntersection = GraphicsLib.intersectLineRectangle(
				m_edgeType == EdgeType.CURVE_VIA_EDGE ? edgePos
						: m_tmpPoints[0], m_tmpPoints[1], item2.getBounds(),
				m_intersectTargetPoints);
		if (tgtIntersection <= 0 && m_edgeType == EdgeType.CURVE_VIA_EDGE) {
			tgtIntersection = GraphicsLib.intersectLineRectangle(edgePos,
					m_tmpPoints[0], item2.getBounds(), m_intersectTargetPoints);
		}

		final double n1x = m_tmpPoints[0].getX();
		final double n1y = m_tmpPoints[0].getY();
		final double n2x = m_tmpPoints[1].getX();
		final double n2y = m_tmpPoints[1].getY();

		boolean[] pointUpdated = new boolean[2];

		if (e.isDirected() && m_edgeArrow != EdgeArrowType.NONE) {
			// get starting and ending edge endpoints
			boolean forward = m_edgeArrow == EdgeArrowType.FORWARD;
			// the orientation of the arrow is different when the curve is drawn
			// via an edge
			Point2D start = m_edgeType == EdgeType.CURVE_VIA_EDGE ? edgePos
					: m_tmpPoints[forward ? 0 : 1];
			Point2D end = m_tmpPoints[forward ? 1 : 0];
			// compute the intersection with the target bounding box

			int i = forward ? tgtIntersection : srcIntersection;
			if (i > 0) {
				end = (forward ? m_intersectTargetPoints
						: m_intersectSourcePoints)[0];
d161 12
a172 16
			// create the arrow head shape
			AffineTransform at = getArrowTrans(start, end, m_curWidth);
			m_curArrow = at.createTransformedShape(m_arrowHead);

			// update the endpoints for the edge shape
			// need to bias this by arrow head size
			Point2D lineEnd = m_tmpPoints[forward ? 1 : 0];
			lineEnd.setLocation(0, -m_arrowHeight);
			at.transform(lineEnd, lineEnd);
			pointUpdated[forward ? 1 : 0] = true;

		} else {
			m_curArrow = null;
		}

		// reposition the start/end points
d174 2
a175 11
		if (!pointUpdated[0] && srcIntersection > 0) {
			m_tmpPoints[0] = m_intersectSourcePoints[0];
			pointUpdated[0] = true;
		}
		if (!pointUpdated[1] && tgtIntersection > 0) {
			m_tmpPoints[1] = m_intersectTargetPoints[0];
			pointUpdated[1] = true;
		}

		// draw self-referencing edges
		if (item1 == item2) {
d177 74
a250 88
			m_ellipse.setFrame(m_tmpPoints[0].getX(), m_tmpPoints[0].getY(),
					40, 30);
			return m_ellipse;
		}

		// create the edge shape
		Shape shape = null;

		switch (m_edgeType) {
		case LINE:
			m_line.setLine(n1x, n1y, n2x, n2y);
			shape = m_line;
			break;
		case CURVE:
			getCurveControlPoints(edge, m_ctrlPoints, n1x, n1y, n2x, n2y);
			m_cubic.setCurve(n1x, n1y, m_ctrlPoints[0].getX(), m_ctrlPoints[0]
					.getY(), m_ctrlPoints[1].getX(), m_ctrlPoints[1].getY(),
					n2x, n2y);
			shape = m_cubic;
			break;
		case CURVE_VIA_EDGE:

			List<Boolean> invisibleSegments = new ArrayList<Boolean>();
			List<Float> splinePoints = new ArrayList<Float>();

			splinePoints.add((float) n1x);
			splinePoints.add((float) n1y);

			if (pointUpdated[0]) {
				invisibleSegments.add(hideNodeInternalSegments);
				splinePoints.add((float) m_tmpPoints[0].getX());
				splinePoints.add((float) m_tmpPoints[0].getY());
			}

			invisibleSegments.add(false);
			splinePoints.add((float) e.getX());
			splinePoints.add((float) e.getY());

			if (pointUpdated[1]) {
				invisibleSegments.add(false);
				splinePoints.add((float) m_tmpPoints[1].getX());
				splinePoints.add((float) m_tmpPoints[1].getY());
				invisibleSegments.add(hideNodeInternalSegments);
			} else {
				invisibleSegments.add(false);
			}

			splinePoints.add((float) n2x);
			splinePoints.add((float) n2y);

			float[] pts = new float[splinePoints.size()];

			int i = 0;
			for (float pt : splinePoints) {
				pts[i++] = pt;
			}
			i = 0;
			boolean[] is = new boolean[invisibleSegments.size()];
			for (boolean b : invisibleSegments) {
				is[i++] = b;
			}
			shape = createCurvedEdge(pts, is);
			break;
		default:
			throw new IllegalStateException("Unknown edge type");
		}

		// return the edge shape
		return shape;
	}

	protected Shape createCurvedEdge(float[] poly, boolean[] invisibleSegments) {
		GeneralPath m_path = new GeneralPath();
		// initialize the path
		m_path.reset();
		m_path.moveTo(poly[0], poly[1]);

		GraphicsLib.cardinalSpline(m_path, poly, invisibleSegments,
				splineSlack, 0.0f, 0.0f);

		return m_path;
	}

	/**
	 * @@see prefuse.render.Renderer#render(java.awt.Graphics2D,
	 *      prefuse.visual.VisualItem)
	 */
	@@Override
d252 47
a299 5
		// render the edge line
		super.render(g, item);

		// render the edge arrow head, if appropriate
		if (m_curArrow != null) {
a300 20
			g.setPaint(ColorLib.getColor(item.getStrokeColor()));
			g.fill(m_curArrow);
		}
	}

	/**
	 * Returns an affine transformation that maps the arrowhead shape to the
	 * position and orientation specified by the provided line segment end
	 * points.
	 */
	protected AffineTransform getArrowTrans(Point2D p1, Point2D p2, double width) {
		m_arrowTrans.setToTranslation(p2.getX(), p2.getY());
		m_arrowTrans.rotate(-MathLib.PI_DIV_2
				+ Math.atan2(p2.getY() - p1.getY(), p2.getX() - p1.getX()));
		if (width > 1) {
			double scalar = width / 4;
			m_arrowTrans.scale(scalar, scalar);
		}
		return m_arrowTrans;
	}
d302 4
a305 28
	/**
	 * Update the dimensions of the arrow head, creating a new arrow head if
	 * necessary. The return value is also set as the member variable
	 * <code>m_arrowHead</code>
	 *
	 * @@param w
	 *            the width of the untransformed arrow head base, in pixels
	 * @@param h
	 *            the height of the untransformed arrow head, in pixels
	 * @@return the untransformed arrow head shape
	 */
	protected Polygon updateArrowHead(int w, int h) {
		if (m_arrowHead == null) {
			m_arrowHead = new Polygon();
		} else {
			m_arrowHead.reset();
		}
		m_arrowHead.addPoint(0, 0);
		m_arrowHead.addPoint(-w / 2, -h);
		m_arrowHead.addPoint(w / 2, -h);
		m_arrowHead.addPoint(0, 0);
		return m_arrowHead;
	}

	/**
	 * @@see prefuse.render.AbstractShapeRenderer#getTransform(prefuse.visual.VisualItem)
	 */
	@@Override
d307 2
a308 2
		return null;
	}
d310 4
a313 5
	/**
	 * @@see prefuse.render.Renderer#locatePoint(java.awt.geom.Point2D,
	 *      prefuse.visual.VisualItem)
	 */
	@@Override
d315 16
a330 15
		Shape s = getShape(item);
		if (s == null) {
			return false;
		} else {
			double width = Math.max(2, getLineWidth(item));
			double halfWidth = width / 2.0;
			return s.intersects(p.getX() - halfWidth, p.getY() - halfWidth,
					width, width);
		}
	}

	/**
	 * @@see prefuse.render.Renderer#calculateBounds(VisualItem,Rectangle2D)
	 */
	@@Override
d332 2
a333 2
		if (!m_manageBounds) {
			bounds.setRect(item.getX(), item.getY(), 0, 0);
d336 3
a338 3
		Shape shape = getShape(item);
		if (shape == null) {
			bounds.setRect(item.getX(), item.getY(), 0, 0);
d340 31
a370 34
		}
		GraphicsLib.calculateBounds(shape, getStroke(item), bounds);
		if (m_curArrow != null) {
			Rectangle2D.union(bounds, m_curArrow.getBounds2D(), bounds);
		}
	}

	/**
	 * Returns the line width to be used for this VisualItem. By default,
	 * returns the base width value set using the
	 * {@@link #setDefaultLineWidth(double)} method, scaled by the item size
	 * returned by {@@link VisualItem#getSize()}. Subclasses can override this
	 * method to perform custom line width determination, however, the preferred
	 * method is to change the item size value itself.
	 *
	 * @@param item
	 *            the VisualItem for which to determine the line width
	 * @@return the desired line width, in pixels
	 */
	protected double getLineWidth(VisualItem<?> item) {
		return item.getSize();
	}

	/**
	 * Returns the stroke value returned by {@@link VisualItem#getStroke()},
	 * scaled by the current line width determined by the
	 * {@@link #getLineWidth(VisualItem)} method. Subclasses may override this
	 * method to perform custom stroke assignment, but should respect the line
	 * width paremeter stored in the {@@link #m_curWidth} member variable, which
	 * caches the result of <code>getLineWidth</code>.
	 *
	 * @@see prefuse.render.AbstractShapeRenderer#getStroke(prefuse.visual.VisualItem)
	 */
	@@Override
d372 2
a373 152
		return StrokeLib.getDerivedStroke(item.getStroke(), m_curWidth);
	}

	/**
	 * Determines the control points to use for cubic (Bezier) curve edges.
	 * Override this method to provide custom curve specifications. To reduce
	 * object initialization, the entries of the Point2D array are already
	 * initialized, so use the <tt>Point2D.setLocation()</tt> method rather
	 * than <tt>new Point2D.Double()</tt> to more efficiently set custom
	 * control points.
	 *
	 * @@param eitem
	 *            the EdgeItem we are determining the control points for
	 * @@param cp
	 *            array of Point2D's (length >= 2) in which to return the
	 *            control points
	 * @@param x1
	 *            the x co-ordinate of the first node this edge connects to
	 * @@param y1
	 *            the y co-ordinate of the first node this edge connects to
	 * @@param x2
	 *            the x co-ordinate of the second node this edge connects to
	 * @@param y2
	 *            the y co-ordinate of the second node this edge connects to
	 */
	protected void getCurveControlPoints(EdgeItem<?, ?> eitem, Point2D[] cp,
			double x1, double y1, double x2, double y2) {
		double dx = x2 - x1, dy = y2 - y1;
		cp[0].setLocation(x1 + 2 * dx / 3, y1);
		cp[1].setLocation(x2 - dx / 8, y2 - dy / 8);
	}

	/**
	 * Returns the type of the drawn edge.
	 *
	 * @@return the edge type
	 */
	public EdgeType getEdgeType() {
		return m_edgeType;
	}

	/**
	 * Sets the type of the drawn edge.
	 *
	 * @@param type
	 *            the new edge type
	 */
	public void setEdgeType(EdgeType type) {
		m_edgeType = type;
	}

	/**
	 * Returns the type of the drawn edge.
	 */
	public EdgeArrowType getArrowType() {
		return m_edgeArrow;
	}

	/**
	 * Sets the type of the drawn edge.
	 *
	 * @@param type
	 *            the new arrow type
	 */
	public void setArrowType(EdgeArrowType type) {
		m_edgeArrow = type;
	}

	/**
	 * Sets the dimensions of an arrow head for a directed edge. This specifies
	 * the pixel dimensions when both the zoom level and the size factor (a
	 * combination of item size value and default stroke width) are 1.0.
	 *
	 * @@param width
	 *            the untransformed arrow head width, in pixels. This specifies
	 *            the span of the base of the arrow head.
	 * @@param height
	 *            the untransformed arrow head height, in pixels. This specifies
	 *            the distance from the point of the arrow to its base.
	 */
	public void setArrowHeadSize(int width, int height) {
		m_arrowWidth = width;
		m_arrowHeight = height;
		m_arrowHead = updateArrowHead(width, height);
	}

	/**
	 * Get the height of the untransformed arrow head. This is the distance, in
	 * pixels, from the tip of the arrow to its base.
	 *
	 * @@return the default arrow head height
	 */
	public int getArrowHeadHeight() {
		return m_arrowHeight;
	}

	/**
	 * Get the width of the untransformed arrow head. This is the length, in
	 * pixels, of the base of the arrow head.
	 *
	 * @@return the default arrow head width
	 */
	public int getArrowHeadWidth() {
		return m_arrowWidth;
	}

	/**
	 * Get the horizontal alignment of the edge mount point with the first node.
	 *
	 * @@return the horizontal alignment
	 */
	public Alignment getHorizontalAlignment1() {
		return m_xAlign1;
	}

	/**
	 * Get the vertical alignment of the edge mount point with the first node.
	 *
	 * @@return the vertical alignment
	 */
	public Alignment getVerticalAlignment1() {
		return m_yAlign1;
	}

	/**
	 * Get the horizontal alignment of the edge mount point with the second
	 * node.
	 *
	 * @@return the horizontal alignment
	 */
	public Alignment getHorizontalAlignment2() {
		return m_xAlign2;
	}

	/**
	 * Get the vertical alignment of the edge mount point with the second node.
	 *
	 * @@return the vertical alignment
	 */
	public Alignment getVerticalAlignment2() {
		return m_yAlign2;
	}

	/**
	 * Set the horizontal alignment of the edge mount point with the first node.
	 *
	 * @@param align
	 *            the horizontal alignment
	 */
	public void setHorizontalAlignment1(Alignment align) {
		m_xAlign1 = align;
	}
d375 172
a546 20
	/**
	 * Set the vertical alignment of the edge mount point with the first node.
	 *
	 * @@param align
	 *            the vertical alignment
	 */
	public void setVerticalAlignment1(Alignment align) {
		m_yAlign1 = align;
	}

	/**
	 * Set the horizontal alignment of the edge mount point with the second
	 * node.
	 *
	 * @@param align
	 *            the horizontal alignment
	 */
	public void setHorizontalAlignment2(Alignment align) {
		m_xAlign2 = align;
	}
d548 1
a548 32
	/**
	 * Set the vertical alignment of the edge mount point with the second node.
	 *
	 * @@param align
	 *            the vertical alignment
	 */
	public void setVerticalAlignment2(Alignment align) {
		m_yAlign2 = align;
	}

	/**
	 * Sets the default width of lines. This width value will be scaled by the
	 * value of an item's size data field. The default base width is 1.
	 *
	 * @@param w
	 *            the desired default line width, in pixels
	 */
	public void setDefaultLineWidth(double w) {
		m_width = w;
	}

	/**
	 * Gets the default width of lines. This width value that will be scaled by
	 * the value of an item's size data field. The default base width is 1.
	 *
	 * @@return the default line width, in pixels
	 */
	public double getDefaultLineWidth() {
		return m_width;
	}

	public float getSplineSlack() {
a555 7
	public boolean isHideNodeInternalSegments() {
		return hideNodeInternalSegments;
	}

	public void setHideNodeInternalSegments(boolean hideNodeInternalSegments) {
		this.hideNodeInternalSegments = hideNodeInternalSegments;
	}
@


2.1.4.9
log
@fix
@
text
@a131 1
	 * TODO: refactor this method - it is far too complicated now
d216 8
a223 9
		if(m_edgeType == EdgeType.CURVE_VIA_EDGE) {
			if (!pointUpdated[0] && srcIntersection > 0) {
				m_tmpPoints[0] = m_intersectSourcePoints[0];
				pointUpdated[0] = true;
			}
			if (!pointUpdated[1] && tgtIntersection > 0) {
				m_tmpPoints[1] = m_intersectTargetPoints[0];
				pointUpdated[1] = true;
			}
d239 1
a239 1
			m_line.setLine(m_tmpPoints[0].getX(), m_tmpPoints[0].getY(), m_tmpPoints[1].getX(), m_tmpPoints[1].getY());
d243 1
a243 1
			getCurveControlPoints(edge, m_ctrlPoints, m_tmpPoints[0].getX(), m_tmpPoints[0].getY(), m_tmpPoints[1].getX(), m_tmpPoints[1].getY());
d246 1
a246 1
					m_tmpPoints[1].getX(), m_tmpPoints[1].getY());
@


2.1.4.10
log
@small fix to make it easier to override the colour of an edge which has an arrow head. Previously the head would get it's colour in a way that made it harder to override.

Unfortunately eclipse changed the layout.
@
text
@d18 1
d27 5
a31 4
 * Renderer that draws edges as lines connecting nodes. Both straight and curved lines are
 * supported. Curved lines are drawn using cubic Bezier curves. Subclasses can override the
 * {@@link #getCurveControlPoints(EdgeItem, Point2D[], double, double, double, double)} method to
 * provide custom control point assignment for such curves.
d33 1
a33 1
 * 
d35 2
a36 2
 * This class also supports arrows for directed edges. See the {@@link #setArrowType(EdgeArrowType)}
 * method for more.
d38 1
a38 1
 * 
d45 1
a45 3
		LINE,
		CURVE,
		CURVE_VIA_EDGE;
d99 1
a99 1
	 * 
d103 1
a103 1
	public EdgeRenderer(final EdgeType edgeType) {
d109 1
a109 1
	 * 
d116 1
a116 1
	public EdgeRenderer(final EdgeType edgeType, final EdgeArrowType arrowType) {
d126 1
a126 1
	public RenderType getRenderType(final VisualItem<?> item) {
d131 2
a132 2
	 * @@see prefuse.render.AbstractShapeRenderer#getRawShape(prefuse.visual.VisualItem) TODO:
	 *      refactor this method - it is far too complicated now
d135 4
a138 4
	protected Shape getRawShape(final VisualItem<?> item) {
		final EdgeItem<?, ?> edge = (EdgeItem<?, ?>) item;
		final VisualItem<?> item1 = edge.getSourceNode();
		final VisualItem<?> item2 = edge.getTargetNode();
d141 4
a144 2
			GraphicsLib.getAlignedPoint(m_tmpPoints[0], item1.getBounds(), m_xAlign1, m_yAlign1);
			GraphicsLib.getAlignedPoint(m_tmpPoints[1], item2.getBounds(), m_xAlign2, m_yAlign2);
d147 4
a150 2
			GraphicsLib.getAlignedPoint(m_tmpPoints[0], item1.getBounds(), Alignment.CENTER, Alignment.CENTER);
			GraphicsLib.getAlignedPoint(m_tmpPoints[1], item2.getBounds(), Alignment.CENTER, Alignment.CENTER);
d156 1
a156 1
		final EdgeItem<?, ?> e = (EdgeItem<?, ?>) item;
d162 2
a163 1
				m_edgeType == EdgeType.CURVE_VIA_EDGE ? edgePos : m_tmpPoints[1], m_tmpPoints[0], item1.getBounds(),
d166 2
a167 2
			srcIntersection = GraphicsLib.intersectLineRectangle(edgePos, m_tmpPoints[1], item1.getBounds(),
					m_intersectSourcePoints);
d170 2
a171 1
				m_edgeType == EdgeType.CURVE_VIA_EDGE ? edgePos : m_tmpPoints[0], m_tmpPoints[1], item2.getBounds(),
d174 2
a175 2
			tgtIntersection = GraphicsLib.intersectLineRectangle(edgePos, m_tmpPoints[0], item2.getBounds(),
					m_intersectTargetPoints);
d183 1
a183 1
		final boolean[] pointUpdated = new boolean[2];
d187 1
a187 1
			final boolean forward = m_edgeArrow == EdgeArrowType.FORWARD;
d190 2
a191 1
			final Point2D start = m_edgeType == EdgeType.CURVE_VIA_EDGE ? edgePos : m_tmpPoints[forward ? 0 : 1];
d195 1
a195 1
			final int i = forward ? tgtIntersection : srcIntersection;
d197 2
a198 1
				end = (forward ? m_intersectTargetPoints : m_intersectSourcePoints)[0];
d202 1
a202 1
			final AffineTransform at = getArrowTrans(start, end, m_curWidth);
d207 1
a207 1
			final Point2D lineEnd = m_tmpPoints[forward ? 1 : 0];
d217 1
a217 1
		if (m_edgeType == EdgeType.CURVE_VIA_EDGE) {
d230 3
a232 2
			final Ellipse2D m_ellipse = new Ellipse2D.Double();
			m_ellipse.setFrame(m_tmpPoints[0].getX(), m_tmpPoints[0].getY(), 40, 30);
d240 28
a267 24
			case LINE:
				m_line.setLine(m_tmpPoints[0].getX(), m_tmpPoints[0].getY(), m_tmpPoints[1].getX(), m_tmpPoints[1].getY());
				shape = m_line;
				break;
			case CURVE:
				getCurveControlPoints(edge, m_ctrlPoints, m_tmpPoints[0].getX(), m_tmpPoints[0].getY(), m_tmpPoints[1].getX(),
						m_tmpPoints[1].getY());
				m_cubic.setCurve(n1x, n1y, m_ctrlPoints[0].getX(), m_ctrlPoints[0].getY(), m_ctrlPoints[1].getX(),
						m_ctrlPoints[1].getY(), m_tmpPoints[1].getX(), m_tmpPoints[1].getY());
				shape = m_cubic;
				break;
			case CURVE_VIA_EDGE:

				final List<Boolean> invisibleSegments = new ArrayList<Boolean>();
				final List<Float> splinePoints = new ArrayList<Float>();

				splinePoints.add((float) n1x);
				splinePoints.add((float) n1y);

				if (pointUpdated[0]) {
					invisibleSegments.add(hideNodeInternalSegments);
					splinePoints.add((float) m_tmpPoints[0].getX());
					splinePoints.add((float) m_tmpPoints[0].getY());
				}
d269 6
d276 4
a279 2
				splinePoints.add((float) e.getX());
				splinePoints.add((float) e.getY());
d281 15
a295 27
				if (pointUpdated[1]) {
					invisibleSegments.add(false);
					splinePoints.add((float) m_tmpPoints[1].getX());
					splinePoints.add((float) m_tmpPoints[1].getY());
					invisibleSegments.add(hideNodeInternalSegments);
				} else {
					invisibleSegments.add(false);
				}

				splinePoints.add((float) n2x);
				splinePoints.add((float) n2y);

				final float[] pts = new float[splinePoints.size()];

				int i = 0;
				for (final float pt : splinePoints) {
					pts[i++] = pt;
				}
				i = 0;
				final boolean[] is = new boolean[invisibleSegments.size()];
				for (final boolean b : invisibleSegments) {
					is[i++] = b;
				}
				shape = createCurvedEdge(pts, is);
				break;
			default:
				throw new IllegalStateException("Unknown edge type");
d302 2
a303 2
	protected Shape createCurvedEdge(final float[] poly, final boolean[] invisibleSegments) {
		final GeneralPath m_path = new GeneralPath();
d308 2
a309 1
		GraphicsLib.cardinalSpline(m_path, poly, invisibleSegments, splineSlack, 0.0f, 0.0f);
d315 2
a316 1
	 * @@see prefuse.render.Renderer#render(java.awt.Graphics2D, prefuse.visual.VisualItem)
d319 1
a319 1
	public void render(final Graphics2D g, final VisualItem<?> item) {
d326 2
a327 1
			g.setPaint(getStrokeColor(item));
d333 3
a335 2
	 * Returns an affine transformation that maps the arrowhead shape to the position and
	 * orientation specified by the provided line segment end points.
d337 1
a337 1
	protected AffineTransform getArrowTrans(final Point2D p1, final Point2D p2, final double width) {
d339 2
a340 1
		m_arrowTrans.rotate(-MathLib.PI_DIV_2 + Math.atan2(p2.getY() - p1.getY(), p2.getX() - p1.getX()));
d342 1
a342 1
			final double scalar = width / 4;
d349 4
a352 3
	 * Update the dimensions of the arrow head, creating a new arrow head if necessary. The return
	 * value is also set as the member variable <code>m_arrowHead</code>
	 * 
d359 1
a359 1
	protected Polygon updateArrowHead(final int w, final int h) {
d376 1
a376 1
	protected AffineTransform getTransform(final VisualItem<?> item) {
d381 2
a382 1
	 * @@see prefuse.render.Renderer#locatePoint(java.awt.geom.Point2D, prefuse.visual.VisualItem)
d385 2
a386 2
	public boolean locatePoint(final Point2D p, final VisualItem<?> item) {
		final Shape s = getShape(item);
d390 4
a393 3
			final double width = Math.max(2, getLineWidth(item));
			final double halfWidth = width / 2.0;
			return s.intersects(p.getX() - halfWidth, p.getY() - halfWidth, width, width);
d401 1
a401 1
	public void calculateBounds(final VisualItem<?> item, final Rectangle2D bounds) {
d406 1
a406 1
		final Shape shape = getShape(item);
d418 7
a424 6
	 * Returns the line width to be used for this VisualItem. By default, returns the base width
	 * value set using the {@@link #setDefaultLineWidth(double)} method, scaled by the item size
	 * returned by {@@link VisualItem#getSize()}. Subclasses can override this method to perform
	 * custom line width determination, however, the preferred method is to change the item size
	 * value itself.
	 * 
d429 1
a429 1
	protected double getLineWidth(final VisualItem<?> item) {
d434 7
a440 6
	 * Returns the stroke value returned by {@@link VisualItem#getStroke()}, scaled by the current
	 * line width determined by the {@@link #getLineWidth(VisualItem)} method. Subclasses may
	 * override this method to perform custom stroke assignment, but should respect the line width
	 * paremeter stored in the {@@link #m_curWidth} member variable, which caches the result of
	 * <code>getLineWidth</code>.
	 * 
d444 1
a444 1
	protected BasicStroke getStroke(final VisualItem<?> item) {
d449 7
a455 5
	 * Determines the control points to use for cubic (Bezier) curve edges. Override this method to
	 * provide custom curve specifications. To reduce object initialization, the entries of the
	 * Point2D array are already initialized, so use the <tt>Point2D.setLocation()</tt> method
	 * rather than <tt>new Point2D.Double()</tt> to more efficiently set custom control points.
	 * 
d459 2
a460 1
	 *            array of Point2D's (length >= 2) in which to return the control points
d470 3
a472 3
	protected void getCurveControlPoints(final EdgeItem<?, ?> eitem, final Point2D[] cp, final double x1, final double y1,
			final double x2, final double y2) {
		final double dx = x2 - x1, dy = y2 - y1;
d479 1
a479 1
	 * 
d488 1
a488 1
	 * 
d492 1
a492 1
	public void setEdgeType(final EdgeType type) {
d505 1
a505 1
	 * 
d509 1
a509 1
	public void setArrowType(final EdgeArrowType type) {
d514 4
a517 4
	 * Sets the dimensions of an arrow head for a directed edge. This specifies the pixel dimensions
	 * when both the zoom level and the size factor (a combination of item size value and default
	 * stroke width) are 1.0.
	 * 
d519 2
a520 2
	 *            the untransformed arrow head width, in pixels. This specifies the span of the base
	 *            of the arrow head.
d522 2
a523 2
	 *            the untransformed arrow head height, in pixels. This specifies the distance from
	 *            the point of the arrow to its base.
d525 1
a525 1
	public void setArrowHeadSize(final int width, final int height) {
d532 3
a534 3
	 * Get the height of the untransformed arrow head. This is the distance, in pixels, from the tip
	 * of the arrow to its base.
	 * 
d542 3
a544 3
	 * Get the width of the untransformed arrow head. This is the length, in pixels, of the base of
	 * the arrow head.
	 * 
d553 1
a553 1
	 * 
d562 1
a562 1
	 * 
d570 3
a572 2
	 * Get the horizontal alignment of the edge mount point with the second node.
	 * 
d581 1
a581 1
	 * 
d590 1
a590 1
	 * 
d594 1
a594 1
	public void setHorizontalAlignment1(final Alignment align) {
d600 1
a600 1
	 * 
d604 1
a604 1
	public void setVerticalAlignment1(final Alignment align) {
d609 3
a611 2
	 * Set the horizontal alignment of the edge mount point with the second node.
	 * 
d615 1
a615 1
	public void setHorizontalAlignment2(final Alignment align) {
d621 1
a621 1
	 * 
d625 1
a625 1
	public void setVerticalAlignment2(final Alignment align) {
d630 3
a632 3
	 * Sets the default width of lines. This width value will be scaled by the value of an item's
	 * size data field. The default base width is 1.
	 * 
d636 1
a636 1
	public void setDefaultLineWidth(final double w) {
d641 3
a643 3
	 * Gets the default width of lines. This width value that will be scaled by the value of an
	 * item's size data field. The default base width is 1.
	 * 
d654 1
a654 1
	public void setSplineSlack(final float splineSlack) {
d662 1
a662 1
	public void setHideNodeInternalSegments(final boolean hideNodeInternalSegments) {
@


2.0
log
@Merge beta branch back onto main trunk
@
text
@a38 2
    protected static final Polygon DEFAULT_ARROW_HEAD =
        new Polygon(new int[] {0,-4,4,0}, new int[] {0,-12,-12,0}, 4);
d49 1
a49 1
    protected int     m_curWidth  = 1;
d54 6
a59 4
    protected String  m_weightLabel = "weight";
    
    protected int     m_edgeArrow = Constants.EDGE_ARROW_FORWARD;
    protected Polygon m_arrowHead = DEFAULT_ARROW_HEAD;
d123 32
a158 4
        m_curWidth = (int)Math.round(m_width * getLineWidth(item));
        
        // create the edge shape
        Shape shape = null;
a175 30
        // create the arrow head, if needed
        EdgeItem e = (EdgeItem)item;
        if ( e.isDirected() && m_edgeArrow != Constants.EDGE_ARROW_NONE ) {
            boolean forward = (m_edgeArrow == Constants.EDGE_ARROW_FORWARD);
            Point2D start = null, end = null;
            double width = m_width * getLineWidth(item);

            switch ( type ) {
                case Constants.EDGE_TYPE_LINE:
                    start = m_tmpPoints[forward?0:1];
                    end   = m_tmpPoints[forward?1:0];
                    break;
                case Constants.EDGE_TYPE_CURVE:
                    start = m_tmpPoints[forward?0:1];
                    end   = m_tmpPoints[forward?1:0];
                    break;
                default:
                    throw new IllegalStateException("Unknown edge type.");
            }
            VisualItem dest = forward ? e.getTargetItem() : e.getSourceItem();
            // TODO: generalize this to work for curved edges, too.
            int i = GraphicsLib.intersectLineRectangle(start, end,
                    dest.getBounds(), m_isctPoints);
            if ( i > 0 ) end = m_isctPoints[0];
            AffineTransform at = getArrowTrans(start, end, width);
            m_curArrow = at.createTransformedShape(m_arrowHead);
        } else {
            m_curArrow = null;
        }

d184 1
d186 1
d210 23
d262 2
a263 2
        Shape s = getShape(item);
        if ( s == null ) {
d267 1
a267 1
        GraphicsLib.setBounds(item, s, getStroke(item));
d276 1
a276 1
     * returns the base width value set using the {@@link #setBaseWidth(double)}
d289 6
d298 1
a298 1
        return (m_curWidth == 1 ? null : StrokeLib.getStroke(m_curWidth));
d392 33
d503 1
a503 1
     * Sets the base width of lines. This width value will
d506 1
a506 1
     * @@param w the desired base line width, in pixels
d508 1
a508 1
    public void setBaseWidth(double w) {
d513 1
a513 1
     * Gets the base width of lines. This width value that will
d516 1
a516 1
     * @@return the base line width, in pixels
d518 1
a518 1
    public double getBaseWidth() {
@


1.1
log
@file EdgeRenderer.java was initially added on branch beta.
@
text
@d1 460
@


1.1.2.1
log
@Initial commit of prefuse beta
@
text
@a0 352
package prefuse.render;

import java.awt.BasicStroke;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.CubicCurve2D;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import prefuse.Constants;
import prefuse.util.ColorLib;
import prefuse.util.GeometryLib;
import prefuse.util.StrokeLib;
import prefuse.visual.EdgeItem;
import prefuse.visual.VisualItem;


/**
 * Default edge renderer that draws edges as lines connecting nodes. Both
 * straight and curved (Bezier) lines are supported.
 * 
 * @@version 1.0
 * @@author <a href="http://jheer.org">Jeffrey Heer</a> prefuse(AT)jheer.org
 */
public class EdgeRenderer extends ShapeRenderer {
    
	public static final String EDGE_TYPE = "edgeType";
	
	protected static final double HALF_PI = Math.PI / 2;
	protected static final Polygon DEFAULT_ARROW_HEAD =
		new Polygon(new int[] {0,-4,4,0}, new int[] {0,-12,-12,0}, 4);
	
	protected Line2D       m_line  = new Line2D.Float();
	protected CubicCurve2D m_cubic = new CubicCurve2D.Float();

	protected int     m_edgeType = Constants.EDGE_TYPE_LINE;
	protected int     m_xAlign1  = Constants.CENTER;
	protected int     m_yAlign1  = Constants.CENTER;
	protected int     m_xAlign2  = Constants.CENTER;
	protected int     m_yAlign2  = Constants.CENTER;
	protected int     m_width    = 1;
	protected int     m_curWidth = 1;
	protected Point2D m_tmpPoints[]  = new Point2D[2];
	protected Point2D m_ctrlPoints[] = new Point2D[2];
	protected Point2D m_isctPoints[] = new Point2D[2];
	
	protected String  m_weightLabel = "weight";
	
	protected boolean m_directed = false;
	protected Polygon m_arrowHead = DEFAULT_ARROW_HEAD;
	protected AffineTransform m_arrowTrans = new AffineTransform();

	/**
	 * Constructor.
	 */
	public EdgeRenderer() {
		m_tmpPoints[0]  = new Point2D.Float();
		m_tmpPoints[1]  = new Point2D.Float();
		m_ctrlPoints[0] = new Point2D.Float();
		m_ctrlPoints[1] = new Point2D.Float();		
		m_isctPoints[0] = new Point2D.Float();
		m_isctPoints[1] = new Point2D.Float();		
	}
    
    public EdgeRenderer(int edgeType) {
        this();
        setEdgeType(edgeType);
    }
	
	/**
	 * @@see prefuse.render.ShapeRenderer#getRenderType()
	 */
	public int getRenderType(VisualItem item) {
		if ( m_directed ) {
			return RENDER_TYPE_DRAW_AND_FILL;
		} else {
			return RENDER_TYPE_DRAW;
		} 
	} //
  	
  	/**
  	 * @@see prefuse.render.ShapeRenderer#getRawShape(prefuse.a_old.VisualItem)
  	 */
	protected Shape getRawShape(VisualItem item) {
		EdgeItem   edge = (EdgeItem)item;
		VisualItem item1 = edge.getSourceItem();
		VisualItem item2 = edge.getTargetItem();
		
		int type = m_edgeType;
		
		getAlignedPoint(m_tmpPoints[0], item1.getBounds(),
						m_xAlign1, m_yAlign1);
		getAlignedPoint(m_tmpPoints[1], item2.getBounds(),
						m_xAlign2, m_yAlign2);
		double n1x = m_tmpPoints[0].getX();
		double n1y = m_tmpPoints[0].getY();
		double n2x = m_tmpPoints[1].getX();
		double n2y = m_tmpPoints[1].getY();
		m_curWidth = getLineWidth(item);
		
		switch ( type ) {
			case Constants.EDGE_TYPE_LINE:			
				m_line.setLine(n1x, n1y, n2x, n2y);
				return m_line;
			case Constants.EDGE_TYPE_CURVE:
				getCurveControlPoints(edge, m_ctrlPoints,n1x,n1y,n2x,n2y);
				m_cubic.setCurve(n1x, n1y,
								m_ctrlPoints[0].getX(), m_ctrlPoints[0].getY(),
								m_ctrlPoints[1].getX(), m_ctrlPoints[1].getY(),
								n2x,n2y);
				return m_cubic;
			default:
				throw new IllegalStateException("Unknown edge type");
		}	
	} //

	/**
	 * @@see prefuse.render.Renderer#render(java.awt.Graphics2D, prefuse.a_old.VisualItem)
	 */
	public void render(Graphics2D g, VisualItem item) {
		super.render(g, item);
        EdgeItem e = (EdgeItem)item;
		if ( false /*e.isDirected()*/ ) {
			Point2D start = null, end = null;
			int width;
			
			String stype = (String)item.get(EDGE_TYPE);
			int type = m_edgeType;
			if ( stype != null ) {
				try {
					type = Integer.parseInt(stype);
				} catch ( Exception ex ) {}
			}
			switch ( type ) {
				case Constants.EDGE_TYPE_LINE:
					start = m_tmpPoints[0];
					end   = m_tmpPoints[1];
					width = m_width;
					break;
				case Constants.EDGE_TYPE_CURVE:
					start = m_ctrlPoints[1];
					end   = m_tmpPoints[1];
					width = 1;
					break;
				default:
					throw new IllegalStateException("Unknown edge type.");
			}
			VisualItem item2 = e.getTargetItem();
			Rectangle2D r = item2.getBounds();
			int i = GeometryLib.intersectLineRectangle(start, end, r, m_isctPoints);
			if ( i > 0 )
				end = m_isctPoints[0];
			AffineTransform at = getArrowTrans(start, end, width);
            Shape arrowHead = at.createTransformedShape(m_arrowHead);
			g.setPaint(ColorLib.getColor(item.getFillColor()));
			g.fill(arrowHead);
		}
	} //

	/**
	 * Returns an affine transformation that maps the arrowhead shape
	 * to the position and orientation specified by the provided
	 * line segment end points.
	 */
	protected AffineTransform getArrowTrans(Point2D p1, Point2D p2, int width) {
		m_arrowTrans.setToTranslation(p2.getX(), p2.getY());
		m_arrowTrans.rotate(-HALF_PI + 
			Math.atan2(p2.getY()-p1.getY(), p2.getX()-p1.getX()));
		if ( width > 1 ) {
			double scalar = (2.0*(width-1))/4+1;
			m_arrowTrans.scale(scalar, scalar);
		}
		return m_arrowTrans;
	} //

	/**
	 * @@see prefuse.render.ShapeRenderer#getTransform(prefuse.a_old.VisualItem)
	 */
	protected AffineTransform getTransform(VisualItem item) {
		return null;
	} //
    
    /**
     * TODO: no longer need this?
     * @@see prefuse.render.Renderer#locatePoint(java.awt.geom.Point2D, prefuse.a_old.VisualItem)
     */
    public boolean locatePoint(Point2D p, VisualItem item) {
        Shape s = getShape(item);
        if ( s == null ) {
            return false;
        } else {
            double width = Math.max(2, getLineWidth(item));
            double halfWidth = width/2.0;
            return s.intersects(p.getX()-halfWidth,
                                p.getY()-halfWidth,
                                width,width);
        }
    }

	/**
	 * Returns the line width to be used for this VisualItem. By default,
	 * returns the value set using the <code>setWidth</code> method.
	 * Subclasses should override this method to perform custom line
	 * width determination.
	 * @@param item the VisualItem for which to determine the line width
	 * @@return the desired line width, in pixels
	 */
	protected int getLineWidth(VisualItem item) {
        return (int)item.getSize();
	}
    
    /**
     * @@see prefuse.render.ShapeRenderer#getStroke(prefuse.a_old.VisualItem)
     */
    protected BasicStroke getStroke(VisualItem item) {
        return (m_curWidth == 1 ? null : StrokeLib.getStroke(m_curWidth));
    }

	/**
	 * Determines the control points to use for cubic (Bezier) curve edges. 
	 * Override this method to provide custom curve specifications.
	 * To reduce object initialization, the entries of the Point2D array are
	 * already initialized, so use the <tt>Point2D.setLocation()</tt> method rather than
	 * <tt>new Point2D.Double()</tt> to more efficiently set custom control points.
     * @@param eitem the EdgeItem we are determining the control points for
	 * @@param cp array of Point2D's (length >= 2) in which to return the control points
	 * @@param x1 the x co-ordinate of the first node this edge connects to
	 * @@param y1 the y co-ordinate of the first node this edge connects to
	 * @@param x2 the x co-ordinate of the second node this edge connects to
	 * @@param y2 the y co-ordinate of the second node this edge connects to
	 */
	protected void getCurveControlPoints(EdgeItem eitem, Point2D[] cp, 
					double x1, double y1, double x2, double y2) 
	{
		double dx = x2-x1, dy = y2-y1;		
		cp[0].setLocation(x1+2*dx/3,y1);
		cp[1].setLocation(x2-dx/8,y2-dy/8);
	} //

	/**
	 * Helper method, which calculates the top-left co-ordinate of a rectangle
	 * given the rectangle's alignment.
	 */
	protected static void getAlignedPoint(Point2D p, Rectangle2D r, int xAlign, int yAlign) {
		double x = r.getX(), y = r.getY(), w = r.getWidth(), h = r.getHeight();
		if ( xAlign == Constants.CENTER ) {
			x = x+(w/2);
		} else if ( xAlign == Constants.RIGHT ) {
			x = x+w;
		}
		if ( yAlign == Constants.CENTER ) {
			y = y+(h/2);
		} else if ( yAlign == Constants.BOTTOM ) {
			y = y+h;
		}
		p.setLocation(x,y);
	} //

	/**
	 * Returns the type of the drawn edge. This is either EDGE_TYPE_LINE or
	 * EDGE_TYPE_CURVE.
	 * @@return the edge type
	 */
	public int getEdgeType() {
		return m_edgeType;
	} //
  	
	/**
	 * Sets the type of the drawn edge. This is either EDGE_TYPE_LINE or
	 * EDGE_TYPE_CURVE.
	 * @@param type the new edge type
	 */
	public void setEdgeType(int type) {
		m_edgeType = type;
	} //
  	
  	/**
  	 * Get the horizontal aligment of the edge mount point with the first node.
  	 * @@return the horizontal alignment
  	 */
	public int getHorizontalAlignment1() {
		return m_xAlign1;
	} //
	
	/**
	 * Get the vertical aligment of the edge mount point with the first node.
	 * @@return the vertical alignment
	 */
	public int getVerticalAlignment1() {
		return m_yAlign1;
	} //

	/**
	 * Get the horizontal aligment of the edge mount point with the second node.
	 * @@return the horizontal alignment
	 */
	public int getHorizontalAlignment2() {
		return m_xAlign2;
	} //
	
	/**
	 * Get the vertical aligment of the edge mount point with the second node.
	 * @@return the vertical alignment
	 */
	public int getVerticalAlignment2() {
		return m_yAlign2;
	} //
	
	/**
	 * Set the horizontal aligment of the edge mount point with the first node.
	 * @@param align the horizontal alignment
	 */
	public void setHorizontalAlignment1(int align) {
		m_xAlign1 = align;
	} //
	
	/**
	 * Set the vertical aligment of the edge mount point with the first node.
	 * @@param align the vertical alignment
	 */
	public void setVerticalAlignment1(int align) {
		m_yAlign1 = align;
	} //

	/**
	 * Set the horizontal aligment of the edge mount point with the second node.
	 * @@param align the horizontal alignment
	 */
	public void setHorizontalAlignment2(int align) {
		m_xAlign2 = align;
	} //
	
	/**
	 * Set the vertical aligment of the edge mount point with the second node.
	 * @@param align the vertical alignment
	 */
	public void setVerticalAlignment2(int align) {
		m_yAlign2 = align;
	} //
	
	/**
	 * Sets the desired width of lines.
	 * @@param w the desired line width, in pixels
	 */
	public void setWidth(int w) {
		m_width = w;
	} //

} // end of class DefaultEdgeRenderer
@


1.1.2.2
log
@Table method refactoring. Added PredicateChain, included in ColorFunction, SizeFunction, and RendererFactory. Added ItemBoundsListener, included in GraphView demo. Updated ColorMap to use int representation, moved palette creators to ColorLib. Added minExtent to JRangeSlider. Fixed round-off rendering glitches int optimized rendering, added RenderingAccuracy test class. Updated PrefuseConfig to support logging output to file system. Added DelmitedTextTableWriter. Added CompositeTupleSet. Added directionality to edges, increased support to EdgeRenderer, including reversed directionality.
@
text
@d39 7
a45 7
	protected int     m_edgeType  = Constants.EDGE_TYPE_LINE;
	protected int     m_xAlign1   = Constants.CENTER;
	protected int     m_yAlign1   = Constants.CENTER;
	protected int     m_xAlign2   = Constants.CENTER;
	protected int     m_yAlign2   = Constants.CENTER;
	protected int     m_width     = 1;
	protected int     m_curWidth  = 1;
d52 1
a52 1
	protected int     m_edgeArrow = Constants.EDGE_ARROW_FORWARD;
d67 1
a67 1

a68 4
        this(edgeType, Constants.EDGE_ARROW_FORWARD);
    }
	
    public EdgeRenderer(int edgeType, int edgeArrow) {
a70 1
        setArrowType(edgeArrow);
d77 6
a82 2
		return RENDER_TYPE_DRAW;
	}
d118 1
a118 1
	}
a124 1
		
d126 1
a126 2
		if ( e.isDirected() && m_edgeArrow != Constants.EDGE_ARROW_NONE ) {
			boolean forward = (m_edgeArrow == Constants.EDGE_ARROW_FORWARD);
d130 7
a136 2
			int type = item.canGetInt(EDGE_TYPE) ? item.getInt(EDGE_TYPE) 
												 : m_edgeType;
d139 2
a140 2
					start = m_tmpPoints[forward?0:1];
					end   = m_tmpPoints[forward?1:0];
d144 2
a145 2
					start = m_tmpPoints[forward?0:1];
					end   = m_tmpPoints[forward?1:0];
d151 5
a155 5
			VisualItem dest = forward ? e.getTargetItem() : e.getSourceItem();
			// TODO: generalize this to work for curved edges, too.
			int i = GeometryLib.intersectLineRectangle(start, end,
					    dest.getBounds(), m_isctPoints);
			if ( i > 0 ) end = m_isctPoints[0];
d161 1
a161 1
	}
d177 1
a177 1
	}
d184 1
a184 1
	}
d241 1
a241 1
	}
d260 1
a260 1
	}
d269 1
a269 1
	}
a276 3
		if ( type < 0 || type >= Constants.EDGE_TYPE_COUNT )
			throw new IllegalArgumentException(
					"Unrecognized edge curve type: "+type);
d278 1
a278 10
	}
  	
	/**
	 * Returns the type of the drawn edge. This is either EDGE_TYPE_LINE or
	 * EDGE_TYPE_CURVE.
	 * @@return the edge type
	 */
	public int getArrowType() {
		return m_edgeArrow;
	}
a279 14
	/**
	 * Sets the type of the drawn edge. This is either
	 * EDGE_ARROW_NONE for no edge arrows,
	 * EDGE_ARROW_FORWARD for arrows from source to target on directed edges, or
	 * EDGE_ARROW_REVERSE for arrows from target to source on directed edges.
	 * @@param type the new arrow type
	 */
	public void setArrowType(int type) {
		if ( type < 0 || type >= Constants.EDGE_ARROW_COUNT )
			throw new IllegalArgumentException(
					"Unrecognized edge arrow type: "+type);
		m_edgeArrow = type;
	}
	
d286 1
a286 1
	}
d294 1
a294 1
	}
d302 1
a302 1
	}
d310 1
a310 1
	}
d318 1
a318 1
	}
d326 1
a326 1
	}
d334 1
a334 1
	}
d342 1
a342 1
	}
d350 1
a350 1
	}
d352 1
a352 1
} // end of class EdgeRenderer
@


1.1.2.3
log
@Added support for aggregates as a visual data type (AggregateItem, AggregateTable).
Added listener callback to DataSourceWorker.
Reworked graph representation to use an internal table of adjacency lists (the "links" table).
Added spanning tree functionality for all graph instances.
Reworked RadialTreeLayout. Updated PolarLocationAnimator to use an externally defined set for linear Cartesian interpolation cases.
Fixed out-of-order row manager indexing bug in CascadedTable -- all row indexing is now complete once a table insert event is fired.
Made filterRows() public in CascadedTable.
Reorganized visual data support classes to prefuse.visual.tuple package.
@
text
@d15 1
a15 1
import prefuse.util.GraphicsLib;
d151 1
a151 1
			int i = GraphicsLib.intersectLineRectangle(start, end,
@


1.1.2.4
log
@Replaced all tab characters with 4 spaces.
Ensured UNIX style line endings.
@
text
@d30 37
a66 37
    public static final String EDGE_TYPE = "edgeType";
    
    protected static final double HALF_PI = Math.PI / 2;
    protected static final Polygon DEFAULT_ARROW_HEAD =
        new Polygon(new int[] {0,-4,4,0}, new int[] {0,-12,-12,0}, 4);
    
    protected Line2D       m_line  = new Line2D.Float();
    protected CubicCurve2D m_cubic = new CubicCurve2D.Float();

    protected int     m_edgeType  = Constants.EDGE_TYPE_LINE;
    protected int     m_xAlign1   = Constants.CENTER;
    protected int     m_yAlign1   = Constants.CENTER;
    protected int     m_xAlign2   = Constants.CENTER;
    protected int     m_yAlign2   = Constants.CENTER;
    protected int     m_width     = 1;
    protected int     m_curWidth  = 1;
    protected Point2D m_tmpPoints[]  = new Point2D[2];
    protected Point2D m_ctrlPoints[] = new Point2D[2];
    protected Point2D m_isctPoints[] = new Point2D[2];
    
    protected String  m_weightLabel = "weight";
    
    protected int     m_edgeArrow = Constants.EDGE_ARROW_FORWARD;
    protected Polygon m_arrowHead = DEFAULT_ARROW_HEAD;
    protected AffineTransform m_arrowTrans = new AffineTransform();

    /**
     * Constructor.
     */
    public EdgeRenderer() {
        m_tmpPoints[0]  = new Point2D.Float();
        m_tmpPoints[1]  = new Point2D.Float();
        m_ctrlPoints[0] = new Point2D.Float();
        m_ctrlPoints[1] = new Point2D.Float();      
        m_isctPoints[0] = new Point2D.Float();
        m_isctPoints[1] = new Point2D.Float();      
    }
d71 1
a71 1
    
d77 50
a126 50
    
    /**
     * @@see prefuse.render.ShapeRenderer#getRenderType()
     */
    public int getRenderType(VisualItem item) {
        return RENDER_TYPE_DRAW;
    }
    
    /**
     * @@see prefuse.render.ShapeRenderer#getRawShape(prefuse.a_old.VisualItem)
     */
    protected Shape getRawShape(VisualItem item) {
        EdgeItem   edge = (EdgeItem)item;
        VisualItem item1 = edge.getSourceItem();
        VisualItem item2 = edge.getTargetItem();
        
        int type = m_edgeType;
        
        getAlignedPoint(m_tmpPoints[0], item1.getBounds(),
                        m_xAlign1, m_yAlign1);
        getAlignedPoint(m_tmpPoints[1], item2.getBounds(),
                        m_xAlign2, m_yAlign2);
        double n1x = m_tmpPoints[0].getX();
        double n1y = m_tmpPoints[0].getY();
        double n2x = m_tmpPoints[1].getX();
        double n2y = m_tmpPoints[1].getY();
        m_curWidth = getLineWidth(item);
        
        switch ( type ) {
            case Constants.EDGE_TYPE_LINE:          
                m_line.setLine(n1x, n1y, n2x, n2y);
                return m_line;
            case Constants.EDGE_TYPE_CURVE:
                getCurveControlPoints(edge, m_ctrlPoints,n1x,n1y,n2x,n2y);
                m_cubic.setCurve(n1x, n1y,
                                m_ctrlPoints[0].getX(), m_ctrlPoints[0].getY(),
                                m_ctrlPoints[1].getX(), m_ctrlPoints[1].getY(),
                                n2x,n2y);
                return m_cubic;
            default:
                throw new IllegalStateException("Unknown edge type");
        }   
    }

    /**
     * @@see prefuse.render.Renderer#render(java.awt.Graphics2D, prefuse.a_old.VisualItem)
     */
    public void render(Graphics2D g, VisualItem item) {
        super.render(g, item);
        
d128 27
a154 27
        if ( e.isDirected() && m_edgeArrow != Constants.EDGE_ARROW_NONE ) {
            boolean forward = (m_edgeArrow == Constants.EDGE_ARROW_FORWARD);
            Point2D start = null, end = null;
            int width;
            
            int type = item.canGetInt(EDGE_TYPE) ? item.getInt(EDGE_TYPE) 
                                                 : m_edgeType;
            switch ( type ) {
                case Constants.EDGE_TYPE_LINE:
                    start = m_tmpPoints[forward?0:1];
                    end   = m_tmpPoints[forward?1:0];
                    width = m_width;
                    break;
                case Constants.EDGE_TYPE_CURVE:
                    start = m_tmpPoints[forward?0:1];
                    end   = m_tmpPoints[forward?1:0];
                    width = 1;
                    break;
                default:
                    throw new IllegalStateException("Unknown edge type.");
            }
            VisualItem dest = forward ? e.getTargetItem() : e.getSourceItem();
            // TODO: generalize this to work for curved edges, too.
            int i = GraphicsLib.intersectLineRectangle(start, end,
                        dest.getBounds(), m_isctPoints);
            if ( i > 0 ) end = m_isctPoints[0];
            AffineTransform at = getArrowTrans(start, end, width);
d156 27
a182 27
            g.setPaint(ColorLib.getColor(item.getFillColor()));
            g.fill(arrowHead);
        }
    }

    /**
     * Returns an affine transformation that maps the arrowhead shape
     * to the position and orientation specified by the provided
     * line segment end points.
     */
    protected AffineTransform getArrowTrans(Point2D p1, Point2D p2, int width) {
        m_arrowTrans.setToTranslation(p2.getX(), p2.getY());
        m_arrowTrans.rotate(-HALF_PI + 
            Math.atan2(p2.getY()-p1.getY(), p2.getX()-p1.getX()));
        if ( width > 1 ) {
            double scalar = (2.0*(width-1))/4+1;
            m_arrowTrans.scale(scalar, scalar);
        }
        return m_arrowTrans;
    }

    /**
     * @@see prefuse.render.ShapeRenderer#getTransform(prefuse.a_old.VisualItem)
     */
    protected AffineTransform getTransform(VisualItem item) {
        return null;
    }
d201 9
a209 9
    /**
     * Returns the line width to be used for this VisualItem. By default,
     * returns the value set using the <code>setWidth</code> method.
     * Subclasses should override this method to perform custom line
     * width determination.
     * @@param item the VisualItem for which to determine the line width
     * @@return the desired line width, in pixels
     */
    protected int getLineWidth(VisualItem item) {
d211 1
a211 1
    }
d220 6
a225 6
    /**
     * Determines the control points to use for cubic (Bezier) curve edges. 
     * Override this method to provide custom curve specifications.
     * To reduce object initialization, the entries of the Point2D array are
     * already initialized, so use the <tt>Point2D.setLocation()</tt> method rather than
     * <tt>new Point2D.Double()</tt> to more efficiently set custom control points.
d227 148
a374 148
     * @@param cp array of Point2D's (length >= 2) in which to return the control points
     * @@param x1 the x co-ordinate of the first node this edge connects to
     * @@param y1 the y co-ordinate of the first node this edge connects to
     * @@param x2 the x co-ordinate of the second node this edge connects to
     * @@param y2 the y co-ordinate of the second node this edge connects to
     */
    protected void getCurveControlPoints(EdgeItem eitem, Point2D[] cp, 
                    double x1, double y1, double x2, double y2) 
    {
        double dx = x2-x1, dy = y2-y1;      
        cp[0].setLocation(x1+2*dx/3,y1);
        cp[1].setLocation(x2-dx/8,y2-dy/8);
    }

    /**
     * Helper method, which calculates the top-left co-ordinate of a rectangle
     * given the rectangle's alignment.
     */
    protected static void getAlignedPoint(Point2D p, Rectangle2D r, int xAlign, int yAlign) {
        double x = r.getX(), y = r.getY(), w = r.getWidth(), h = r.getHeight();
        if ( xAlign == Constants.CENTER ) {
            x = x+(w/2);
        } else if ( xAlign == Constants.RIGHT ) {
            x = x+w;
        }
        if ( yAlign == Constants.CENTER ) {
            y = y+(h/2);
        } else if ( yAlign == Constants.BOTTOM ) {
            y = y+h;
        }
        p.setLocation(x,y);
    }

    /**
     * Returns the type of the drawn edge. This is either EDGE_TYPE_LINE or
     * EDGE_TYPE_CURVE.
     * @@return the edge type
     */
    public int getEdgeType() {
        return m_edgeType;
    }
    
    /**
     * Sets the type of the drawn edge. This is either EDGE_TYPE_LINE or
     * EDGE_TYPE_CURVE.
     * @@param type the new edge type
     */
    public void setEdgeType(int type) {
        if ( type < 0 || type >= Constants.EDGE_TYPE_COUNT )
            throw new IllegalArgumentException(
                    "Unrecognized edge curve type: "+type);
        m_edgeType = type;
    }
    
    /**
     * Returns the type of the drawn edge. This is either EDGE_TYPE_LINE or
     * EDGE_TYPE_CURVE.
     * @@return the edge type
     */
    public int getArrowType() {
        return m_edgeArrow;
    }
    
    /**
     * Sets the type of the drawn edge. This is either
     * EDGE_ARROW_NONE for no edge arrows,
     * EDGE_ARROW_FORWARD for arrows from source to target on directed edges, or
     * EDGE_ARROW_REVERSE for arrows from target to source on directed edges.
     * @@param type the new arrow type
     */
    public void setArrowType(int type) {
        if ( type < 0 || type >= Constants.EDGE_ARROW_COUNT )
            throw new IllegalArgumentException(
                    "Unrecognized edge arrow type: "+type);
        m_edgeArrow = type;
    }
    
    /**
     * Get the horizontal aligment of the edge mount point with the first node.
     * @@return the horizontal alignment
     */
    public int getHorizontalAlignment1() {
        return m_xAlign1;
    }
    
    /**
     * Get the vertical aligment of the edge mount point with the first node.
     * @@return the vertical alignment
     */
    public int getVerticalAlignment1() {
        return m_yAlign1;
    }

    /**
     * Get the horizontal aligment of the edge mount point with the second node.
     * @@return the horizontal alignment
     */
    public int getHorizontalAlignment2() {
        return m_xAlign2;
    }
    
    /**
     * Get the vertical aligment of the edge mount point with the second node.
     * @@return the vertical alignment
     */
    public int getVerticalAlignment2() {
        return m_yAlign2;
    }
    
    /**
     * Set the horizontal aligment of the edge mount point with the first node.
     * @@param align the horizontal alignment
     */
    public void setHorizontalAlignment1(int align) {
        m_xAlign1 = align;
    }
    
    /**
     * Set the vertical aligment of the edge mount point with the first node.
     * @@param align the vertical alignment
     */
    public void setVerticalAlignment1(int align) {
        m_yAlign1 = align;
    }

    /**
     * Set the horizontal aligment of the edge mount point with the second node.
     * @@param align the horizontal alignment
     */
    public void setHorizontalAlignment2(int align) {
        m_xAlign2 = align;
    }
    
    /**
     * Set the vertical aligment of the edge mount point with the second node.
     * @@param align the vertical alignment
     */
    public void setVerticalAlignment2(int align) {
        m_yAlign2 = align;
    }
    
    /**
     * Sets the desired width of lines.
     * @@param w the desired line width, in pixels
     */
    public void setWidth(int w) {
        m_width = w;
    }
@


1.1.2.5
log
@Much more javadoc
@
text
@d22 2
a23 8
 * <p>Renderer that draws edges as lines connecting nodes. Both
 * straight and curved lines are supported. Curved lines are drawn using
 * cubic Bezier curves. Subclasses can override the
 * {@@link #getCurveControlPoints(EdgeItem, Point2D[], double, double, double, double)}
 * method to provide custom control point assignment for such curves.</p>
 * 
 * <p>This class also supports arrows for directed edges. See the
 * {@@link #setArrowType(int)} method for more.</p>
d57 1
a57 1
     * Create a new EdgeRenderer.
a67 6
    /**
     * Create a new EdgeRenderer with the given edge type.
     * @@param edgeType the edge type, one of
     * {@@link prefuse.Constants#EDGE_TYPE_LINE} or
     * {@@link prefuse.Constants#EDGE_TYPE_CURVE}.
     */
d72 1
a72 12
    /**
     * Create a new EdgeRenderer with the given edge and arrow types.
     * @@param edgeType the edge type, one of
     * {@@link prefuse.Constants#EDGE_TYPE_LINE} or
     * {@@link prefuse.Constants#EDGE_TYPE_CURVE}.
     * @@param arrowType the arrow type, one of
     * {@@link prefuse.Constants#EDGE_ARROW_FORWARD},
     * {@@link prefuse.Constants#EDGE_ARROW_REVERSE}, or
     * {@@link prefuse.Constants#EDGE_ARROW_NONE}.
     * @@see #setArrowType(int)
     */
    public EdgeRenderer(int edgeType, int arrowType) {
d75 1
a75 1
        setArrowType(arrowType);
d178 1
a178 1
     * @@see prefuse.render.ShapeRenderer#getTransform(prefuse.visual.VisualItem)
d185 2
a186 1
     * @@see prefuse.render.Renderer#locatePoint(java.awt.geom.Point2D, prefuse.visual.VisualItem)
d214 1
a214 1
     * @@see prefuse.render.ShapeRenderer#getStroke(prefuse.visual.VisualItem)
d261 2
a262 3
     * Returns the type of the drawn edge. This is one of
     * {@@link prefuse.Constants#EDGE_TYPE_LINE} or
     * {@@link prefuse.Constants#EDGE_TYPE_CURVE}.
d270 2
a271 3
     * Sets the type of the drawn edge. This must be one of
    * {@@link prefuse.Constants#EDGE_TYPE_LINE} or
    * {@@link prefuse.Constants#EDGE_TYPE_CURVE}.
d282 2
a283 4
     * Returns the type of the drawn edge. This is one of
     * {@@link prefuse.Constants#EDGE_ARROW_FORWARD},
     * {@@link prefuse.Constants#EDGE_ARROW_REVERSE}, or
     * {@@link prefuse.Constants#EDGE_ARROW_NONE}.
d292 3
a294 5
     * {@@link prefuse.Constants#EDGE_ARROW_NONE} for no edge arrows,
     * {@@link prefuse.Constants#EDGE_ARROW_FORWARD} for arrows from source to
     *  target on directed edges, or
     * {@@link prefuse.Constants#EDGE_ARROW_REVERSE} for arrows from target to
     *  source on directed edges.
d306 1
a306 2
     * @@return the horizontal alignment, one of {@@link prefuse.Constants#LEFT},
     * {@@link prefuse.Constants#RIGHT}, or {@@link prefuse.Constants#CENTER}.
d314 1
a314 2
     * @@return the vertical alignment, one of {@@link prefuse.Constants#TOP},
     * {@@link prefuse.Constants#BOTTOM}, or {@@link prefuse.Constants#CENTER}.
d321 2
a322 4
     * Get the horizontal aligment of the edge mount point with the second
     * node.
     * @@return the horizontal alignment, one of {@@link prefuse.Constants#LEFT},
     * {@@link prefuse.Constants#RIGHT}, or {@@link prefuse.Constants#CENTER}.
d330 1
a330 2
     * @@return the vertical alignment, one of {@@link prefuse.Constants#TOP},
     * {@@link prefuse.Constants#BOTTOM}, or {@@link prefuse.Constants#CENTER}.
d338 1
a338 3
     * @@param align the horizontal alignment, one of 
     * {@@link prefuse.Constants#LEFT}, {@@link prefuse.Constants#RIGHT}, or
     * {@@link prefuse.Constants#CENTER}.
d346 1
a346 3
     * @@param align the vertical alignment, one of
     * {@@link prefuse.Constants#TOP}, {@@link prefuse.Constants#BOTTOM}, or
     * {@@link prefuse.Constants#CENTER}.
d353 2
a354 5
     * Set the horizontal aligment of the edge mount point with the second
     * node.
     * @@param align the horizontal alignment, one of
     * {@@link prefuse.Constants#LEFT}, {@@link prefuse.Constants#RIGHT}, or
     * {@@link prefuse.Constants#CENTER}.
d362 1
a362 3
     * @@param align the vertical alignment, one of
     * {@@link prefuse.Constants#TOP}, {@@link prefuse.Constants#BOTTOM}, or
     * {@@link prefuse.Constants#CENTER}.
d369 1
a369 1
     * Sets the desired default width of lines.
@


1.1.2.6
log
@Javadoc'd.
@
text
@d102 1
a102 1
     * @@see prefuse.render.ShapeRenderer#getRenderType(prefuse.visual.VisualItem)
d109 1
a109 1
     * @@see prefuse.render.ShapeRenderer#getRawShape(prefuse.visual.VisualItem)
d145 1
a145 1
     * @@see prefuse.render.Renderer#render(java.awt.Graphics2D, prefuse.visual.VisualItem)
@


1.1.2.7
log
@Standardized @@author tag contents
Added toggle for enabling/disabling damage/redraw
EdgeRenderer now cleanly pulls edge widths from the size field
Refactored TupleManager to a single reusable class
@
text
@d32 1
a32 1
 * @@author <a href="http://jheer.org">jeffrey heer</a>
d50 1
a50 1
    protected double  m_width     = 1;
d126 1
a126 1
        m_curWidth = (int)Math.round(m_width * getLineWidth(item));
d154 1
a154 1
            double width = m_width * getLineWidth(item);
d162 1
d167 1
d189 1
a189 3
    protected AffineTransform getArrowTrans(Point2D p1, Point2D p2, 
                                            double width)
    {
d194 1
a194 1
            double scalar = width/4;
d225 3
a227 5
     * returns the base width value set using the {@@link #setBaseWidth(double)}
     * method, scaled by the item size returned by
     * {@@link VisualItem#getSize()}. Subclasses can override this method to
     * perform custom line width determination, however, the preferred
     * method is to change the item size value itself.
d231 2
a232 2
    protected double getLineWidth(VisualItem item) {
        return item.getSize();
d411 2
a412 4
     * Sets the base width of lines. This width value will
     * be scaled by the value of an item's size data field. The default
     * base width is 1.
     * @@param w the desired base line width, in pixels
d414 1
a414 1
    public void setBaseWidth(double w) {
a416 10
    
    /**
     * Gets the base width of lines. This width value that will
     * be scaled by the value of an item's size data field. The default
     * base width is 1.
     * @@return the base line width, in pixels
     */
    public double getBaseWidth() {
        return m_width;
    }
@


1.1.2.8
log
@Various pre-release edits
Added RadialGraphView
Added new applets
Renamed ShapeRenderer to AbstractShapeRenderer
Renamed ShapeItemRenderer to ShapeRenderer
Merged TextItemRenderer and ImageItemRenderer into LabelRenderer
Removed demo launcher (and commented line in build.xml), will reintroduce demo launcher later
@
text
@d34 1
a34 1
public class EdgeRenderer extends AbstractShapeRenderer {
d102 1
a102 1
     * @@see prefuse.render.AbstractShapeRenderer#getRenderType(prefuse.visual.VisualItem)
d109 1
a109 1
     * @@see prefuse.render.AbstractShapeRenderer#getRawShape(prefuse.visual.VisualItem)
d201 1
a201 1
     * @@see prefuse.render.AbstractShapeRenderer#getTransform(prefuse.visual.VisualItem)
d238 1
a238 1
     * @@see prefuse.render.AbstractShapeRenderer#getStroke(prefuse.visual.VisualItem)
@


1.1.2.9
log
@Changed interaction mechanism of RotationControl
Added documentation of expression language to ExpressionParser javadoc
Added inclusion of edge arrows in bounds computation for EdgeRenderer
Added integer dimensions check to LabelRenderer
Added new readme file
@
text
@a60 1
    protected Shape   m_curArrow;
a127 2
        // create the edge shape
        Shape shape = null;
d131 1
a131 2
                shape = m_line;
                break;
d137 2
a138 3
                                n2x, n2y);
                shape = m_cubic;
                break;
d141 8
a148 1
        }
a149 1
        // create the arrow head, if needed
d155 3
a157 1

d173 1
a173 1
                    dest.getBounds(), m_isctPoints);
d176 1
a176 15
            m_curArrow = at.createTransformedShape(m_arrowHead);
        } else {
            m_curArrow = null;
        }

        // return the edge shape
        return shape;
    }

    /**
     * @@see prefuse.render.Renderer#render(java.awt.Graphics2D, prefuse.visual.VisualItem)
     */
    public void render(Graphics2D g, VisualItem item) {
        super.render(g, item);
        if ( m_curArrow != null ) {
d178 1
a178 1
            g.fill(m_curArrow);
a221 17
    
    /**
     * @@see prefuse.render.Renderer#setBounds(prefuse.visual.VisualItem)
     */
    public void setBounds(VisualItem item) {
        if ( !m_manageBounds ) return;
        Shape s = getShape(item);
        if ( s == null ) {
            item.setBounds(item.getX(), item.getY(), 0, 0);
            return;
        }
        GraphicsLib.setBounds(item, s, getStroke(item));
        if ( m_curArrow != null ) {
            Rectangle2D bbox = (Rectangle2D)item.get(VisualItem.BOUNDS);
            Rectangle2D.union(bbox, m_curArrow.getBounds2D(), bbox);
        }
    }
@


