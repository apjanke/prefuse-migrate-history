head	2.2;
access;
symbols
	java_1_5:2.2.0.4
	Root_java_1_5:2.2
	beta:2.2.0.2
	beta-20080113:2.2
	beta-20071021:2.2
	beta-20060220:2.1
	beta-20060209:2.0;
locks; strict;
comment	@# @;


2.2
date	2006.03.06.00.33.58;	author jheer;	state Exp;
branches
	2.2.4.1;
next	2.1;

2.1
date	2006.02.17.18.08.28;	author jheer;	state Exp;
branches;
next	2.0;

2.0
date	2006.02.12.18.23.45;	author jheer;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.09.05.12.45;	author jheer;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2006.02.09.05.12.45;	author jheer;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2006.02.09.10.33.59;	author jheer;	state Exp;
branches;
next	;

2.2.4.1
date	2008.01.23.23.55.44;	author jogiles;	state Exp;
branches;
next	2.2.4.2;

2.2.4.2
date	2008.02.26.05.02.53;	author amarsden;	state Exp;
branches;
next	2.2.4.3;

2.2.4.3
date	2008.03.03.05.19.17;	author amarsden;	state Exp;
branches;
next	2.2.4.4;

2.2.4.4
date	2008.04.01.03.32.45;	author amarsden;	state Exp;
branches;
next	2.2.4.5;

2.2.4.5
date	2008.04.14.04.59.42;	author amarsden;	state Exp;
branches;
next	2.2.4.6;

2.2.4.6
date	2008.04.28.02.40.09;	author amarsden;	state Exp;
branches;
next	;


desc
@@


2.2
log
@Added multi-line text support
Added image/text positioning and alignment options
@
text
@package prefuse.render;

import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.RectangularShape;
import java.awt.geom.RoundRectangle2D;

import prefuse.Constants;
import prefuse.util.ColorLib;
import prefuse.util.FontLib;
import prefuse.util.GraphicsLib;
import prefuse.util.StringLib;
import prefuse.visual.VisualItem;


/**
 * Renderer that draws a label, which consists of a text string,
 * an image, or both.
 * 
 * <p>When created using the default constructor, the renderer attempts
 * to use text from the "label" field. To use a different field, use the
 * appropriate constructor or use the {@@link #setTextField(String)} method.
 * To perform custom String selection, subclass this Renderer and override the 
 * {@@link #getText(VisualItem)} method. When the text field is
 * <code>null</code>, no text label will be shown. Labels can span multiple
 * lines of text, determined by the presence of newline characters ('\n')
 * within the text string.</p>
 * 
 * <p>By default, no image is shown. To show an image, the image field needs
 * to be set, either using the appropriate constructor or the
 * {@@link #setImageField(String)} method. The value of the image field should
 * be a text string indicating the location of the image file to use. The
 * string should be either a URL, a file located on the current classpath,
 * or a file on the local filesystem. If found, the image will be managed
 * internally by an {@@link ImageFactory} instance, which maintains a
 * cache of loaded images.</p>
 * 
 * <p>The position of the image relative to text can be set using the
 * {@@link #setImagePosition(int)} method. Images can be placed to the
 * left, right, above, or below the text. The horizontal and vertical
 * alignments of either the text or the image can be set explicitly
 * using the appropriate methods of this class (e.g.,
 * {@@link #setHorizontalTextAlignment(int)}). By default, both the
 * text and images are centered along both the horizontal and
 * vertical directions.</p>
 * 
 * @@author <a href="http://jheer.org">jeffrey heer</a>
 */
public class LabelRenderer extends AbstractShapeRenderer {

    protected ImageFactory m_images = null;
    protected String m_delim = "\n";
    
    protected String m_labelName = "label";
    protected String m_imageName = null;
    
    protected int m_xAlign = Constants.CENTER;
    protected int m_yAlign = Constants.CENTER;
    protected int m_hTextAlign = Constants.CENTER;
    protected int m_vTextAlign = Constants.CENTER;
    protected int m_hImageAlign = Constants.CENTER;
    protected int m_vImageAlign = Constants.CENTER;
    protected int m_imagePos = Constants.LEFT;
    
    protected int m_horizBorder = 2;
    protected int m_vertBorder  = 0;
    protected int m_imageMargin = 2;
    protected int m_arcWidth    = 0;
    protected int m_arcHeight   = 0;

    protected int m_maxTextWidth = -1;
    
    /** Transform used to scale and position images */
    AffineTransform m_transform = new AffineTransform();
    
    /** The holder for the currently computed bounding box */
    protected RectangularShape m_bbox  = new Rectangle2D.Double();
    protected Point2D m_pt = new Point2D.Double(); // temp point
    protected Font    m_font; // temp font holder
    protected String    m_text; // label text
    protected Dimension m_textDim = new Dimension(); // text width / height

    /**
     * Create a new LabelRenderer. By default the field "label" is used
     * as the field name for looking up text, and no image is used.
     */
    public LabelRenderer() {
    }
    
    /**
     * Create a new LabelRenderer. Draws a text label using the given
     * text data field and does not draw an image.
     * @@param textField the data field for the text label.
     */
    public LabelRenderer(String textField) {
        this.setTextField(textField);
    }
    
    /**
     * Create a new LabelRenderer. Draws a text label using the given text
     * data field, and draws the image at the location reported by the
     * given image data field.
     * @@param textField the data field for the text label
     * @@param imageField the data field for the image location. This value
     * in the data field should be a URL, a file within the current classpath,
     * a file on the filesystem, or null for no image. If the
     * <code>imageField</code> parameter is null, no images at all will be
     * drawn.
     */
    public LabelRenderer(String textField, String imageField) {
        setTextField(textField);
        setImageField(imageField);
    }
    
    // ------------------------------------------------------------------------
    
    /**
     * Rounds the corners of the bounding rectangle in which the text
     * string is rendered. This will only be seen if either the stroke
     * or fill color is non-transparent.
     * @@param arcWidth the width of the curved corner
     * @@param arcHeight the height of the curved corner
     */
    public void setRoundedCorner(int arcWidth, int arcHeight) {
        if ( (arcWidth == 0 || arcHeight == 0) && 
            !(m_bbox instanceof Rectangle2D) ) {
            m_bbox = new Rectangle2D.Double();
        } else {
            if ( !(m_bbox instanceof RoundRectangle2D) )
                m_bbox = new RoundRectangle2D.Double();
            ((RoundRectangle2D)m_bbox)
                .setRoundRect(0,0,10,10,arcWidth,arcHeight);
            m_arcWidth = arcWidth;
            m_arcHeight = arcHeight;
        }
    }

    /**
     * Get the field name to use for text labels.
     * @@return the data field for text labels, or null for no text
     */
    public String getTextField() {
        return m_labelName;
    }
    
    /**
     * Set the field name to use for text labels.
     * @@param textField the data field for text labels, or null for no text
     */
    public void setTextField(String textField) {
        m_labelName = textField;
    }
    
    /**
     * Sets the maximum width that should be allowed of the text label.
     * A value of -1 specifies no limit (this is the default).
     * @@param maxWidth the maximum width of the text or -1 for no limit
     */
    public void setMaxTextWidth(int maxWidth) {
        m_maxTextWidth = maxWidth;
    }
    
    /**
     * Returns the text to draw. Subclasses can override this class to
     * perform custom text selection.
     * @@param item the item to represent as a <code>String</code>
     * @@return a <code>String</code> to draw
     */
    protected String getText(VisualItem item) {
        String s = null;
        if ( item.canGetString(m_labelName) ) {
            return item.getString(m_labelName);            
        }
        return s;
    }

    // ------------------------------------------------------------------------
    // Image Handling
    
    /**
     * Get the data field for image locations. The value stored
     * in the data field should be a URL, a file within the current classpath,
     * a file on the filesystem, or null for no image.
     * @@return the data field for image locations, or null for no images
     */
    public String getImageField() {
        return m_imageName;
    }
    
    /**
     * Set the data field for image locations. The value stored
     * in the data field should be a URL, a file within the current classpath,
     * a file on the filesystem, or null for no image. If the
     * <code>imageField</code> parameter is null, no images at all will be
     * drawn.
     * @@param imageField the data field for image locations, or null for
     * no images
     */
    public void setImageField(String imageField) {
        if ( imageField != null ) m_images = new ImageFactory();
        m_imageName = imageField;
    }
    
    /**
     * Sets the maximum image dimensions, used to control scaling of loaded
     * images. This scaling is enforced immediately upon loading of the image.
     * @@param width the maximum width of images (-1 for no limit)
     * @@param height the maximum height of images (-1 for no limit)
     */
    public void setMaxImageDimensions(int width, int height) {
        if ( m_images == null ) m_images = new ImageFactory();
        m_images.setMaxImageDimensions(width, height);
    }
    
    /**
     * Returns a location string for the image to draw. Subclasses can override 
     * this class to perform custom image selection beyond looking up the value
     * from a data field.
     * @@param item the item for which to select an image to draw
     * @@return the location string for the image to use, or null for no image
     */
    protected String getImageLocation(VisualItem item) {
        return item.canGetString(m_imageName)
                ? item.getString(m_imageName)
                : null;
    }
    
    /**
     * Get the image to include in the label for the given VisualItem.
     * @@param item the item to get an image for
     * @@return the image for the item, or null for no image
     */
    protected Image getImage(VisualItem item) {
        String imageLoc = getImageLocation(item);
        return ( imageLoc == null ? null : m_images.getImage(imageLoc) );
    }
    
    
    // ------------------------------------------------------------------------
    // Rendering
    
    private String computeTextDimensions(VisualItem item, String text,
                                         double size)
    {
        // put item font in temp member variable
        m_font = item.getFont();
        // scale the font as needed
        if ( size != 1 ) {
            m_font = FontLib.getFont(m_font.getName(), m_font.getStyle(),
                                     size*m_font.getSize());
        }
        
        FontMetrics fm = DEFAULT_GRAPHICS.getFontMetrics(m_font);
        StringBuffer str = null;
        
        // compute the number of lines and the maximum width
        int nlines = 1, w = 0, start = 0, end = text.indexOf(m_delim);
        m_textDim.width = 0;
        String line;
        for ( ; end >= 0; ++nlines ) {
            w = fm.stringWidth(line=text.substring(start,end));
            // abbreviate line as needed
            if ( m_maxTextWidth > -1 && w > m_maxTextWidth ) {
                if ( str == null )
                    str = new StringBuffer(text.substring(0,start));
                str.append(StringLib.abbreviate(line, fm, m_maxTextWidth));
                str.append(m_delim);
                w = m_maxTextWidth;
            } else if ( str != null ) {
                str.append(line).append(m_delim);
            }
            // update maximum width and substring indices
            m_textDim.width = Math.max(m_textDim.width, w);
            start = end+1;
            end = text.indexOf(m_delim, start);
        }
        w = fm.stringWidth(line=text.substring(start));
        // abbreviate line as needed
        if ( m_maxTextWidth > -1 && w > m_maxTextWidth ) {
            if ( str == null )
                str = new StringBuffer(text.substring(0,start));
            str.append(StringLib.abbreviate(line, fm, m_maxTextWidth));
            w = m_maxTextWidth;
        } else if ( str != null ) {
            str.append(line);
        }
        // update maximum width
        m_textDim.width = Math.max(m_textDim.width, w);
        
        // compute the text height
        m_textDim.height = fm.getHeight() * nlines;
        
        return str==null ? text : str.toString();
    }
    
    /**
     * @@see prefuse.render.AbstractShapeRenderer#getRawShape(prefuse.visual.VisualItem)
     */
    protected Shape getRawShape(VisualItem item) {
        m_text = getText(item);
        Image  img  = getImage(item);
        double size = item.getSize();
        
        // get image dimensions
        double iw=0, ih=0;
        if ( img != null ) {
            ih = img.getHeight(null);
            iw = img.getWidth(null);    
        }
        
        // get text dimensions
        int tw=0, th=0;
        if ( m_text != null ) {
            m_text = computeTextDimensions(item, m_text, size);
            th = m_textDim.height;
            tw = m_textDim.width;   
        }
        
        // get bounding box dimensions
        double w=0, h=0;
        switch ( m_imagePos ) {
        case Constants.LEFT:
        case Constants.RIGHT:
            w = tw + size*(iw +2*m_horizBorder
                   + (tw>0 && iw>0 ? m_imageMargin : 0));
            h = Math.max(th, size*ih) + size*2*m_vertBorder;
            break;
        case Constants.TOP:
        case Constants.BOTTOM:
            w = Math.max(tw, size*iw) + size*2*m_horizBorder;
            h = th + size*(ih + 2*m_vertBorder
                   + (th>0 && ih>0 ? m_imageMargin : 0));
            break;
        default:
            throw new IllegalStateException(
                "Unrecognized image alignment setting.");
        }
        
        // get the top-left point, using the current alignment settings
        getAlignedPoint(m_pt, item, w, h, m_xAlign, m_yAlign);
        
        if ( m_bbox instanceof RoundRectangle2D ) {
            RoundRectangle2D rr = (RoundRectangle2D)m_bbox;
            rr.setRoundRect(m_pt.getX(), m_pt.getY(), w, h,
                            size*m_arcWidth, size*m_arcHeight);
        } else {
            m_bbox.setFrame(m_pt.getX(), m_pt.getY(), w, h);
        }
        return m_bbox;
    }
    
    /**
     * Helper method, which calculates the top-left co-ordinate of an item
     * given the item's alignment.
     */
    protected static void getAlignedPoint(Point2D p, VisualItem item, 
            double w, double h, int xAlign, int yAlign)
    {
        double x = item.getX(), y = item.getY();
        if ( Double.isNaN(x) || Double.isInfinite(x) )
            x = 0; // safety check
        if ( Double.isNaN(y) || Double.isInfinite(y) )
            y = 0; // safety check
        
        if ( xAlign == Constants.CENTER ) {
            x = x-(w/2);
        } else if ( xAlign == Constants.RIGHT ) {
            x = x-w;
        }
        if ( yAlign == Constants.CENTER ) {
            y = y-(h/2);
        } else if ( yAlign == Constants.BOTTOM ) {
            y = y-h;
        }
        p.setLocation(x,y);
    }
    
    /**
     * @@see prefuse.render.Renderer#render(java.awt.Graphics2D, prefuse.visual.VisualItem)
     */
    public void render(Graphics2D g, VisualItem item) {
        RectangularShape shape = (RectangularShape)getShape(item);
        if ( shape == null ) return;
        
        // fill the shape, if requested
        int type = getRenderType(item);
        if ( type==RENDER_TYPE_FILL || type==RENDER_TYPE_DRAW_AND_FILL )
            GraphicsLib.paint(g, item, shape, getStroke(item), RENDER_TYPE_FILL);

        // now render the image and text
        String text = m_text;
        Image  img  = getImage(item);
        
        if ( text == null && img == null )
            return;
                        
        double size = item.getSize();
        boolean useInt = 1.5 > Math.max(g.getTransform().getScaleX(),
                                        g.getTransform().getScaleY());
        double x = shape.getMinX() + size*m_horizBorder;
        double y = shape.getMinY() + size*m_vertBorder;
        
        // render image
        if ( img != null ) {            
            double w = size * img.getWidth(null);
            double h = size * img.getHeight(null);
            double ix=x, iy=y;
            
            // determine one co-ordinate based on the image position
            switch ( m_imagePos ) {
            case Constants.LEFT:
                x += w + size*m_imageMargin;
                break;
            case Constants.RIGHT:
                ix = shape.getMaxX() - size*m_horizBorder - w;
                break;
            case Constants.TOP:
                y += h + size*m_imageMargin;
                break;
            case Constants.BOTTOM:
                iy = shape.getMaxY() - size*m_vertBorder - h;
                break;
            default:
                throw new IllegalStateException(
                        "Unrecognized image alignment setting.");
            }
            
            // determine the other coordinate based on image alignment
            switch ( m_imagePos ) {
            case Constants.LEFT:
            case Constants.RIGHT:
                // need to set image y-coordinate
                switch ( m_vImageAlign ) {
                case Constants.TOP:
                    break;
                case Constants.BOTTOM:
                    iy = shape.getMaxY() - size*m_vertBorder - h;
                    break;
                case Constants.CENTER:
                    iy = shape.getCenterY() - h/2;
                    break;
                }
                break;
            case Constants.TOP:
            case Constants.BOTTOM:
                // need to set image x-coordinate
                switch ( m_hImageAlign ) {
                case Constants.LEFT:
                    break;
                case Constants.RIGHT:
                    ix = shape.getMaxX() - size*m_horizBorder - w;
                    break;
                case Constants.CENTER:
                    ix = shape.getCenterX() - w/2;
                    break;
                }
                break;
            }
            
            if ( useInt && size == 1.0 ) {
                // if possible, use integer precision
                // results in faster, flicker-free image rendering
                g.drawImage(img, (int)ix, (int)iy, null);
            } else {
                m_transform.setTransform(size,0,0,size,ix,iy);
                g.drawImage(img, m_transform, null);
            }
        }
        
        // render text
        int textColor = item.getTextColor();
        if ( text != null && ColorLib.alpha(textColor) > 0 ) {
            g.setPaint(ColorLib.getColor(textColor));
            g.setFont(m_font);
            FontMetrics fm = DEFAULT_GRAPHICS.getFontMetrics(m_font);

            // compute available width
            double tw;
            switch ( m_imagePos ) {
            case Constants.TOP:
            case Constants.BOTTOM:
                tw = shape.getWidth() - 2*size*m_horizBorder;
                break;
            default:
                tw = m_textDim.width;
            }
            
            // compute available height
            double th;
            switch ( m_imagePos ) {
            case Constants.LEFT:
            case Constants.RIGHT:
                th = shape.getHeight() - 2*size*m_vertBorder;
                break;
            default:
                th = m_textDim.height;
            }
            
            // compute starting y-coordinate
            y += fm.getAscent();
            switch ( m_vTextAlign ) {
            case Constants.TOP:
                break;
            case Constants.BOTTOM:
                y += th - m_textDim.height;
                break;
            case Constants.CENTER:
                y += (th - m_textDim.height)/2;
            }
            
            // render each line of text
            int lh = fm.getHeight(); // the line height
            int start = 0, end = text.indexOf(m_delim);
            for ( ; end >= 0; y += lh ) {
                drawString(g, fm, text.substring(start, end), useInt, x, y, tw);
                start = end+1;
                end = text.indexOf(m_delim, start);   
            }
            drawString(g, fm, text.substring(start), useInt, x, y, tw);
        }
    
        // draw border
        if (type==RENDER_TYPE_DRAW || type==RENDER_TYPE_DRAW_AND_FILL) {
            GraphicsLib.paint(g,item,shape,getStroke(item),RENDER_TYPE_DRAW);
        }
    }
    
    private final void drawString(Graphics2D g, FontMetrics fm, String text,
            boolean useInt, double x, double y, double w)
    {
        // compute the x-coordinate
        double tx;
        switch ( m_hTextAlign ) {
        case Constants.LEFT:
            tx = x;
            break;
        case Constants.RIGHT:
            tx = x + w - fm.stringWidth(text);
            break;
        case Constants.CENTER:
            tx = x + (w - fm.stringWidth(text)) / 2;
            break;
        default:
            throw new IllegalStateException(
                    "Unrecognized text alignment setting.");
        }
        // use integer precision unless zoomed-in
        // results in more stable drawing
        if ( useInt ) {
            g.drawString(text, (int)tx, (int)y);
        } else {
            g.drawString(text, (float)tx, (float)y);
        }
    }
    
    /**
     * Returns the image factory used by this renderer.
     * @@return the image factory
     */
    public ImageFactory getImageFactory() {
        if ( m_images == null ) m_images = new ImageFactory();
        return m_images;
    }
    
    /**
     * Sets the image factory used by this renderer.
     * @@param ifact the image factory
     */
    public void setImageFactory(ImageFactory ifact) {
        m_images = ifact;
    }
    
    // ------------------------------------------------------------------------
    
    /**
     * Get the horizontal text alignment within the layout. One of
     * {@@link prefuse.Constants#LEFT}, {@@link prefuse.Constants#RIGHT}, or
     * {@@link prefuse.Constants#CENTER}. The default is centered text.
     * @@return the horizontal text alignment
     */
    public int getHorizontalTextAlignment() {
        return m_hTextAlign;
    }
    
    /**
     * Set the horizontal text alignment within the layout. One of
     * {@@link prefuse.Constants#LEFT}, {@@link prefuse.Constants#RIGHT}, or
     * {@@link prefuse.Constants#CENTER}. The default is centered text.
     * @@param halign the desired horizontal text alignment
     */
    public void setHorizontalTextAlignment(int halign) {
        if ( halign != Constants.LEFT &&
             halign != Constants.RIGHT &&
             halign != Constants.CENTER )
           throw new IllegalArgumentException(
                   "Illegal horizontal text alignment value.");
        m_hTextAlign = halign;
    }
    
    /**
     * Get the vertical text alignment within the layout. One of
     * {@@link prefuse.Constants#TOP}, {@@link prefuse.Constants#BOTTOM}, or
     * {@@link prefuse.Constants#CENTER}. The default is centered text.
     * @@return the vertical text alignment
     */
    public int getVerticalTextAlignment() {
        return m_vTextAlign;
    }
    
    /**
     * Set the vertical text alignment within the layout. One of
     * {@@link prefuse.Constants#TOP}, {@@link prefuse.Constants#BOTTOM}, or
     * {@@link prefuse.Constants#CENTER}. The default is centered text.
     * @@param valign the desired vertical text alignment
     */
    public void setVerticalTextAlignment(int valign) {
        if ( valign != Constants.TOP &&
             valign != Constants.BOTTOM &&
             valign != Constants.CENTER )
            throw new IllegalArgumentException(
                    "Illegal vertical text alignment value.");
        m_vTextAlign = valign;
    }
    
    /**
     * Get the horizontal image alignment within the layout. One of
     * {@@link prefuse.Constants#LEFT}, {@@link prefuse.Constants#RIGHT}, or
     * {@@link prefuse.Constants#CENTER}. The default is a centered image.
     * @@return the horizontal image alignment
     */
    public int getHorizontalImageAlignment() {
        return m_hImageAlign;
    }
    
    /**
     * Set the horizontal image alignment within the layout. One of
     * {@@link prefuse.Constants#LEFT}, {@@link prefuse.Constants#RIGHT}, or
     * {@@link prefuse.Constants#CENTER}. The default is a centered image.
     * @@param halign the desired horizontal image alignment
     */
    public void setHorizontalImageAlignment(int halign) {
        if ( halign != Constants.LEFT &&
             halign != Constants.RIGHT &&
             halign != Constants.CENTER )
           throw new IllegalArgumentException(
                   "Illegal horizontal text alignment value.");
        m_hImageAlign = halign;
    }
    
    /**
     * Get the vertical image alignment within the layout. One of
     * {@@link prefuse.Constants#TOP}, {@@link prefuse.Constants#BOTTOM}, or
     * {@@link prefuse.Constants#CENTER}. The default is a centered image.
     * @@return the vertical image alignment
     */
    public int getVerticalImageAlignment() {
        return m_vImageAlign;
    }
    
    /**
     * Set the vertical image alignment within the layout. One of
     * {@@link prefuse.Constants#TOP}, {@@link prefuse.Constants#BOTTOM}, or
     * {@@link prefuse.Constants#CENTER}. The default is a centered image.
     * @@param valign the desired vertical image alignment
     */
    public void setVerticalImageAlignment(int valign) {
        if ( valign != Constants.TOP &&
             valign != Constants.BOTTOM &&
             valign != Constants.CENTER )
            throw new IllegalArgumentException(
                    "Illegal vertical text alignment value.");
        m_vImageAlign = valign;
    }
    
    /**
     * Get the image position, determining where the image is placed with
     * respect to the text. One of {@@link Constants#LEFT},
     * {@@link Constants#RIGHT}, {@@link Constants#TOP}, or
     * {@@link Constants#BOTTOM}.  The default is left.
     * @@return the image position
     */
    public int getImagePosition() {
        return m_imagePos;
    }
    
    /**
     * Set the image position, determining where the image is placed with
     * respect to the text. One of {@@link Constants#LEFT},
     * {@@link Constants#RIGHT}, {@@link Constants#TOP}, or
     * {@@link Constants#BOTTOM}.  The default is left.
     * @@param pos the desired image position
     */
    public void setImagePosition(int pos) {
        if ( pos != Constants.TOP &&
             pos != Constants.BOTTOM &&
             pos != Constants.LEFT &&
             pos != Constants.RIGHT &&
             pos != Constants.CENTER )
           throw new IllegalArgumentException(
                   "Illegal image position value.");
        m_imagePos = pos;
    }
    
    // ------------------------------------------------------------------------
    
    /**
     * Get the horizontal alignment of this node with respect to its
     * x, y coordinates.
     * @@return the horizontal alignment, one of
     * {@@link prefuse.Constants#LEFT}, {@@link prefuse.Constants#RIGHT}, or
     * {@@link prefuse.Constants#CENTER}.
     */
    public int getHorizontalAlignment() {
        return m_xAlign;
    }
    
    /**
     * Get the vertical alignment of this node with respect to its
     * x, y coordinates.
     * @@return the vertical alignment, one of
     * {@@link prefuse.Constants#TOP}, {@@link prefuse.Constants#BOTTOM}, or
     * {@@link prefuse.Constants#CENTER}.
     */
    public int getVerticalAlignment() {
        return m_yAlign;
    }
    
    /**
     * Set the horizontal alignment of this node with respect to its
     * x, y coordinates.
     * @@param align the horizontal alignment, one of
     * {@@link prefuse.Constants#LEFT}, {@@link prefuse.Constants#RIGHT}, or
     * {@@link prefuse.Constants#CENTER}.
     */ 
    public void setHorizontalAlignment(int align) {
        m_xAlign = align;
    }
    
    /**
     * Set the vertical alignment of this node with respect to its
     * x, y coordinates.
     * @@param align the vertical alignment, one of
     * {@@link prefuse.Constants#TOP}, {@@link prefuse.Constants#BOTTOM}, or
     * {@@link prefuse.Constants#CENTER}.
     */ 
    public void setVerticalAlignment(int align) {
        m_yAlign = align;
    }
    
    /**
     * Returns the amount of padding in pixels between the content 
     * and the border of this item along the horizontal dimension.
     * @@return the horizontal padding
     */
    public int getHorizontalPadding() {
        return m_horizBorder;
    }
    
    /**
     * Sets the amount of padding in pixels between the content 
     * and the border of this item along the horizontal dimension.
     * @@param xpad the horizontal padding to set
     */
    public void setHorizontalPadding(int xpad) {
        m_horizBorder = xpad;
    }
    
    /**
     * Returns the amount of padding in pixels between the content 
     * and the border of this item along the vertical dimension.
     * @@return the vertical padding
     */
    public int getVerticalPadding() {
        return m_vertBorder;
    }
    
    /**
     * Sets the amount of padding in pixels between the content 
     * and the border of this item along the vertical dimension.
     * @@param ypad the vertical padding
     */
    public void setVerticalPadding(int ypad) {
        m_vertBorder = ypad;
    }
    
    /**
     * Get the padding, in pixels, between an image and text.
     * @@return the padding between an image and text
     */
    public int getImageTextPadding() {
        return m_imageMargin;
    }
    
    /**
     * Set the padding, in pixels, between an image and text.
     * @@param pad the padding to use between an image and text
     */
    public void setImageTextPadding(int pad) {
        m_imageMargin = pad;
    }
    
} // end of class LabelRenderer
@


2.2.4.1
log
@First import of a Java 1.5-targetted version of prefuse.
@
text
@d15 1
a15 1
import prefuse.Alignment;
d26 1
a26 1
 *
d30 1
a30 1
 * To perform custom String selection, subclass this Renderer and override the
d35 1
a35 1
 *
d44 1
a44 1
 *
d46 1
a46 1
 * {@@link #setImagePosition(Alignment)} method. Images can be placed to the
d50 1
a50 1
 * {@@link #setHorizontalTextAlignment(Alignment)}). By default, both the
d53 1
a53 1
 *
d60 1
a60 1

d63 9
a71 9

    protected Alignment m_xAlign = Alignment.CENTER;
    protected Alignment m_yAlign = Alignment.CENTER;
    protected Alignment m_hTextAlign = Alignment.CENTER;
    protected Alignment m_vTextAlign = Alignment.CENTER;
    protected Alignment m_hImageAlign = Alignment.CENTER;
    protected Alignment m_vImageAlign = Alignment.CENTER;
    protected Alignment m_imagePos = Alignment.LEFT;

d79 1
a79 3

	protected Integer maxLineLength = null;

d82 1
a82 1

d96 1
a96 1

d105 1
a105 1

d121 1
a121 1

d123 1
a123 1

d132 1
a132 1
        if ( (arcWidth == 0 || arcHeight == 0) &&
d136 2
a137 3
            if ( !(m_bbox instanceof RoundRectangle2D) ) {
				m_bbox = new RoundRectangle2D.Double();
			}
d152 1
a152 1

d160 1
a160 1

d169 1
a169 1

d176 7
a182 50
    protected String getText(VisualItem<?> item) {
		String orig = null;
		if (item.canGetString(m_labelName)) {
			orig = item.getString(m_labelName);
		}
		if (orig == null || maxLineLength == null || orig.length() < maxLineLength) {
			return orig;
		}

		StringBuffer buf = new StringBuffer();

		String[] origLines = orig.split(m_delim);

		// find the longest word
		int maxLen = 0;
		for (String element : origLines) {
			String[] words = element.split("\\s+");
			for (String element2 : words) {
				if (element2.length() > maxLen) {
					maxLen = element2.length();
				}
			}
		}

		if (maxLineLength > maxLen) {
			maxLen = maxLineLength;
		}

		for (String element : origLines) {
			if (buf.length() > 0) {
				buf.append('\n');
			}
			String[] words = element.split("\\s+");
			int lineLen = 0;
			for (String word : words) {
				if (lineLen > 0) {
					if (lineLen + 1 + word.length() > maxLen) {
						buf.append('\n');
						lineLen = 0;
					} else {
						buf.append(' ');
					}
				}
				buf.append(word);
				lineLen += word.length();
			}
		}
		return buf.toString();

	}
d186 1
a186 1

d188 5
a192 6
	 * Get the data field for image locations. The value stored in the data
	 * field should be a URL, a file within the current classpath, a file on the
	 * filesystem, or null for no image.
	 *
	 * @@return the data field for image locations, or null for no images
	 */
d196 1
a196 1

d207 1
a207 3
        if ( imageField != null ) {
			m_images = new ImageFactory();
		}
d210 1
a210 1

d218 1
a218 3
        if ( m_images == null ) {
			m_images = new ImageFactory();
		}
d221 1
a221 1

d223 1
a223 1
     * Returns a location string for the image to draw. Subclasses can override
d229 1
a229 1
    protected String getImageLocation(VisualItem<?> item) {
d234 1
a234 1

d240 1
a240 1
    protected Image getImage(VisualItem<?> item) {
d242 1
a242 1
        return imageLoc == null ? null : m_images.getImage(imageLoc);
d244 2
a245 2


d248 2
a249 2

    private String computeTextDimensions(VisualItem<?> item, String text,
d259 1
a259 1

d262 1
a262 1

d271 2
a272 3
                if ( str == null ) {
					str = new StringBuffer(text.substring(0,start));
				}
d287 2
a288 3
            if ( str == null ) {
				str = new StringBuffer(text.substring(0,start));
			}
d296 1
a296 1

d299 1
a299 1

d302 1
a302 1

d306 1
a306 2
    @@Override
	protected Shape getRawShape(VisualItem<?> item) {
d310 1
a310 1

d315 1
a315 1
            iw = img.getWidth(null);
d317 1
a317 1

d323 1
a323 1
            tw = m_textDim.width;
d325 1
a325 1

d329 2
a330 2
        case LEFT:
        case RIGHT:
d335 2
a336 2
        case TOP:
        case BOTTOM:
d345 1
a345 1

d348 1
a348 1

d358 1
a358 1

d363 2
a364 2
    protected static void getAlignedPoint(Point2D p, VisualItem<?> item,
            double w, double h, Alignment xAlign, Alignment yAlign)
d367 8
a374 10
        if ( Double.isNaN(x) || Double.isInfinite(x) ) {
			x = 0; // safety check
		}
        if ( Double.isNaN(y) || Double.isInfinite(y) ) {
			y = 0; // safety check
		}

        if ( xAlign == Alignment.CENTER ) {
            x = x-w/2;
        } else if ( xAlign == Alignment.RIGHT ) {
d377 3
a379 3
        if ( yAlign == Alignment.CENTER ) {
            y = y-h/2;
        } else if ( yAlign == Alignment.BOTTOM ) {
d384 1
a384 1

d388 1
a388 2
    @@Override
	public void render(Graphics2D g, VisualItem<?> item) {
d390 2
a391 4
        if ( shape == null ) {
			return;
		}

d393 3
a395 4
        RenderType type = getRenderType(item);
        if ( type==AbstractShapeRenderer.RenderType.FILL || type==AbstractShapeRenderer.RenderType.DRAW_AND_FILL ) {
			GraphicsLib.paint(g, item, shape, getStroke(item), AbstractShapeRenderer.RenderType.FILL);
		}
d400 4
a403 5

        if ( text == null && img == null ) {
			return;
		}

d409 1
a409 1

d411 1
a411 1
        if ( img != null ) {
d415 1
a415 1

d418 1
a418 1
            case LEFT:
d421 1
a421 1
            case RIGHT:
d424 1
a424 1
            case TOP:
d427 1
a427 1
            case BOTTOM:
d434 1
a434 1

d437 2
a438 2
            case LEFT:
            case RIGHT:
d441 1
a441 1
                case TOP:
d443 1
a443 1
                case BOTTOM:
d446 1
a446 1
                case CENTER:
d451 2
a452 2
            case TOP:
            case BOTTOM:
d455 1
a455 1
                case LEFT:
d457 1
a457 1
                case RIGHT:
d460 1
a460 1
                case CENTER:
d466 1
a466 1

d476 1
a476 1

d487 2
a488 2
            case TOP:
            case BOTTOM:
d494 1
a494 1

d498 2
a499 2
            case LEFT:
            case RIGHT:
d505 1
a505 1

d509 1
a509 1
            case TOP:
d511 1
a511 1
            case BOTTOM:
d514 1
a514 1
            case CENTER:
d517 1
a517 1

d524 1
a524 1
                end = text.indexOf(m_delim, start);
d528 1
a528 1

d530 2
a531 2
        if (type==AbstractShapeRenderer.RenderType.DRAW || type==AbstractShapeRenderer.RenderType.DRAW_AND_FILL) {
            GraphicsLib.paint(g,item,shape,getStroke(item),AbstractShapeRenderer.RenderType.DRAW);
d534 1
a534 1

d541 1
a541 1
        case LEFT:
d544 1
a544 1
        case RIGHT:
d547 1
a547 1
        case CENTER:
d562 1
a562 1

d568 1
a568 3
        if ( m_images == null ) {
			m_images = new ImageFactory();
		}
d571 1
a571 1

d579 1
a579 1

d581 1
a581 1

d583 3
a585 1
     * Get the horizontal text alignment within the layout. The default is centered text.
d588 1
a588 1
    public Alignment getHorizontalTextAlignment() {
d591 1
a591 1

d594 2
a595 2
     * {@@link Alignment#LEFT}, {@@link Alignment#RIGHT}, or
     * {@@link Alignment#CENTER}. The default is centered text.
d598 6
a603 7
    public void setHorizontalTextAlignment(Alignment halign) {
        if ( halign != Alignment.LEFT &&
             halign != Alignment.RIGHT &&
             halign != Alignment.CENTER ) {
			throw new IllegalArgumentException(
			           "Illegal horizontal text alignment value.");
		}
d606 1
a606 1

d609 2
a610 2
     * {@@link Alignment#TOP}, {@@link Alignment#BOTTOM}, or
     * {@@link Alignment#CENTER}. The default is centered text.
d613 1
a613 1
    public Alignment getVerticalTextAlignment() {
d616 1
a616 1

d619 2
a620 2
     * {@@link Alignment#TOP}, {@@link Alignment#BOTTOM}, or
     * {@@link Alignment#CENTER}. The default is centered text.
d623 5
a627 5
    public void setVerticalTextAlignment(Alignment valign) {
        if ( valign != Alignment.TOP &&
             valign != Alignment.BOTTOM &&
             valign != Alignment.CENTER ) {
			throw new IllegalArgumentException(
a628 1
		}
d631 1
a631 1

d634 2
a635 2
     * {@@link Alignment#LEFT}, {@@link Alignment#RIGHT}, or
     * {@@link Alignment#CENTER}. The default is a centered image.
d638 1
a638 1
    public Alignment getHorizontalImageAlignment() {
d641 1
a641 1

d644 2
a645 2
     * {@@link Alignment#LEFT}, {@@link Alignment#RIGHT}, or
     * {@@link Alignment#CENTER}. The default is a centered image.
d648 6
a653 7
    public void setHorizontalImageAlignment(Alignment halign) {
        if ( halign != Alignment.LEFT &&
             halign != Alignment.RIGHT &&
             halign != Alignment.CENTER ) {
			throw new IllegalArgumentException(
			           "Illegal horizontal text alignment value.");
		}
d656 1
a656 1

d659 2
a660 2
     * {@@link Alignment#TOP}, {@@link Alignment#BOTTOM}, or
     * {@@link Alignment#CENTER}. The default is a centered image.
d663 1
a663 1
    public Alignment getVerticalImageAlignment() {
d666 1
a666 1

d669 2
a670 2
     * {@@link Alignment#TOP}, {@@link Alignment#BOTTOM}, or
     * {@@link Alignment#CENTER}. The default is a centered image.
d673 5
a677 5
    public void setVerticalImageAlignment(Alignment valign) {
        if ( valign != Alignment.TOP &&
             valign != Alignment.BOTTOM &&
             valign != Alignment.CENTER ) {
			throw new IllegalArgumentException(
a678 1
		}
d681 1
a681 1

d684 3
a686 1
     * respect to the text. The default is left.
d689 1
a689 1
    public Alignment getImagePosition() {
d692 1
a692 1

d695 3
a697 1
     * respect to the text. The default is left.
d700 8
a707 1
    public void setImagePosition(Alignment pos) {
d710 1
a710 1

d712 1
a712 1

d717 2
a718 2
     * {@@link Alignment#LEFT}, {@@link Alignment#RIGHT}, or
     * {@@link Alignment#CENTER}.
d720 1
a720 1
    public Alignment getHorizontalAlignment() {
d723 1
a723 1

d728 2
a729 2
     * {@@link Alignment#TOP}, {@@link Alignment#BOTTOM}, or
     * {@@link Alignment#CENTER}.
d731 1
a731 1
    public Alignment getVerticalAlignment() {
d734 1
a734 1

d739 4
a742 4
     * {@@link Alignment#LEFT}, {@@link Alignment#RIGHT}, or
     * {@@link Alignment#CENTER}.
     */
    public void setHorizontalAlignment(Alignment align) {
d745 1
a745 1

d750 4
a753 4
     * {@@link Alignment#TOP}, {@@link Alignment#BOTTOM}, or
     * {@@link Alignment#CENTER}.
     */
    public void setVerticalAlignment(Alignment align) {
d756 1
a756 1

d758 1
a758 1
     * Returns the amount of padding in pixels between the content
d765 1
a765 1

d767 1
a767 1
     * Sets the amount of padding in pixels between the content
d774 1
a774 1

d776 1
a776 1
     * Returns the amount of padding in pixels between the content
d783 1
a783 1

d785 1
a785 1
     * Sets the amount of padding in pixels between the content
d792 1
a792 1

d800 1
a800 1

d808 1
a808 17

    /**
     *
     * @@return the maximum line length, or null if there is no maximum
     */
    public Integer getMaxLineLength() {
		return maxLineLength;
	}

    /**
     *
     * @@param maxLineLength the maximum line length
     */
	public void setMaxLineLength(Integer maxLineLength) {
		this.maxLineLength = maxLineLength;
	}

@


2.2.4.2
log
@Moved RenderType outside of AbstractShapeRenderer (it is now a top level enum)
@
text
@d453 2
a454 2
        if ( type==RenderType.FILL || type==RenderType.DRAW_AND_FILL ) {
			GraphicsLib.paint(g, item, shape, getStroke(item), RenderType.FILL);
d591 2
a592 2
        if (type==RenderType.DRAW || type==RenderType.DRAW_AND_FILL) {
            GraphicsLib.paint(g,item,shape,getStroke(item),RenderType.DRAW);
@


2.2.4.3
log
@GraphicsLib is no longer aware of VisualItem. The Renderers now provide the necessary information to GraphicsLib
@
text
@a2 1
import java.awt.Color;
a450 3
        final Color strokeColor = ColorLib.getColor(item.getStrokeColor());
        final Color fillColor = ColorLib.getColor(item.getFillColor());

d454 1
a454 1
			GraphicsLib.paint(g, strokeColor, fillColor, shape, getStroke(item), RenderType.FILL);
d592 1
a592 1
            GraphicsLib.paint(g,strokeColor,fillColor,shape,getStroke(item),RenderType.DRAW);
@


2.2.4.4
log
@changed point at which getImage() is called
@
text
@d363 1
d366 7
a380 11
        // get image dimensions
        final Image  img  = getImage(item);
        final double iw, ih;
        if ( img != null ) {
            ih = img.getHeight(null);
            iw = img.getWidth(null);
        } else {
        	iw = 0;
        	ih = 0;
        }

@


2.2.4.5
log
@made the LabelRenderer more flexible
@
text
@a2 1
import java.awt.BasicStroke;
a444 4
    protected Color getTextColor(VisualItem<?> item) {
    	return ColorLib.getColor(item.getTextColor());
    }

d455 2
a456 3
        final Color strokeColor = getStrokeColor(item);
        final Color fillColor = getFillColor(item);
        final BasicStroke stroke = getStroke(item);
d461 1
a461 1
			GraphicsLib.paint(g, strokeColor, fillColor, shape, stroke, RenderType.FILL);
d546 3
a548 3
        final Color textColor = getTextColor(item);
        if ( text != null && textColor.getAlpha() > 0 ) {
            g.setPaint(textColor);
d560 1
a560 1
                tw = (img != null ? m_textDim.width : shape.getWidth() - 2*size*m_horizBorder);
d571 1
a571 1
                th = (img != null ? m_textDim.height : shape.getHeight() - 2*size*m_vertBorder);
d599 1
a599 1
            GraphicsLib.paint(g,strokeColor,fillColor,shape,stroke,RenderType.DRAW);
@


2.2.4.6
log
@added ability to override the item's font
@
text
@a297 3
    protected Font getFont(VisualItem<?> item) {
    	return item.getFont();
    }
d306 1
a306 1
        m_font = getFont(item);
@


2.1
log
@Added "stroke" visual property for configuring line drawing.
EdgeRenderer now draws directed edges (more) correctly, and allow parameterization of the arrow head size.
@
text
@d3 1
d32 3
a34 1
 * <code>null</code>, no text label will be shown.</p>
d45 9
d59 1
d66 5
d74 1
a74 1
    protected int m_imageMargin = 0;
d87 2
a88 1
    
d179 1
a179 8
            s = item.getString(m_labelName);
            if ( m_maxTextWidth > -1 ) {
                Font font = item.getFont();
                FontMetrics fm = DEFAULT_GRAPHICS.getFontMetrics(font);
                if ( fm.stringWidth(s) > m_maxTextWidth ) {
                    s = StringLib.abbreviate(s, fm, m_maxTextWidth);       
                }
            }
d249 54
d307 1
a307 1
        String text = getText(item);
a309 1
        boolean sizeAdjust = (size != 1);
d320 4
a323 11
        if ( text != null ) {
            // put item font in temp member variable
            m_font = item.getFont();
            // scale the font as needed
            if ( sizeAdjust ) {
                m_font = FontLib.getFont(m_font.getName(), m_font.getStyle(),
                                         size*m_font.getSize());
            }
            FontMetrics fm = DEFAULT_GRAPHICS.getFontMetrics(m_font);
            th = fm.getHeight();
            tw = fm.stringWidth(text);    
d327 18
a344 3
        double w = tw + size*(iw + 2*m_horizBorder
                      + (tw>0 && iw>0 ? m_imageMargin : 0));
        double h = Math.max(th, size*ih) + size*2*m_vertBorder;
d398 1
a398 1
        String text = getText(item);
d408 2
a409 1
            
d414 52
a465 1
            double y = shape.getMinY() + (shape.getHeight()-h)/2;
d470 1
a470 1
                g.drawImage(img, (int)x, (int)y, null);
d472 1
a472 1
                m_transform.setTransform(size,0,0,size,x,y);
a474 2
            
            x += w + (text!=null && w>0 ? size*m_imageMargin : 0);
d478 47
a524 15
        if ( text != null ) {
            int textColor = item.getTextColor();
            if ( ColorLib.alpha(textColor) > 0 ) {
                g.setPaint(ColorLib.getColor(textColor));
                g.setFont(m_font);
                FontMetrics fm = DEFAULT_GRAPHICS.getFontMetrics(m_font);
                double y = shape.getCenterY() - 
                            ((fm.getHeight()>>1)-fm.getAscent());
                if ( useInt ) {
                    // use integer precision unless zoomed-in
                    // results in more stable drawing
                    g.drawString(text, (int)x, (int)y);
                } else {
                    g.drawString(text, (float)x, (float)y);
                }
d526 1
d535 28
d580 87
d668 48
a715 2
     * Get the horizontal alignment of this node with respect to it's
     * location co-ordinate.
d725 2
a726 2
     * Get the vertical alignment of this node with respect to it's
     * location co-ordinate.
d736 2
a737 2
     * Set the horizontal alignment of this node with respect to it's
     * location co-ordinate.
d747 2
a748 2
     * Set the vertical alignment of this node with respect to it's
     * location co-ordinate.
d758 1
a758 1
     * Returns the amount of padding in pixels between text 
d767 1
a767 1
     * Sets the amount of padding in pixels between text 
d776 1
a776 1
     * Returns the amount of padding in pixels between text 
d785 1
a785 1
     * Sets the amount of padding in pixels between text 
d793 16
@


2.0
log
@Merge beta branch back onto main trunk
@
text
@a7 1
import java.awt.Stroke;
d322 1
a322 1
            GraphicsLib.paint(g, item, shape, RENDER_TYPE_FILL);
d375 1
a375 6
            Stroke stroke = g.getStroke();
            Stroke itemStroke = getStroke(item);
            if ( itemStroke != null )
                g.setStroke(itemStroke);
            GraphicsLib.paint(g, item, shape, RENDER_TYPE_DRAW);
            g.setStroke(stroke);
@


1.1
log
@file LabelRenderer.java was initially added on branch beta.
@
text
@d1 482
@


1.1.2.1
log
@Various pre-release edits
Added RadialGraphView
Added new applets
Renamed ShapeRenderer to AbstractShapeRenderer
Renamed ShapeItemRenderer to ShapeRenderer
Merged TextItemRenderer and ImageItemRenderer into LabelRenderer
Removed demo launcher (and commented line in build.xml), will reintroduce demo launcher later
@
text
@a0 470
package prefuse.render;

import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.RectangularShape;
import java.awt.geom.RoundRectangle2D;

import prefuse.Constants;
import prefuse.util.ColorLib;
import prefuse.util.FontLib;
import prefuse.util.GraphicsLib;
import prefuse.util.StringLib;
import prefuse.visual.VisualItem;


/**
 * Renderer that draws a label, which consists of a text string,
 * an image, or both.
 * 
 * <p>When created using the default constructor, the renderer attempts
 * to use text from the "label" field. To use a different field, use the
 * appropriate constructor or use the {@@link #setTextField(String)} method.
 * To perform custom String selection, subclass this Renderer and override the 
 * {@@link #getText(VisualItem)} method. When the text field is
 * <code>null</code>, no text label will be shown.</p>
 * 
 * <p>By default, no image is shown. To show an image, the image field needs
 * to be set, either using the appropriate constructor or the
 * {@@link setImageField(String)} method. The value of the image field should
 * be a text string indicating the location of the image file to use. The
 * string should be either a URL, a file located on the current classpath,
 * or a file on the local filesystem. If found, the image will be managed
 * internally by an {@@link ImageFactory} instance, which maintains a
 * cache of loaded images.</p>
 * 
 * @@author <a href="http://jheer.org">jeffrey heer</a>
 */
public class LabelRenderer extends AbstractShapeRenderer {

    protected ImageFactory m_images = null;
    
    protected String m_labelName = "label";
    protected String m_imageName = null;
    
    protected int m_xAlign = Constants.CENTER;
    protected int m_yAlign = Constants.CENTER;
    
    protected int m_horizBorder = 2;
    protected int m_vertBorder  = 1;
    protected int m_imageMargin = 0;
    protected int m_arcWidth    = 0;
    protected int m_arcHeight   = 0;

    protected int m_maxTextWidth = -1;
    
    /** Transform used to scale and position images */
    AffineTransform m_transform = new AffineTransform();
    
    /** The holder for the currently computed bounding box */
    protected RectangularShape m_bbox  = new Rectangle2D.Double();
    protected Point2D m_pt = new Point2D.Double(); // temp point
    protected Font    m_font; // temp font holder
    

    /**
     * Create a new LabelRenderer. By default the field "label" is used
     * as the field name for looking up text, and no image is used.
     */
    public LabelRenderer() {
    }
    
    /**
     * Create a new LabelRenderer. Draws a text label using the given
     * text data field and does not draw an image.
     * @@param textField the data field for the text label.
     */
    public LabelRenderer(String textField) {
        this.setTextField(textField);
    }
    
    /**
     * Create a new LabelRenderer. Draws a text label using the given text
     * data field, and draws the image at the location reported by the
     * given image data field.
     * @@param textField the data field for the text label
     * @@param imageField the data field for the image location. This value
     * in the data field should be a URL, a file within the current classpath,
     * a file on the filesystem, or null for no image. If the
     * <code>imageField</code> parameter is null, no images at all will be
     * drawn.
     */
    public LabelRenderer(String textField, String imageField) {
        setTextField(textField);
        setImageField(imageField);
    }
    
    // ------------------------------------------------------------------------
    
    /**
     * Rounds the corners of the bounding rectangle in which the text
     * string is rendered. This will only be seen if either the stroke
     * or fill color is non-transparent.
     * @@param arcWidth the width of the curved corner
     * @@param arcHeight the height of the curved corner
     */
    public void setRoundedCorner(int arcWidth, int arcHeight) {
        if ( (arcWidth == 0 || arcHeight == 0) && 
            !(m_bbox instanceof Rectangle2D) ) {
            m_bbox = new Rectangle2D.Double();
        } else {
            if ( !(m_bbox instanceof RoundRectangle2D) )
                m_bbox = new RoundRectangle2D.Double();
            ((RoundRectangle2D)m_bbox)
                .setRoundRect(0,0,10,10,arcWidth,arcHeight);
            m_arcWidth = arcWidth;
            m_arcHeight = arcHeight;
        }
    }

    /**
     * Get the field name to use for text labels.
     * @@return the data field for text labels, or null for no text
     */
    public String getTextField() {
        return m_labelName;
    }
    
    /**
     * Set the field name to use for text labels.
     * @@param textField the data field for text labels, or null for no text
     */
    public void setTextField(String textField) {
        m_labelName = textField;
    }
    
    /**
     * Sets the maximum width that should be allowed of the text label.
     * A value of -1 specifies no limit (this is the default).
     * @@param maxWidth the maximum width of the text or -1 for no limit
     */
    public void setMaxTextWidth(int maxWidth) {
        m_maxTextWidth = maxWidth;
    }
    
    /**
     * Returns the text to draw. Subclasses can override this class to
     * perform custom text selection.
     * @@param item the item to represent as a <code>String</code>
     * @@return a <code>String</code> to draw
     */
    protected String getText(VisualItem item) {
        String s = null;
        if ( item.canGetString(m_labelName) ) {
            s = item.getString(m_labelName);
            if ( m_maxTextWidth > -1 ) {
                Font font = item.getFont();
                FontMetrics fm = DEFAULT_GRAPHICS.getFontMetrics(font);
                if ( fm.stringWidth(s) > m_maxTextWidth ) {
                    s = StringLib.abbreviate(s, fm, m_maxTextWidth);       
                }
            }
        }
        return s;
    }

    // ------------------------------------------------------------------------
    // Image Handling
    
    /**
     * Get the data field for image locations. The value stored
     * in the data field should be a URL, a file within the current classpath,
     * a file on the filesystem, or null for no image.
     * @@return the data field for image locations, or null for no images
     */
    public String getImageField() {
        return m_imageName;
    }
    
    /**
     * Set the data field for image locations. The value stored
     * in the data field should be a URL, a file within the current classpath,
     * a file on the filesystem, or null for no image. If the
     * <code>imageField</code> parameter is null, no images at all will be
     * drawn.
     * @@param imageField the data field for image locations, or null for
     * no images
     */
    public void setImageField(String imageField) {
        if ( imageField != null ) m_images = new ImageFactory();
        m_imageName = imageField;
    }
    
    /**
     * Sets the maximum image dimensions, used to control scaling of loaded
     * images. This scaling is enforced immediately upon loading of the image,
     * to scale the image at rendering time instead, refer to the 
     * {@@link #setImageSize(double) setImageSize} method.
     * @@param width the maximum width of images (-1 for no limit)
     * @@param height the maximum height of images (-1 for no limit)
     */
    public void setMaxImageDimensions(int width, int height) {
        if ( m_images == null ) m_images = new ImageFactory();
        m_images.setMaxImageDimensions(width, height);
    }
    
    /**
     * Returns a location string for the image to draw. Subclasses can override 
     * this class to perform custom image selection beyond looking up the value
     * from a data field.
     * @@param item the item for which to select an image to draw
     * @@return the location string for the image to use, or null for no image
     */
    protected String getImageLocation(VisualItem item) {
        return item.canGetString(m_imageName)
                ? item.getString(m_imageName)
                : null;
    }
    
    /**
     * Get the image to include in the label for the given VisualItem.
     * @@param item the item to get an image for
     * @@return the image for the item, or null for no image
     */
    protected Image getImage(VisualItem item) {
        String imageLoc = getImageLocation(item);
        return ( imageLoc == null ? null : m_images.getImage(imageLoc) );
    }
    
    
    // ------------------------------------------------------------------------
    // Rendering
    
    /**
     * @@see prefuse.render.AbstractShapeRenderer#getRawShape(prefuse.visual.VisualItem)
     */
    protected Shape getRawShape(VisualItem item) {
        String text = getText(item);
        Image  img  = getImage(item);
        double size = item.getSize();
        boolean sizeAdjust = (size != 1);
        
        // get image dimensions
        double iw=0, ih=0;
        if ( img != null ) {
            ih = img.getHeight(null);
            iw = img.getWidth(null);    
        }
        
        // get text dimensions
        int tw=0, th=0;
        if ( text != null ) {
            // put item font in temp member variable
            m_font = item.getFont();
            // scale the font as needed
            if ( sizeAdjust ) {
                m_font = FontLib.getFont(m_font.getName(), m_font.getStyle(),
                                         size*m_font.getSize());
            }
            FontMetrics fm = DEFAULT_GRAPHICS.getFontMetrics(m_font);
            th = fm.getHeight();
            tw = fm.stringWidth(text);    
        }
        
        // get bounding box dimensions
        double w = tw + size*(iw + 2*m_horizBorder
                      + (tw>0 && iw>0 ? m_imageMargin : 0));
        double h = Math.max(th, size*ih) + size*2*m_vertBorder;
        
        // get the top-left point, using the current alignment settings
        getAlignedPoint(m_pt, item, w, h, m_xAlign, m_yAlign);
        
        if ( m_bbox instanceof RoundRectangle2D ) {
            RoundRectangle2D rr = (RoundRectangle2D)m_bbox;
            rr.setRoundRect(m_pt.getX(), m_pt.getY(), w, h,
                            size*m_arcWidth, size*m_arcHeight);
        } else {
            m_bbox.setFrame(m_pt.getX(), m_pt.getY(), w, h);
        }
        return m_bbox;
    }
    
    /**
     * Helper method, which calculates the top-left co-ordinate of an item
     * given the item's alignment.
     */
    protected static void getAlignedPoint(Point2D p, VisualItem item, 
            double w, double h, int xAlign, int yAlign)
    {
        double x = item.getX(), y = item.getY();
        if ( Double.isNaN(x) || Double.isInfinite(x) )
            x = 0; // safety check
        if ( Double.isNaN(y) || Double.isInfinite(y) )
            y = 0; // safety check
        
        if ( xAlign == Constants.CENTER ) {
            x = x-(w/2);
        } else if ( xAlign == Constants.RIGHT ) {
            x = x-w;
        }
        if ( yAlign == Constants.CENTER ) {
            y = y-(h/2);
        } else if ( yAlign == Constants.BOTTOM ) {
            y = y-h;
        }
        p.setLocation(x,y);
    }
    
    /**
     * @@see prefuse.render.Renderer#render(java.awt.Graphics2D, prefuse.visual.VisualItem)
     */
    public void render(Graphics2D g, VisualItem item) {
        RectangularShape shape = (RectangularShape)getShape(item);
        if ( shape == null ) return;
        
        // fill the shape, if requested
        int type = getRenderType(item);
        if ( type==RENDER_TYPE_FILL || type==RENDER_TYPE_DRAW_AND_FILL )
            GraphicsLib.paint(g, item, shape, RENDER_TYPE_FILL);

        // now render the image and text
        String text = getText(item);
        Image  img  = getImage(item);
        
        if ( text == null && img == null )
            return;
                        
        double size = item.getSize();
        double x = shape.getMinX() + size*m_horizBorder;
            
        // render image
        if ( img != null ) {            
            double w = size * img.getWidth(null);
            double h = size * img.getHeight(null);
            double y = shape.getMinY() + (shape.getHeight()-h)/2;
            
            m_transform.setTransform(size,0,0,size,x,y);
            g.drawImage(img, m_transform, null);
            
            x += w + (text!=null && w>0 ? size*m_imageMargin : 0);
        }
        
        // render text
        if ( text != null ) {
            int textColor = item.getTextColor();
            if ( ColorLib.alpha(textColor) > 0 ) {
                g.setPaint(ColorLib.getColor(textColor));
                g.setFont(m_font);
                FontMetrics fm = DEFAULT_GRAPHICS.getFontMetrics(m_font);
                double y = shape.getCenterY() - 
                            ((fm.getHeight()>>1)-fm.getAscent());
                g.drawString(text, (float)x, (float)y);
            }
        }
    
        // draw border
        if (type==RENDER_TYPE_DRAW || type==RENDER_TYPE_DRAW_AND_FILL) {
            Stroke stroke = g.getStroke();
            Stroke itemStroke = getStroke(item);
            if ( itemStroke != null )
                g.setStroke(itemStroke);
            GraphicsLib.paint(g, item, shape, RENDER_TYPE_DRAW);
            g.setStroke(stroke);
        }
    }
    
    /**
     * Returns the image factory used by this renderer.
     * @@return the image factory
     */
    public ImageFactory getImageFactory() {
        if ( m_images == null ) m_images = new ImageFactory();
        return m_images;
    }
    
    /**
     * Sets the image factory used by this renderer.
     * @@param ifact the image factory
     */
    public void setImageFactory(ImageFactory ifact) {
        m_images = ifact;
    }
    
    /**
     * Get the horizontal alignment of this node with respect to it's
     * location co-ordinate.
     * @@return the horizontal alignment, one of
     * {@@link prefuse.Constants#LEFT}, {@@link prefuse.Constants#RIGHT}, or
     * {@@link prefuse.Constants#CENTER}.
     */
    public int getHorizontalAlignment() {
        return m_xAlign;
    }
    
    /**
     * Get the vertical alignment of this node with respect to it's
     * location co-ordinate.
     * @@return the vertical alignment, one of
     * {@@link prefuse.Constants#TOP}, {@@link prefuse.Constants#BOTTOM}, or
     * {@@link prefuse.Constants#CENTER}.
     */
    public int getVerticalAlignment() {
        return m_yAlign;
    }
    
    /**
     * Set the horizontal alignment of this node with respect to it's
     * location co-ordinate.
     * @@param align the horizontal alignment, one of
     * {@@link prefuse.Constants#LEFT}, {@@link prefuse.Constants#RIGHT}, or
     * {@@link prefuse.Constants#CENTER}.
     */ 
    public void setHorizontalAlignment(int align) {
        m_xAlign = align;
    }
    
    /**
     * Set the vertical alignment of this node with respect to it's
     * location co-ordinate.
     * @@param align the vertical alignment, one of
     * {@@link prefuse.Constants#TOP}, {@@link prefuse.Constants#BOTTOM}, or
     * {@@link prefuse.Constants#CENTER}.
     */ 
    public void setVerticalAlignment(int align) {
        m_yAlign = align;
    }
    
    /**
     * Returns the amount of padding in pixels between text 
     * and the border of this item along the horizontal dimension.
     * @@return the horizontal padding
     */
    public int getHorizontalPadding() {
        return m_horizBorder;
    }
    
    /**
     * Sets the amount of padding in pixels between text 
     * and the border of this item along the horizontal dimension.
     * @@param xpad the horizontal padding to set
     */
    public void setHorizontalPadding(int xpad) {
        m_horizBorder = xpad;
    }
    
    /**
     * Returns the amount of padding in pixels between text 
     * and the border of this item along the vertical dimension.
     * @@return the vertical padding
     */
    public int getVerticalPadding() {
        return m_vertBorder;
    }
    
    /**
     * Sets the amount of padding in pixels between text 
     * and the border of this item along the vertical dimension.
     * @@param ypad the vertical padding
     */
    public void setVerticalPadding(int ypad) {
        m_vertBorder = ypad;
    }
    
} // end of class LabelRenderer
@


1.1.2.2
log
@Changed interaction mechanism of RotationControl
Added documentation of expression language to ExpressionParser javadoc
Added inclusion of edge arrows in bounds computation for EdgeRenderer
Added integer dimensions check to LabelRenderer
Added new readme file
@
text
@d36 1
a36 1
 * {@@link #setImageField(String)} method. The value of the image field should
d56 1
a56 1
    protected int m_vertBorder  = 0;
d202 3
a204 1
     * images. This scaling is enforced immediately upon loading of the image.
a334 2
        boolean useInt = 1.5 > Math.max(g.getTransform().getScaleX(),
                                        g.getTransform().getScaleY());
d343 2
a344 8
            if ( useInt && size == 1.0 ) {
                // if possible, use integer precision
                // results in faster, flicker-free image rendering
                g.drawImage(img, (int)x, (int)y, null);
            } else {
                m_transform.setTransform(size,0,0,size,x,y);
                g.drawImage(img, m_transform, null);
            }
d358 1
a358 7
                if ( useInt ) {
                    // use integer precision unless zoomed-in
                    // results in more stable drawing
                    g.drawString(text, (int)x, (int)y);
                } else {
                    g.drawString(text, (float)x, (float)y);
                }
@


